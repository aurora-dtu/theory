import Mathlib.MeasureTheory.Constructions.BorelSpace.Basic
import Mathlib.MeasureTheory.SetAlgebra
import Mathlib.Order.CompletePartialOrder
import Mathlib.Topology.MetricSpace.Polish
import Mathlib.Topology.Instances.CantorSet

/-!

# Cantor

This file defines the Cantor-space and its components.

## Main definitions

- [`B[h]`](find/?pattern=ProbNetKAT.B_h#doc): The subbasic sets of the Cantor space topology
  (denoted $B_h$ in the paper).
- [`B{b}`](find/?pattern=ProbNetKAT.B_b#doc): The subbasic sets extended to sets of the Cantor space
  topology (denoted $B_b$ in the paper).
- `ℬ`: The smallest σ-algebra generated by the Cantor-open sets.
- `ℬ.cantorSpace`: The Cantor space topology.
- `ℬ.borel`: The Borel measurable space generated from the Cantor space topology.
- [`ℬ{b}`](find/?pattern=ProbNetKAT.ℬ_b#doc): The smallest Set Algebra generated by `{B[h] | h ∈ b}`
  (denoted $ℬ_b$ in the paper).
- [`A{a,b}`](find/?pattern=ProbNetKAT.A_ab#doc): The atoms of `ℬ{b}`.

-/

set_option grind.warning false

namespace ProbNetKAT

open Topology MeasureTheory

variable {P : Type} [Countable P]

abbrev H P := List P

notation "H[" P "]" => H P

/-! ## The subbasic sets `B[h]` and `B{b}` -/

/-- **Equation (1.1)**

$$B[h] = \{ c ∣ h ∈ c \}$$
-/
def B_h (h : H P) := {c : Set H[P] | h ∈ c}
/-- **Equation (1.1)**

$$B\{b\} = \{ c ∣ b ⊆ c \}$$
-/
def B_b (b : Set H[P]) := {c : Set H[P] | b ⊆ c}

@[inherit_doc] notation "B[" h "]" => B_h h
@[inherit_doc] notation "B{" b "}" => B_b b

@[simp] theorem B_b_h_eq_B_h : B{{h}} = B[h] := by simp [B_h, B_b]
/-- **Lemma 1.** (i) -/
@[simp] theorem B_b_subset_iff : B{c} ⊆ B{b} ↔ b ⊆ c := by
  simp [B_b]; exact ⟨(· c (by rfl)), fun h _ h' ↦ subset_trans h h'⟩
/-- **Lemma 1.** (ii) -/
@[simp] theorem B_b_union_eq_inter : B{b ∪ c} = B{b} ∩ B{c} := by ext a; simp [B_b]
/-- **Lemma 1.** (iii) -/
@[simp] theorem B_b_empty : B{(∅ : Set H[P])} = Set.univ := by ext a; simp [B_b]

@[simp]
def ℬ.generatingSet : Set (Set (Set H[P])) := ({B[h] | h} ∪ {B[h]ᶜ | h})

/-- The sets `B[h]` and `B[h]ᶜ` are the subbasic open sets of the Cantor space topology on 2H. -/
def ℬ.cantorSpace : TopologicalSpace (Set H[P]) :=
  TopologicalSpace.generateFrom generatingSet
/-- The Borel measurable space generated by the Cantor-topology. -/
def ℬ.borel : MeasurableSpace (Set H[P]) := @_root_.borel _ ℬ.cantorSpace

theorem ℬ.generatingSet_countable : ({B[(h : H[P])] | h} ∪ {B[h]ᶜ | h}).Countable := by
  have : {B[(h : H[P])] | h} = ((B[·]) '' Set.univ) := by ext; simp
  have : {B[(h : H[P])]ᶜ | h} = ((B[·]ᶜ) '' Set.univ) := by ext; simp
  simp [Set.countable_range, *]

open scoped Classical in
noncomputable def ℬ.dist : Set H[P] → Set H[P] → ℝ := fun a b ↦
  if a = b then 0 else (1 : ℝ) / 2^(⨅ s ∈ symmDiff a b, s.length)

@[simp]
noncomputable instance ℬ.instDist : Dist (Set H[P]) := ⟨dist⟩


/-- The Cantor space $2^H$ is second countable. -/
instance ℬ.secondCountable : @SecondCountableTopology (Set H[P]) ℬ.cantorSpace :=
  letI := (ℬ.cantorSpace (P:=P))
  ⟨Exists.intro _ ⟨ℬ.generatingSet_countable, rfl⟩⟩

@[simp]
noncomputable instance ℬ.pseudoMetricSpace : PseudoMetricSpace (Set H[P]) where
  dist_self := by simp [dist]
  dist_comm x y := by simp [dist, symmDiff_comm]; split_ifs <;> simp_all
  dist_triangle x y z := by
    simp [dist]
    split_ifs <;> subst_eqs <;> try simp_all
    · apply Right.add_nonneg <;> simp
    · sorry
      -- generalize h₁ : dist (symmDiff x y) z = d₁
      -- generalize h₂ : dist x (symmDiff y z) = d₂
      -- simp_all [dist, symmDiff_assoc]

example : sInf (∅ : Set ℕ) = 0 := by simp

noncomputable def ℬ.metricSpace : MetricSpace (Set H[P]) := by
  refine { toPseudoMetricSpace := pseudoMetricSpace, eq_of_dist_eq_zero := ?_ }
  intro x y
  simp [pseudoMetricSpace, dist]

noncomputable instance ℬ.uniformSpace : UniformSpace (Set H[P]) :=
  PseudoMetricSpace.toUniformSpace

instance ℬ.isCompletelyMetrizableSpace :
    @TopologicalSpace.IsCompletelyMetrizableSpace (Set H[P]) ℬ.cantorSpace := by
  letI := ℬ.cantorSpace (P:=P)
  -- letI : UniformSpace (Set H[P]) := ℬ.uniformSpace
  refine { complete := ?_ }
  use ℬ.metricSpace
  constructor
  · refine TopologicalSpace.ext ?_
    ext x
    constructor
    · intro h
      sorry
    · intro h
      sorry

  · refine completeSpace_iff_isComplete_univ.mpr ?_
    sorry

/-- The Cantor space $2^H$ is a Polish space. -/
instance ℬ.polishSpace : @PolishSpace (Set H[P]) ℬ.cantorSpace :=
  letI := ℬ.cantorSpace (P:=P)
  letI : SecondCountableTopology (Set H[P]) := ℬ.secondCountable
  instPolishSpaceOfSeparableSpaceOfIsCompletelyMetrizableSpace

/-! ## The Set Algebra `ℬ` -/

/-- The family of Borel sets `ℬ` is the smallest σ-algebra containing the Cantor-open sets.

The theorem `ℬ_is_borel` establishes this connection.
-/
def ℬ : Set (Set (Set H[P])) := generateSetAlgebra ℬ.cantorSpace.IsOpen

omit [Countable P] in
section

@[simp] theorem ℬ_IsSetAlgebra : IsSetAlgebra (ℬ (P:=P)) := isSetAlgebra_generateSetAlgebra
@[simp] theorem ℬ_IsSetRing : IsSetRing (ℬ (P:=P)) := ℬ_IsSetAlgebra.isSetRing
@[simp] theorem ℬ_IsSetSemiring : IsSetSemiring (ℬ (P:=P)) := ℬ_IsSetRing.isSetSemiring
@[simp] theorem ℬ_mem_empty : ∅ ∈ (ℬ (P:=P)) := generateSetAlgebra.empty
@[simp] theorem ℬ_mem_univ : Set.univ ∈ (ℬ (P:=P)) := IsSetAlgebra.univ_mem ℬ_IsSetAlgebra
@[simp] theorem ℬ_mem_compl : sᶜ ∈ (ℬ (P:=P)) ↔ s ∈ (ℬ (P:=P)) := by
  constructor
  · intro h
    have := generateSetAlgebra.compl _ h
    simp_all
    exact this
  · intro h; apply generateSetAlgebra.compl _ h
@[simp] theorem ℬ_mem_union : s ∈ (ℬ (P:=P)) ∧ t ∈ (ℬ (P:=P)) → s ∪ t ∈ (ℬ (P:=P)) := by
  intro h; apply generateSetAlgebra.union _ _ h.left h.right
@[simp] theorem ℬ_mem_inter : s ∈ (ℬ (P:=P)) ∧ t ∈ (ℬ (P:=P)) → s ∩ t ∈ (ℬ (P:=P)) := by
  intro h; apply IsSetAlgebra.inter_mem ℬ_IsSetAlgebra h.left h.right

/-- All set `B[b]` are open in the Cantor-space topology. -/
@[simp] theorem B_b_IsOpen_of_mem : IsOpen[ℬ.cantorSpace] B[b] := by
  refine TopologicalSpace.isOpen_generateFrom_of_mem ?_
  simp

/-- All set `B[b]` are closed in the Cantor-space topology. -/
@[simp] theorem B_b_IsClosed_of_mem : IsClosed[ℬ.cantorSpace] B[b] :=
  (@isOpen_compl_iff _ _ ℬ.cantorSpace).mp (TopologicalSpace.isOpen_generateFrom_of_mem (by simp))

@[simp] theorem ℬ.isClosed_of_isOpen (h : IsOpen[ℬ.cantorSpace] S) : IsClosed[ℬ.cantorSpace] S := by
  induction h with
  | basic s hs =>
    simp_all
    obtain (⟨w, hw⟩ | ⟨w, hw⟩) := hs
    all_goals (subst_eqs; simp_all)
  | univ => exact @isClosed_univ _ ℬ.cantorSpace
  | inter _ _ _ _ ih₁ ih₂ => exact @IsClosed.inter _ _ _ ℬ.cantorSpace ih₁ ih₂
  | sUnion S hsS ih =>
    sorry

/-- From [Wikipedia](https://en.wikipedia.org/wiki/Clopen_set#Properties):

> Using the union and intersection as operations, the clopen subsets of a given topological space X
> form a Boolean algebra. Every Boolean algebra can be obtained in this way from a suitable
> topological space: see Stone's representation theorem for Boolean algebras.
-/
@[simp] theorem ℬ.isClosed_iff_isOpen : IsClosed[ℬ.cantorSpace] S ↔ IsOpen[ℬ.cantorSpace] S := by
  constructor
  · intro h
    apply (@isOpen_compl_iff _ _ ℬ.cantorSpace).mpr at h
    generalize h' : Sᶜ = S'
    suffices IsOpen[ℬ.cantorSpace] S'ᶜ by subst_eqs; simp_all
    simp_all
  · simp_all

/-- All set in `ℬ` are open in the Cantor-space topology. -/
theorem ℬ.IsOpen_of_mem (h : b ∈ ℬ) : IsOpen[ℬ.cantorSpace] b := by
  induction h with
  | base s s_mem => exact s_mem
  | empty => simp
  | compl y hy ih => simp_all
  | union _ _ _ _ ih₁ ih₂ =>
    exact @IsOpen.union _ _ _ ℬ.cantorSpace ih₁ ih₂

/-- The family of Borel sets `ℬ` is the smallest σ-algebra containing the Cantor-open sets. -/
theorem ℬ_is_borel : S ∈ ℬ ↔ MeasurableSet[ℬ.borel] S := by
  constructor
  · intro h
    induction h with
    | base s s_mem => exact MeasurableSpace.measurableSet_generateFrom s_mem
    | empty => simp
    | compl _ _ ih => exact MeasurableSet.compl_iff.mpr ih
    | union => exact MeasurableSet.union (by assumption) (by assumption)
  · intro h
    induction h with
    | basic s s_mem => exact generateSetAlgebra.base s s_mem
    | empty => simp
    | compl _ _ ih => exact IsSetAlgebra.compl_mem ℬ_IsSetAlgebra ih
    | iUnion f h₁ h₂ =>
      apply MeasureTheory.self_subset_generateSetAlgebra (@isOpen_iUnion _ _ ℬ.cantorSpace _ _)
      exact fun i ↦ ℬ.IsOpen_of_mem (h₂ i)

/-! ## The Set Algebra `ℬ{b}` -/

/-- Let `ℬ{b}` be the Boolean subalgebra of `ℬ` generated by `{B[h] | h ∈ b}`. -/
def ℬ_b (b : Set H[P]) := generateSetAlgebra {B[h] | h ∈ b}
@[inherit_doc] notation "ℬ{" b "}" => ℬ_b b

theorem ℬ_b_mono {a b : Set H[P]} (h : a ⊆ b) : ℬ{a} ⊆ ℬ{b} := by
  apply generateSetAlgebra_mono
  simp only [Set.setOf_subset_setOf, forall_exists_index, and_imp, forall_apply_eq_imp_iff₂]
  exact fun x hx ↦ ⟨x, h hx, rfl⟩

@[simp] theorem ℬ_b_IsSetAlgebra : IsSetAlgebra (ℬ{b}) := isSetAlgebra_generateSetAlgebra
@[simp] theorem ℬ_b_IsSetRing : IsSetRing (ℬ{b}) := ℬ_b_IsSetAlgebra.isSetRing
@[simp] theorem ℬ_b_IsSetSemiring : IsSetSemiring (ℬ{b}) := ℬ_b_IsSetRing.isSetSemiring
@[simp] theorem ℬ_b_mem_empty {b : Set H[P]} : ∅ ∈ ℬ{b} := generateSetAlgebra.empty
@[simp] theorem ℬ_b_mem_univ {b : Set H[P]} : Set.univ ∈ ℬ{b} :=
  IsSetAlgebra.univ_mem ℬ_b_IsSetAlgebra
@[simp] theorem ℬ_b_mem_compl {b : Set H[P]} : sᶜ ∈ ℬ{b} ↔ s ∈ ℬ{b} := by
  constructor
  · intro h
    rw [← compl_compl (x:=s)]
    exact IsSetAlgebra.compl_mem (by simp) h
  · intro h; apply generateSetAlgebra.compl _ h
@[simp] theorem ℬ_b_mem_union {b : Set H[P]} : s ∈ ℬ{b} ∧ t ∈ ℬ{b} → s ∪ t ∈ ℬ{b} :=
  fun h ↦ generateSetAlgebra.union _ _ h.left h.right
@[simp] theorem ℬ_b_mem_inter {b : Set H[P]} : s ∈ ℬ{b} ∧ t ∈ ℬ{b} → s ∩ t ∈ ℬ{b} :=
  fun h ↦ IsSetAlgebra.inter_mem ℬ_b_IsSetAlgebra h.left h.right

@[simp] theorem B_h_mem_ℬ_b_univ : B[i] ∈ ℬ{Set.univ} := by
  apply generateSetAlgebra.base; use i; simp
@[simp] theorem B_h_mem_ℬ_b (hi : i ∈ b) : B[i] ∈ ℬ{b} := by apply generateSetAlgebra.base; use i
@[simp] theorem B_h_mem_ℬ : B[i] ∈ ℬ := generateSetAlgebra.base _ B_b_IsOpen_of_mem

/-- If `b` is finite, so is `ℬ{b}`. -/
theorem ℬ_b_finite_of_finite (h : b.Finite) : ℬ{b}.Finite := sorry

/-- For a set `X`, we let `℘ω(X)` denote the finite subsets of `X`. -/
def ℘ω (X : Set α) := {Y ⊆ X | Y.Finite}

/-- **Lemma 1.** (iv) -/
theorem ℬ_b_eq_iUnion : ℬ{(Set.univ : Set H[P])} = ⋃ b ∈ ℘ω Set.univ, ℬ{b} := by
  ext A
  simp only [℘ω, Set.subset_univ, true_and, Set.mem_setOf_eq, Set.mem_iUnion, exists_prop]
  constructor
  · intro h
    induction h with
    | base B hB =>
      obtain ⟨h, hh⟩ := hB
      use {h}, Set.finite_singleton h
      exact generateSetAlgebra.base _ (by simp_all)
    | empty => use {}; simp
    | compl B hB ih =>
      obtain ⟨C, hC, hC'⟩ := ih
      use C, hC
      exact generateSetAlgebra.compl _ hC'
    | union B C hB hC ihB ihC =>
      replace hB : B ∈ ℬ{Set.univ} := hB
      replace hC : C ∈ ℬ{Set.univ} := hC
      obtain ⟨X, hX₁, hX₂⟩ := ihB
      obtain ⟨Y, hY₁, hY₂⟩ := ihC
      use X ∪ Y
      constructor
      · exact Set.Finite.union hX₁ hY₁
      · apply generateSetAlgebra.union _ _ <;> show _ ∈ ℬ{X ∪ Y}
        · apply generateSetAlgebra_mono _ hX₂
          simp_all only [Set.mem_union, Set.setOf_subset_setOf, forall_exists_index, and_imp,
            forall_apply_eq_imp_iff₂]
          intro h hh; use h
          simp_all only [true_or, and_self]
        · apply generateSetAlgebra_mono _ hY₂
          simp_all only [Set.mem_union, Set.setOf_subset_setOf, forall_exists_index, and_imp,
            forall_apply_eq_imp_iff₂]
          intro h hh; use h
          simp_all only [or_true, and_self]
  · rintro ⟨B, hB, hB'⟩; apply MeasureTheory.generateSetAlgebra_mono (by simp) hB'

theorem ℬ_b_mem_iff_exists : B ∈ ℬ{(Set.univ : Set H[P])} ↔ ∃ i, i.Finite ∧ B ∈ ℬ{i} := by
  simp [ℬ_b_eq_iUnion, ℘ω]

end

@[simp]
theorem ℬ_borel_le_generateFrom :
    ℬ.borel (P:=P) ≤ MeasurableSpace.generateFrom ℬ{Set.univ} := by
  simp [ℬ.borel]
  rw [@borel_eq_generateFrom_of_subbasis _ _ ℬ.cantorSpace ℬ.secondCountable rfl]
  refine MeasurableSpace.generateFrom_mono ?_
  simp_all
  constructor
  all_goals intro a; simp_all; rintro _ ⟨_⟩; simp

/-! ## The atoms `A{a,b}` -/

/-- The atoms of `ℬ{b}` are in one-to-one correspondence with the subsets `a ⊆ b`, the subset `a`
    determining which `B[h]` occur positively in the construction of the atom:

```
A{a,b} = ⋂ h ∈ a, B[h] ∩ ⋂ h ∈ b \ a, B[h]ᶜ = B{a} \ ⋃ a ⊂ c ∧ c ⊆ b, B{c} = {c | a = c ∩ b}
```

Formulated in in `A_ab_eq₁`, `A_ab_eq₂`, and, `A_ab_eq₃`.
-/
def A_ab (a b : Set H[P]) := {c | a = c ∩ b}
@[inherit_doc] notation "A{" a "," b "}" => A_ab a b

/-- **Definition (i)** of `A{a,b}`. -/
def A_ab_eq₁ (hab : a ⊆ b) : A{a,b} = (⋂ h ∈ a, B[h]) ∩ (⋂ h ∈ (b \ a), B[h]ᶜ) := by
  ext c
  simp only [A_ab, Set.mem_setOf_eq, B_h, Set.mem_diff, Set.mem_inter_iff, Set.mem_iInter,
    Set.mem_compl_iff, and_imp]
  constructor
  · rintro ⟨_⟩
    simp_all only [Set.mem_inter_iff, implies_true, and_true, not_false_eq_true, and_self]
  · simp_all only [and_imp]
    intro h h'
    simp [not_imp_not] at h'
    replace h' : ∀ i, i ∈ b → i ∈ c → i ∈ a := h'
    replace h' : ∀ i, i ∈ c → i ∈ b → i ∈ a := by exact fun i h₁ h₂ => h' i h₂ h₁
    ext v
    simp_all
    constructor
    · intro h₁
      exact ⟨h v h₁, hab h₁⟩
    · intro ⟨h₁, h₂⟩
      exact h' v h₁ h₂

/-- **Definition (ii)** of `A{a,b}`. -/
theorem A_ab_eq₂ (hab : a ⊆ b) : A{a,b} = B{a} \ ⋃ (c : {c | a ⊂ c ∧ c ⊆ b}), B{c} := by
  ext c
  constructor
  · rintro ⟨_⟩
    simp [A_ab, B_b]
    intro c hcbc hcb
    contrapose! hcbc
    simp_all [not_ssubset_of_subset]
  · simp_all [A_ab_eq₁ hab, B_h, B_b]
    intro h h'
    contrapose h'
    simp_all
    replace h' := h' h
    obtain ⟨w, hwb, hwa, hwc⟩ := h'
    use (b ∩ c) ∪ {w}
    constructor
    · simp
      refine (Set.ssubset_iff_of_subset ?_).mpr ?_
      · simp_all
      · use w; simp_all
    · simp_all

/-- **Definition (iii)** of `A{a,b}`. -/
theorem A_ab_eq₃ (_hab : a ⊆ b) : A{a,b} = {c | a = c ∩ b} := rfl

@[simp] theorem A_ab_a_mem (hab : a ⊆ b) : a ∈ A{a,b} := by simp [hab, A_ab]

@[simp] theorem A_ab_same_eq_B_b : A{b,b} = B{b} := by ext; simp [A_ab_eq₃, B_b]

omit [Countable P] in
theorem A_ab_mem_ℬ_b {a b : Set H[P]} (hb : b.Finite) (hab : a ⊆ b) : A{a,b} ∈ ℬ{b} := by
  rw [A_ab_eq₁ hab]
  refine ℬ_b_mem_inter ?_
  constructor
  · have : a.Finite := Set.Finite.subset hb hab
    have := IsSetAlgebra.biInter_mem (𝒜:=ℬ{b}) (S:=this.toFinset) (s:=B_h)
    simp_all
    apply this
    intro i hi
    exact B_h_mem_ℬ_b (hab hi)
  · have : (b \ a).Finite := Set.Finite.diff hb
    have := IsSetAlgebra.biInter_mem (𝒜:=ℬ{b}) (S:=this.toFinset) (s:=(B[·]ᶜ))
    simp_all

omit [Countable P] in
theorem A_ab_mem_ℬ {a b : Set H[P]} (hb : b.Finite) (hab : a ⊆ b) : A{a,b} ∈ ℬ := by
  rw [A_ab_eq₁ hab]
  apply IsSetAlgebra.inter_mem (by simp)
  · have : a.Finite := Set.Finite.subset hb hab
    have := IsSetAlgebra.biInter_mem (𝒜:=ℬ) (S:=this.toFinset) (s:=B_h) (by simp)
    simp_all
  · have : (b \ a).Finite := Set.Finite.diff hb
    have := IsSetAlgebra.biInter_mem (𝒜:=ℬ) (S:=this.toFinset) (s:=(B[·]ᶜ))
    simp_all

/-- **Lemma 2.** -/
theorem B_b_eq_iUnion_A_ab (hab : a ⊆ b) : B{a} = ⋃ c ∈ {c | a ⊆ c ∧ c ⊆ b}, A{c,b} := by
  symm
  calc
    ⋃ c ∈ {c | a ⊆ c ∧ c ⊆ b}, A{c,b} = ⋃ c ∈ {c | a ⊆ c ∧ c ⊆ b}, {d | c = d ∩ b} := by simp [A_ab]
    _ = {d | a ⊆ d} := by ext; simp_all

/-- **Lemma 2.** rephrased for `B[h]` -/
theorem B_h_eq_iUnion_A_ab (hab : a ∈ b) : B[a] = ⋃ c ∈ {c | a ∈ c ∧ c ⊆ b}, A{c,b} := by
  have := B_b_eq_iUnion_A_ab (by simp [hab] : {a} ⊆ b)
  simp_all

/-- **Lemma 3.** (i) -/
theorem A_ab_subset_iff (hab : a ⊆ b) (hab' : a' ⊆ b') :
    A{a,b} ⊆ A{a',b'} ↔ a' ⊆ a ∧ b' \ a' ⊆ b \ a := by
  sorry

/-- **Lemma 3.** (ii) -/
theorem A_ab_rel (hab : a ⊆ b) (hab' : a' ⊆ b') :
    A{a,b} ⊆ A{a',b'} ∨ A{a',b'} ⊆ A{a,b} ∨ A{a,b} ∩ A{a',b'} = ∅ := by
  by_contra q
  simp at q
  obtain ⟨q₁, q₂, q₃⟩ := q
  sorry

end ProbNetKAT
