import Mathlib.MeasureTheory.Constructions.BorelSpace.Basic
import Mathlib.MeasureTheory.SetAlgebra
import Mathlib.Order.CompletePartialOrder
import Mathlib.Topology.MetricSpace.Polish

/-!

# Cantor

This file defines the Cantor-space and its components.

## Main definitions

- [`B[h]`](find/?pattern=ProbNetKAT.B_h#doc): The subbasic sets of the Cantor space topology
  (denoted $B_h$ in the paper).
- [`B{b}`](find/?pattern=ProbNetKAT.B_b#doc): The subbasic sets extended to sets of the Cantor space
  topology (denoted $B_b$ in the paper).
- `â„¬`: The smallest Ïƒ-algebra generated by the Cantor-open sets.
- `â„¬.cantorSpace`: The Cantor space topology.
- `â„¬.borel`: The Borel measurable space generated from the Cantor space topology.
- [`â„¬{b}`](find/?pattern=ProbNetKAT.â„¬_b#doc): The smallest Set Algebra generated by `{B[h] | h âˆˆ b}`
  (denoted $â„¬_b$ in the paper).
- [`A{a,b}`](find/?pattern=ProbNetKAT.A_ab#doc): The atoms of `â„¬{b}`.

-/

set_option grind.warning false

namespace ProbNetKAT

open Topology MeasureTheory

variable {H : Type}

/-! ## The subbasic sets `B[h]` and `B{b}` -/

/-- **Equation (1.1)**

$$B[h] = \{ c âˆ£ h âˆˆ c \}$$
-/
def B_h (h : H) := {c : Set H | h âˆˆ c}
/-- **Equation (1.1)**

$$B\{b\} = \{ c âˆ£ b âŠ† c \}$$
-/
def B_b (b : Set H) := {c : Set H | b âŠ† c}

@[inherit_doc] notation "B[" h "]" => B_h h
@[inherit_doc] notation "B{" b "}" => B_b b

@[simp] theorem B_b_h_eq_B_h : B{{h}} = B[h] := by simp [B_h, B_b]
/-- **Lemma 1.** (i) -/
@[simp] theorem B_b_subset_iff : B{c} âŠ† B{b} â†” b âŠ† c := by
  simp [B_b]; exact âŸ¨(Â· c (by rfl)), fun h _ h' â†¦ subset_trans h h'âŸ©
/-- **Lemma 1.** (ii) -/
@[simp] theorem B_b_union_eq_inter : B{b âˆª c} = B{b} âˆ© B{c} := by ext a; simp [B_b]
/-- **Lemma 1.** (iii) -/
@[simp] theorem B_b_empty : B{(âˆ… : Set H)} = Set.univ := by ext a; simp [B_b]

/-- The sets `B[h]` and `B[h]á¶œ` are the subbasic open sets of the Cantor space topology on 2H. -/
def â„¬.cantorSpace : TopologicalSpace (Set H) :=
  TopologicalSpace.generateFrom ({B[h] | h} âˆª {B[h]á¶œ | h})
/-- The Borel measurable space generated by the Cantor-topology. -/
def â„¬.borel : MeasurableSpace (Set H) := @_root_.borel _ â„¬.cantorSpace

/-- The Cantor space $2^H$ is a Polish space. -/
instance â„¬.polishSpace : @PolishSpace (Set H) â„¬.cantorSpace := sorry

/-- The Cantor space $2^H$ is second countable. -/
instance â„¬.secondCountable : @SecondCountableTopology (Set H) â„¬.cantorSpace :=
  PolishSpace.toSecondCountableTopology

/-! ## The Set Algebra `â„¬` -/

/-- The family of Borel sets `â„¬` is the smallest Ïƒ-algebra containing the Cantor-open sets.

The theorem `â„¬_is_borel` establishes this connection.
-/
def â„¬ : Set (Set (Set H)) := generateSetAlgebra â„¬.cantorSpace.IsOpen

@[simp] theorem â„¬_IsSetAlgebra : IsSetAlgebra (â„¬ (H:=H)) := isSetAlgebra_generateSetAlgebra
@[simp] theorem â„¬_IsSetRing : IsSetRing (â„¬ (H:=H)) := â„¬_IsSetAlgebra.isSetRing
@[simp] theorem â„¬_IsSetSemiring : IsSetSemiring (â„¬ (H:=H)) := â„¬_IsSetRing.isSetSemiring
@[simp] theorem â„¬_mem_empty : âˆ… âˆˆ (â„¬ (H:=H)) := generateSetAlgebra.empty
@[simp] theorem â„¬_mem_univ : Set.univ âˆˆ (â„¬ (H:=H)) := IsSetAlgebra.univ_mem â„¬_IsSetAlgebra
@[simp] theorem â„¬_mem_compl : sá¶œ âˆˆ (â„¬ (H:=H)) â†” s âˆˆ (â„¬ (H:=H)) := by
  constructor
  Â· intro h
    have := generateSetAlgebra.compl _ h
    simp_all
    exact this
  Â· intro h; apply generateSetAlgebra.compl _ h
@[simp] theorem â„¬_mem_union : s âˆˆ (â„¬ (H:=H)) âˆ§ t âˆˆ (â„¬ (H:=H)) â†’ s âˆª t âˆˆ (â„¬ (H:=H)) := by
  intro h; apply generateSetAlgebra.union _ _ h.left h.right
@[simp] theorem â„¬_mem_inter : s âˆˆ (â„¬ (H:=H)) âˆ§ t âˆˆ (â„¬ (H:=H)) â†’ s âˆ© t âˆˆ (â„¬ (H:=H)) := by
  intro h; apply IsSetAlgebra.inter_mem â„¬_IsSetAlgebra h.left h.right

/-- All set `B[b]` are open in the Cantor-space topology. -/
@[simp] theorem B_b_IsOpen_of_mem : IsOpen[â„¬.cantorSpace] B[b] := by
  refine TopologicalSpace.isOpen_generateFrom_of_mem ?_
  simp

/-- All set `B[b]` are closed in the Cantor-space topology. -/
@[simp] theorem B_b_IsClosed_of_mem : IsClosed[â„¬.cantorSpace] B[b] :=
  (@isOpen_compl_iff _ _ â„¬.cantorSpace).mp (TopologicalSpace.isOpen_generateFrom_of_mem (by simp))

@[simp] theorem â„¬.isClosed_of_isOpen (h : IsOpen[â„¬.cantorSpace] S) : IsClosed[â„¬.cantorSpace] S := by
  induction h with
  | basic s hs =>
    simp_all
    obtain (âŸ¨w, hwâŸ© | âŸ¨w, hwâŸ©) := hs
    all_goals (subst_eqs; simp_all)
  | univ => exact @isClosed_univ _ â„¬.cantorSpace
  | inter _ _ _ _ ihâ‚ ihâ‚‚ => exact @IsClosed.inter _ _ _ â„¬.cantorSpace ihâ‚ ihâ‚‚
  | sUnion S hsS ih =>
    sorry

/-- From [Wikipedia](https://en.wikipedia.org/wiki/Clopen_set#Properties):

> Using the union and intersection as operations, the clopen subsets of a given topological space X
> form a Boolean algebra. Every Boolean algebra can be obtained in this way from a suitable
> topological space: see Stone's representation theorem for Boolean algebras.
-/
@[simp] theorem â„¬.isClosed_iff_isOpen : IsClosed[â„¬.cantorSpace] S â†” IsOpen[â„¬.cantorSpace] S := by
  constructor
  Â· intro h
    apply (@isOpen_compl_iff _ _ â„¬.cantorSpace).mpr at h
    generalize h' : Sá¶œ = S'
    suffices IsOpen[â„¬.cantorSpace] S'á¶œ by subst_eqs; simp_all
    simp_all
  Â· simp_all

/-- All set in `â„¬` are open in the Cantor-space topology. -/
theorem â„¬.IsOpen_of_mem (h : b âˆˆ â„¬) : IsOpen[â„¬.cantorSpace] b := by
  induction h with
  | base s s_mem => exact s_mem
  | empty => simp
  | compl y hy ih => simp_all
  | union _ _ _ _ ihâ‚ ihâ‚‚ =>
    exact @IsOpen.union _ _ _ â„¬.cantorSpace ihâ‚ ihâ‚‚

/-- The family of Borel sets `â„¬` is the smallest Ïƒ-algebra containing the Cantor-open sets. -/
theorem â„¬_is_borel : S âˆˆ â„¬ â†” MeasurableSet[â„¬.borel] S := by
  constructor
  Â· intro h
    induction h with
    | base s s_mem => exact MeasurableSpace.measurableSet_generateFrom s_mem
    | empty => simp
    | compl _ _ ih => exact MeasurableSet.compl_iff.mpr ih
    | union => exact MeasurableSet.union (by assumption) (by assumption)
  Â· intro h
    induction h with
    | basic s s_mem => exact generateSetAlgebra.base s s_mem
    | empty => simp
    | compl _ _ ih => exact IsSetAlgebra.compl_mem â„¬_IsSetAlgebra ih
    | iUnion f hâ‚ hâ‚‚ =>
      apply MeasureTheory.self_subset_generateSetAlgebra (@isOpen_iUnion _ _ â„¬.cantorSpace _ _)
      exact fun i â†¦ â„¬.IsOpen_of_mem (hâ‚‚ i)

/-! ## The Set Algebra `â„¬{b}` -/

/-- Let `â„¬{b}` be the Boolean subalgebra of `â„¬` generated by `{B[h] | h âˆˆ b}`. -/
def â„¬_b (b : Set H) := generateSetAlgebra {B[h] | h âˆˆ b}
@[inherit_doc] notation "â„¬{" b "}" => â„¬_b b

theorem â„¬_b_mono {a b : Set H} (h : a âŠ† b) : â„¬{a} âŠ† â„¬{b} := by
  apply generateSetAlgebra_mono
  simp only [Set.setOf_subset_setOf, forall_exists_index, and_imp, forall_apply_eq_imp_iffâ‚‚]
  exact fun x hx â†¦ âŸ¨x, h hx, rflâŸ©

@[simp] theorem â„¬_b_IsSetAlgebra : IsSetAlgebra (â„¬{b}) := isSetAlgebra_generateSetAlgebra
@[simp] theorem â„¬_b_IsSetRing : IsSetRing (â„¬{b}) := â„¬_b_IsSetAlgebra.isSetRing
@[simp] theorem â„¬_b_IsSetSemiring : IsSetSemiring (â„¬{b}) := â„¬_b_IsSetRing.isSetSemiring
@[simp] theorem â„¬_b_mem_empty {b : Set H} : âˆ… âˆˆ â„¬{b} := generateSetAlgebra.empty
@[simp] theorem â„¬_b_mem_univ {b : Set H} : Set.univ âˆˆ â„¬{b} := IsSetAlgebra.univ_mem â„¬_b_IsSetAlgebra
@[simp] theorem â„¬_b_mem_compl {b : Set H} : sá¶œ âˆˆ â„¬{b} â†” s âˆˆ â„¬{b} := by
  constructor
  Â· intro h
    rw [â† compl_compl (x:=s)]
    exact IsSetAlgebra.compl_mem (by simp) h
  Â· intro h; apply generateSetAlgebra.compl _ h
@[simp] theorem â„¬_b_mem_union {b : Set H} : s âˆˆ â„¬{b} âˆ§ t âˆˆ â„¬{b} â†’ s âˆª t âˆˆ â„¬{b} :=
  fun h â†¦ generateSetAlgebra.union _ _ h.left h.right
@[simp] theorem â„¬_b_mem_inter {b : Set H} : s âˆˆ â„¬{b} âˆ§ t âˆˆ â„¬{b} â†’ s âˆ© t âˆˆ â„¬{b} :=
  fun h â†¦ IsSetAlgebra.inter_mem â„¬_b_IsSetAlgebra h.left h.right

@[simp] theorem B_h_mem_â„¬_b_univ : B[i] âˆˆ â„¬{Set.univ} := by
  apply generateSetAlgebra.base; use i; simp
@[simp] theorem B_h_mem_â„¬_b (hi : i âˆˆ b) : B[i] âˆˆ â„¬{b} := by apply generateSetAlgebra.base; use i
@[simp] theorem B_h_mem_â„¬ : B[i] âˆˆ â„¬ := generateSetAlgebra.base _ B_b_IsOpen_of_mem

/-- If `b` is finite, so is `â„¬{b}`. -/
theorem â„¬_b_finite_of_finite (h : b.Finite) : â„¬{b}.Finite := sorry

/-- For a set `X`, we let `â„˜Ï‰(X)` denote the finite subsets of `X`. -/
def â„˜Ï‰ (X : Set Î±) := {Y âŠ† X | Y.Finite}

/-- **Lemma 1.** (iv) -/
theorem â„¬_b_eq_iUnion : â„¬{(Set.univ : Set H)} = â‹ƒ b âˆˆ â„˜Ï‰ Set.univ, â„¬{b} := by
  ext A
  simp only [â„˜Ï‰, Set.subset_univ, true_and, Set.mem_setOf_eq, Set.mem_iUnion, exists_prop]
  constructor
  Â· intro h
    induction h with
    | base B hB =>
      obtain âŸ¨h, hhâŸ© := hB
      use {h}, Set.finite_singleton h
      exact generateSetAlgebra.base _ (by simp_all)
    | empty => use {}; simp
    | compl B hB ih =>
      obtain âŸ¨C, hC, hC'âŸ© := ih
      use C, hC
      exact generateSetAlgebra.compl _ hC'
    | union B C hB hC ihB ihC =>
      replace hB : B âˆˆ â„¬{Set.univ} := hB
      replace hC : C âˆˆ â„¬{Set.univ} := hC
      obtain âŸ¨X, hXâ‚, hXâ‚‚âŸ© := ihB
      obtain âŸ¨Y, hYâ‚, hYâ‚‚âŸ© := ihC
      use X âˆª Y
      constructor
      Â· exact Set.Finite.union hXâ‚ hYâ‚
      Â· apply generateSetAlgebra.union _ _ <;> show _ âˆˆ â„¬{X âˆª Y}
        Â· apply generateSetAlgebra_mono _ hXâ‚‚
          simp_all only [Set.mem_union, Set.setOf_subset_setOf, forall_exists_index, and_imp,
            forall_apply_eq_imp_iffâ‚‚]
          intro h hh; use h
          simp_all only [true_or, and_self]
        Â· apply generateSetAlgebra_mono _ hYâ‚‚
          simp_all only [Set.mem_union, Set.setOf_subset_setOf, forall_exists_index, and_imp,
            forall_apply_eq_imp_iffâ‚‚]
          intro h hh; use h
          simp_all only [or_true, and_self]
  Â· rintro âŸ¨B, hB, hB'âŸ©; apply MeasureTheory.generateSetAlgebra_mono (by simp) hB'

theorem â„¬_b_mem_iff_exists : B âˆˆ â„¬{(Set.univ : Set H)} â†” âˆƒ i, i.Finite âˆ§ B âˆˆ â„¬{i} := by
  simp [â„¬_b_eq_iUnion, â„˜Ï‰]

@[simp]
theorem â„¬_borel_le_generateFrom : â„¬.borel (H:=H) â‰¤ MeasurableSpace.generateFrom â„¬{Set.univ} := by
  simp [â„¬.borel]
  rw [@borel_eq_generateFrom_of_subbasis _ _ â„¬.cantorSpace â„¬.secondCountable rfl]
  refine MeasurableSpace.generateFrom_mono ?_
  simp_all
  constructor
  all_goals intro a; simp_all; rintro _ âŸ¨_âŸ©; simp

/-! ## The atoms `A{a,b}` -/

/-- The atoms of `â„¬{b}` are in one-to-one correspondence with the subsets `a âŠ† b`, the subset `a`
    determining which `B[h]` occur positively in the construction of the atom:

```
A{a,b} = â‹‚ h âˆˆ a, B[h] âˆ© â‹‚ h âˆˆ b \ a, B[h]á¶œ = B{a} \ â‹ƒ a âŠ‚ c âˆ§ c âŠ† b, B{c} = {c | a = c âˆ© b}
```

Formulated in in `A_ab_eqâ‚`, `A_ab_eqâ‚‚`, and, `A_ab_eqâ‚ƒ`.
-/
def A_ab (a b : Set H) := {c | a = c âˆ© b}
@[inherit_doc] notation "A{" a "," b "}" => A_ab a b

/-- **Definition (i)** of `A{a,b}`. -/
def A_ab_eqâ‚ (hab : a âŠ† b) : A{a,b} = (â‹‚ h âˆˆ a, B[h]) âˆ© (â‹‚ h âˆˆ (b \ a), B[h]á¶œ) := by
  ext c
  simp only [A_ab, Set.mem_setOf_eq, B_h, Set.mem_diff, Set.mem_inter_iff, Set.mem_iInter,
    Set.mem_compl_iff, and_imp]
  constructor
  Â· rintro âŸ¨_âŸ©
    simp_all only [Set.mem_inter_iff, implies_true, and_true, not_false_eq_true, and_self]
  Â· simp_all only [and_imp]
    intro h h'
    simp [not_imp_not] at h'
    replace h' : âˆ€ i, i âˆˆ b â†’ i âˆˆ c â†’ i âˆˆ a := h'
    replace h' : âˆ€ i, i âˆˆ c â†’ i âˆˆ b â†’ i âˆˆ a := by exact fun i hâ‚ hâ‚‚ => h' i hâ‚‚ hâ‚
    ext v
    simp_all
    constructor
    Â· intro hâ‚
      exact âŸ¨h v hâ‚, hab hâ‚âŸ©
    Â· intro âŸ¨hâ‚, hâ‚‚âŸ©
      exact h' v hâ‚ hâ‚‚

/-- **Definition (ii)** of `A{a,b}`. -/
theorem A_ab_eqâ‚‚ (hab : a âŠ† b) : A{a,b} = B{a} \ â‹ƒ (c : {c | a âŠ‚ c âˆ§ c âŠ† b}), B{c} := by
  ext c
  constructor
  Â· rintro âŸ¨_âŸ©
    simp [A_ab, B_b]
    intro c hcbc hcb
    contrapose! hcbc
    simp_all [not_ssubset_of_subset]
  Â· simp_all [A_ab_eqâ‚ hab, B_h, B_b]
    intro h h'
    contrapose h'
    simp_all
    replace h' := h' h
    obtain âŸ¨w, hwb, hwa, hwcâŸ© := h'
    use (b âˆ© c) âˆª {w}
    constructor
    Â· simp
      refine (Set.ssubset_iff_of_subset ?_).mpr ?_
      Â· simp_all
      Â· use w; simp_all
    Â· simp_all

/-- **Definition (iii)** of `A{a,b}`. -/
theorem A_ab_eqâ‚ƒ (_hab : a âŠ† b) : A{a,b} = {c | a = c âˆ© b} := rfl

@[simp] theorem A_ab_a_mem (hab : a âŠ† b) : a âˆˆ A{a,b} := by simp [hab, A_ab]

@[simp] theorem A_ab_same_eq_B_b : A{b,b} = B{b} := by ext; simp [A_ab_eqâ‚ƒ, B_b]

theorem A_ab_mem_â„¬_b {a b : Set H} (hb : b.Finite) (hab : a âŠ† b) : A{a,b} âˆˆ â„¬{b} := by
  rw [A_ab_eqâ‚ hab]
  refine â„¬_b_mem_inter ?_
  constructor
  Â· have : a.Finite := Set.Finite.subset hb hab
    have := IsSetAlgebra.biInter_mem (ğ’œ:=â„¬{b}) (S:=this.toFinset) (s:=B_h)
    simp_all
    apply this
    intro i hi
    exact B_h_mem_â„¬_b (hab hi)
  Â· have : (b \ a).Finite := Set.Finite.diff hb
    have := IsSetAlgebra.biInter_mem (ğ’œ:=â„¬{b}) (S:=this.toFinset) (s:=(B[Â·]á¶œ))
    simp_all

theorem A_ab_mem_â„¬ {a b : Set H} (hb : b.Finite) (hab : a âŠ† b) : A{a,b} âˆˆ â„¬ := by
  rw [A_ab_eqâ‚ hab]
  apply IsSetAlgebra.inter_mem (by simp)
  Â· have : a.Finite := Set.Finite.subset hb hab
    have := IsSetAlgebra.biInter_mem (ğ’œ:=â„¬) (S:=this.toFinset) (s:=B_h) (by simp)
    simp_all
  Â· have : (b \ a).Finite := Set.Finite.diff hb
    have := IsSetAlgebra.biInter_mem (ğ’œ:=â„¬) (S:=this.toFinset) (s:=(B[Â·]á¶œ))
    simp_all

/-- **Lemma 2.** -/
theorem B_b_eq_iUnion_A_ab (hab : a âŠ† b) : B{a} = â‹ƒ c âˆˆ {c | a âŠ† c âˆ§ c âŠ† b}, A{c,b} := by
  symm
  calc
    â‹ƒ c âˆˆ {c | a âŠ† c âˆ§ c âŠ† b}, A{c,b} = â‹ƒ c âˆˆ {c | a âŠ† c âˆ§ c âŠ† b}, {d | c = d âˆ© b} := by simp [A_ab]
    _ = {d | a âŠ† d} := by ext; simp_all

/-- **Lemma 2.** rephrased for `B[h]` -/
theorem B_h_eq_iUnion_A_ab (hab : a âˆˆ b) : B[a] = â‹ƒ c âˆˆ {c | a âˆˆ c âˆ§ c âŠ† b}, A{c,b} := by
  have := B_b_eq_iUnion_A_ab (by simp [hab] : {a} âŠ† b)
  simp_all

/--
For any `B âˆˆ â„¬{b}` there exists **finite** set of **subsets of `b`**, call it `q`, who's **disjoint
union** satisfies `B = â‹ƒ a âˆˆ q, A{a,b}`.
-/
def â„¬_b_exists_cover (hsb : B âˆˆ â„¬{b}) (hb : b.Finite) :
    âˆƒ q : Set (Set H),
      B = â‹ƒ a âˆˆ q, A{a,b}
      âˆ§ Set.PairwiseDisjoint q (A{Â·,b})
      âˆ§ q.Finite
      âˆ§ (B.Nonempty â†” q.Nonempty)
      âˆ§ âˆ€ a âˆˆ q, a âŠ† b := by
  induction hsb with clear B
  | base s hs =>
    simp only [Set.mem_setOf_eq] at hs
    obtain âŸ¨w, hw, _, _âŸ© := hs
    nth_rw 1 [B_h_eq_iUnion_A_ab hw]
    simp
    apply Exists.intro
    Â· split_ands
      Â· rfl
      Â· intro x hx y hy hxy a hax hay q hq
        simp_all
        replace hax := hax hq
        replace hqy := hay hq
        simp_all [A_ab]
      Â· show {a | w âˆˆ a âˆ§ a âŠ† b}.Finite
        suffices {a | a âŠ† b}.Finite by exact Set.Finite.subset this (by simp)
        exact Set.Finite.finite_subsets hb
      Â· constructor
        Â· intro _
          use {w}
          show w âˆˆ ({w} : Set H) âˆ§ {w} âŠ† b
          simp [hw]
        Â· intro h
          replace h : {c | w âˆˆ c âˆ§ c âŠ† b}.Nonempty := h
          obtain âŸ¨c, hâ‚, hâ‚‚âŸ© := h
          use {w}
          simp [B_h]
      Â· show âˆ€ a âˆˆ {c | w âˆˆ c âˆ§ c âŠ† b}, a âŠ† b
        simp
  | empty => use {}; simp
  | compl s hs ih =>
    replace hs : s âˆˆ â„¬{b} := hs
    obtain âŸ¨w, âŸ¨_, _, _âŸ©, hwâŸ© := ih
    simp_all
    clear hs
    use {a âˆˆ wá¶œ | a âŠ† b}
    split_ands
    Â· ext a
      simp_all [A_ab]
      constructor
      Â· intro h
        exact fun a_1 â†¦ h (a âˆ© b) a_1 rfl
      Â· intro h i hi q
        subst_eqs
        contradiction
    Â· intro x hx y hy hxy a hax hay q hq
      simp_all
      replace hax := hax hq
      replace hqy := hay hq
      simp_all [A_ab]
    Â· suffices {a | a âŠ† b}.Finite by exact Set.Finite.subset this (by simp)
      exact Set.Finite.finite_subsets hb
    Â· simp
      constructor
      Â· simp
        intro x hx
        if hw : w.Nonempty then
          simp_all
          obtain âŸ¨c, hcâŸ© := hw
          have : âˆ€ i, x âˆˆ A{i,b} â†’ i âˆ‰ w := fun i a a_1 â†¦ hx i a_1 a
          simp [A_ab] at this
          use x âˆ© b
          simp_all
        else
          simp_all
          have : w = âˆ… := by exact Set.not_nonempty_iff_eq_empty.mp hw
          subst_eqs
          simp_all
          use b
          simp
      Â· rintro âŸ¨x, hxâ‚, hxâ‚‚âŸ©
        simp [A_ab]
        if hwN : w.Nonempty then
          simp_all
          have âŸ¨q, hqâ‚, hqâ‚‚âŸ© := hw.right.right.left
          contrapose! hxâ‚
          obtain âŸ¨y, hyâŸ© := hqâ‚‚
          simp [A_ab] at hy
          subst_eqs
          simp_all
          have := hxâ‚ x
          have : x âˆ© b = x := by simp_all
          simp_all
        else
          have : w = âˆ… := Set.not_nonempty_iff_eq_empty.mp hwN
          subst_eqs
          simp_all
    Â· simp
  | union s t hs ht ihs iht =>
    replace hs : s âˆˆ â„¬{b} := hs
    replace ht : t âˆˆ â„¬{b} := ht
    obtain âŸ¨s, âŸ¨_, _, _âŸ©, ihsâŸ© := ihs
    obtain âŸ¨t, âŸ¨_, _, _âŸ©, ihtâŸ© := iht
    use s âˆª t
    split_ands
    Â· ext x
      simp_all
      constructor
      Â· rintro (âŸ¨i, his, hxiâŸ© | âŸ¨i, hit, hxiâŸ©)
        all_goals (use i; simp_all)
      Â· rintro âŸ¨i, (hsi | hti), hiâŸ©
        Â· left; use i
        Â· right; use i
    Â· intro x hx y hy hxy a hax hay q hq
      simp_all only [Set.nonempty_iUnion, exists_prop, Set.mem_union, ne_eq, Set.le_eq_subset,
        Set.bot_eq_empty, Set.mem_empty_iff_false]
      replace hax := hax hq
      replace hqy := hay hq
      simp_all [A_ab]
    Â· refine Set.Finite.union ihs.right.left iht.right.left
    Â· simp_all only [Set.nonempty_iUnion, exists_prop, Set.union_nonempty]
    Â· simp_all
      rintro a (ha | ha)
      Â· exact ihs.right.right.right _ ha
      Â· exact iht.right.right.right _ ha


theorem â„¬_b_unique_exists_cover.base (hb : b.Finite) (hs : s âˆˆ {x | âˆƒ h âˆˆ b, B[h] = x}) :
    âˆƒ! q : Set (Set H),
        s = â‹ƒ a âˆˆ q, A{a,b}
      âˆ§ (q.PairwiseDisjoint fun x â†¦ A{x,b})
      âˆ§ q.Finite
      âˆ§ (s.Nonempty â†” q.Nonempty)
      âˆ§ âˆ€ a âˆˆ q, a âŠ† b := by
  simp only [Set.mem_setOf_eq] at hs
  obtain âŸ¨w, hw, _, _âŸ© := hs
  nth_rw 1 [B_h_eq_iUnion_A_ab hw]
  simp
  apply Exists.intro
  Â· split_ands
    Â· rfl
    Â· intro x hx y hy hxy a hax hay q hq
      simp_all
      replace hax := hax hq
      replace hqy := hay hq
      simp_all [A_ab]
    Â· show {a | w âˆˆ a âˆ§ a âŠ† b}.Finite
      suffices {a | a âŠ† b}.Finite by exact Set.Finite.subset this (by simp)
      exact Set.Finite.finite_subsets hb
    Â· constructor
      Â· intro _
        use {w}
        show w âˆˆ ({w} : Set H) âˆ§ {w} âŠ† b
        simp [hw]
      Â· intro h
        replace h : {c | w âˆˆ c âˆ§ c âŠ† b}.Nonempty := h
        obtain âŸ¨c, hâ‚, hâ‚‚âŸ© := h
        use {w}
        simp [B_h]
    Â· show âˆ€ a âˆˆ {c | w âˆˆ c âˆ§ c âŠ† b}, a âŠ† b
      simp
    Â· simp_all only [and_imp]
      intro y hy h_disjoint h_fin h_nonempty h
      show y = {c | w âˆˆ c âˆ§ c âŠ† b}
      simp [Set.ext_iff] at hy
      ext x
      simp_all only [Set.mem_setOf_eq]
      constructor
      Â· intro hxy
        replace hy := hy x |>.mpr
        simp_all only [forall_exists_index, and_imp, and_true]
        have âŸ¨i, âŸ¨hâ‚, hâ‚‚âŸ©, hâ‚ƒâŸ© := hy x hxy (A_ab_a_mem (h x hxy)); clear hy
        simp only [A_ab, Set.mem_setOf_eq] at hâ‚ƒ
        subst_eqs
        simp_all only [Set.mem_inter_iff, and_true, Set.inter_subset_right]
      Â· intro âŸ¨hâ‚, hâ‚‚âŸ©
        replace hy := hy x |>.mp
        simp_all only [A_ab, Set.mem_setOf_eq, exists_eq_right, Set.mem_inter_iff, and_self,
          Set.inter_subset_right, forall_const]
        induction y, h_fin using Set.Finite.induction_on with
        | empty => simp_all only [Set.pairwiseDisjoint_empty, Set.not_nonempty_empty, iff_false,
          Set.mem_empty_iff_false, IsEmpty.forall_iff, implies_true]
        | insert hsy ih hâ‚ƒ =>
          rename_i s y
          simp_all only [Set.insert_nonempty, true_iff, Set.mem_insert_iff, or_true, implies_true,
            forall_const, iff_true, forall_eq_or_imp]
          rcases hy with hy | hy
          Â· subst_eqs
            simp_all only [IsEmpty.forall_iff, implies_true, Set.inter_subset_right, true_and,
              Set.left_eq_inter, true_or]
          Â· simp_all only [forall_const]
            right
            apply hâ‚ƒ _ (Set.nonempty_of_mem hy)
            intro u huy v hvy huv
            exact h_disjoint (Set.mem_insert_of_mem s huy) (Set.mem_insert_of_mem s hvy) huv

theorem â„¬_b_unique_exists_cover.empty (hb : b.Finite) :
    âˆƒ! q : Set (Set H), âˆ… = â‹ƒ a âˆˆ q, A{a,b}
      âˆ§ (q.PairwiseDisjoint fun x â†¦ A{x,b})
      âˆ§ q.Finite
      âˆ§ ((âˆ… : Set (Set H)).Nonempty â†” q.Nonempty)
      âˆ§ âˆ€ a âˆˆ q, a âŠ† b := by
  use {}
  simp
  intro y h_empty h_disjoint h_fin h_nonempty h
  exact Set.not_nonempty_iff_eq_empty.mp h_nonempty

theorem A_ab_inj {b : Set H} : Function.Injective (fun (a : {a | a âŠ† b}) â†¦ A{a,b}) := by
  intro âŸ¨aâ‚, habâ‚âŸ© âŸ¨aâ‚‚, habâ‚‚âŸ© h
  simp_all [A_ab, Set.ext_iff]
  simp_all [A_ab, Set.ext_iff]
  intro x
  constructor
  Â· intro h'
    have hâ‚ := h aâ‚
    have hâ‚‚ := h aâ‚‚
    clear h
    simp_all [habâ‚]
    replace hâ‚ := hâ‚.mp (fun x a â†¦ habâ‚ a)
    simp_all
  Â· intro h'
    have hâ‚ := h aâ‚
    clear h
    simp_all
    replace hâ‚ := hâ‚.mp (fun x a â†¦ habâ‚ a)
    simp_all

@[simp] theorem A_ab_mem_iff : x âˆˆ A{a,b} â†” a = x âˆ© b := by simp [A_ab]

set_option maxHeartbeats 5000000 in
/--
For any `B âˆˆ â„¬{b}` there exists **finite** set of **subsets of `b`**, call it `q`, who's **disjoint
union** satisfies `B = â‹ƒ a âˆˆ q, A{a,b}`.
-/
def â„¬_b_unique_exists_cover (hsb : B âˆˆ â„¬{b}) (hb : b.Finite) :
    âˆƒ! q : Set (Set H),
      B = â‹ƒ a âˆˆ q, A{a,b}
      âˆ§ Set.PairwiseDisjoint q (A{Â·,b})
      âˆ§ q.Finite
      âˆ§ (B.Nonempty â†” q.Nonempty)
      âˆ§ âˆ€ a âˆˆ q, a âŠ† b := by
  induction hsb with clear B
  | base s hs => exact â„¬_b_unique_exists_cover.base hb hs
  | empty => exact â„¬_b_unique_exists_cover.empty hb
  | compl s hs ih =>
    sorry
    -- replace hs : s âˆˆ â„¬{b} := hs
    -- obtain âŸ¨w, âŸ¨_, _, _âŸ©, hwâŸ© := ih
    -- simp_all
    -- clear hs
    -- use {a âˆˆ wá¶œ | a âŠ† b}
    -- split_ands
    -- Â· ext a
    --   simp_all [A_ab]
    --   constructor
    --   Â· intro h
    --     exact fun a_1 â†¦ h (a âˆ© b) a_1 rfl
    --   Â· intro h i hi q
    --     subst_eqs
    --     contradiction
    -- Â· intro x hx y hy hxy a hax hay q hq
    --   simp_all
    --   replace hax := hax hq
    --   replace hqy := hay hq
    --   simp_all [A_ab]
    -- Â· suffices {a | a âŠ† b}.Finite by exact Set.Finite.subset this (by simp)
    --   exact Set.Finite.finite_subsets hb
    -- Â· simp
    --   constructor
    --   Â· simp
    --     intro x hx
    --     if hw : w.Nonempty then
    --       simp_all
    --       obtain âŸ¨c, hcâŸ© := hw
    --       have : âˆ€ i, x âˆˆ A{i,b} â†’ i âˆ‰ w := fun i a a_1 â†¦ hx i a_1 a
    --       simp [A_ab] at this
    --       use x âˆ© b
    --       simp_all
    --     else
    --       simp_all
    --       have : w = âˆ… := by exact Set.not_nonempty_iff_eq_empty.mp hw
    --       subst_eqs
    --       simp_all
    --       use b
    --       simp
    --   Â· rintro âŸ¨x, hxâ‚, hxâ‚‚âŸ©
    --     simp [A_ab]
    --     if hwN : w.Nonempty then
    --       simp_all
    --       have âŸ¨q, hqâ‚, hqâ‚‚âŸ© := hw.right.right.left
    --       contrapose! hxâ‚
    --       obtain âŸ¨y, hyâŸ© := hqâ‚‚
    --       simp [A_ab] at hy
    --       subst_eqs
    --       simp_all
    --       have := hxâ‚ x
    --       have : x âˆ© b = x := by simp_all
    --       simp_all
    --     else
    --       have : w = âˆ… := Set.not_nonempty_iff_eq_empty.mp hwN
    --       subst_eqs
    --       simp_all
    -- Â· simp
  | union s t hs ht ihs iht =>
    replace hs : s âˆˆ â„¬{b} := hs
    replace ht : t âˆˆ â„¬{b} := ht
    obtain âŸ¨s, âŸ¨âŸ¨_âŸ©, _, s_finite, s_nonempty, hsabâŸ©, ihsâŸ© := ihs
    obtain âŸ¨t, âŸ¨âŸ¨_âŸ©, _, t_finite, t_nonempty, htabâŸ©, ihtâŸ© := iht
    use s âˆª t
    simp only [Set.nonempty_iUnion, exists_prop, and_imp, Set.mem_union, Set.finite_union,
      Set.union_nonempty] at *
    split_ands
    Â· ext x
      sorry
      -- constructor
      -- Â· rintro (âŸ¨i, his, hxiâŸ© | âŸ¨i, hit, hxiâŸ©)
      --   all_goals (use i; simp_all)
      -- Â· rintro âŸ¨i, (hsi | hti), hiâŸ©
      --   Â· left; use i
      --   Â· right; use i
    Â· intro x hx y hy hxy a hax hay q hq
      simp only [Set.nonempty_iUnion, exists_prop, and_imp, Set.mem_union, ne_eq, Set.le_eq_subset,
        Set.bot_eq_empty, Set.mem_empty_iff_false] at *
      replace hax := hax hq
      replace hay := hay hq
      simp [A_ab] at *
      subst_eqs
      contradiction
    Â· exact s_finite
    Â· clear ihs iht
      simp_all only [Set.nonempty_iUnion, exists_prop, Set.union_nonempty]
    Â· exact or_congr s_nonempty t_nonempty
    Â· intro y hy
      rcases hy with hy | hy
      Â· simp [*]
      Â· simp [*]
    Â· intro y hy hy_disjoint hy_finite h_nonemp h
      simp only [Set.ext_iff, Set.mem_union, Set.mem_iUnion, exists_prop] at hy âŠ¢
      intro x
      clear ihs iht
      replace hy := hy x
      constructor
      Â· intro h'
        sorry
      Â· intro h'

        sorry

def â„¬_b_cover {b : Set H} (hsb : B âˆˆ â„¬{b}) (hb : b.Finite) : Set (Set H) :=
  (â„¬_b_exists_cover hsb hb).choose
def â„¬_b_cover_spec {b : Set H} (hsb : B âˆˆ â„¬{b}) (hb : b.Finite) :
      B = â‹ƒ a âˆˆ (â„¬_b_cover hsb hb), A{a,b}
    âˆ§ Set.PairwiseDisjoint (â„¬_b_cover hsb hb) (A{Â·,b})
    âˆ§ (â„¬_b_cover hsb hb).Finite
    âˆ§ (B.Nonempty â†” (â„¬_b_cover hsb hb).Nonempty)
    âˆ§ âˆ€ a âˆˆ (â„¬_b_cover hsb hb), a âŠ† b :=
  (â„¬_b_exists_cover hsb hb).choose_spec

theorem â„¬_cover_eq {b : Set H} (hsb : B âˆˆ â„¬{b}) (hb : b.Finite) :
    B = â‹ƒ a âˆˆ â„¬_b_cover hsb hb, A{a,b} := by
  have := â„¬_b_cover_spec hsb hb
  simp_all

/-- **Lemma 3.** (i) -/
theorem A_ab_subset_iff (hab : a âŠ† b) (hab' : a' âŠ† b') :
    A{a,b} âŠ† A{a',b'} â†” a' âŠ† a âˆ§ b' \ a' âŠ† b \ a := by
  sorry

/-- **Lemma 3.** (ii) -/
theorem A_ab_rel (hab : a âŠ† b) (hab' : a' âŠ† b') :
    A{a,b} âŠ† A{a',b'} âˆ¨ A{a',b'} âŠ† A{a,b} âˆ¨ A{a,b} âˆ© A{a',b'} = âˆ… := by
  by_contra q
  simp at q
  obtain âŸ¨qâ‚, qâ‚‚, qâ‚ƒâŸ© := q
  sorry

end ProbNetKAT
