import Mathlib.MeasureTheory.Constructions.BorelSpace.Basic
import Mathlib.MeasureTheory.SetAlgebra
import Mathlib.Order.CompletePartialOrder
import Mathlib.Topology.MetricSpace.Polish
import Mathlib.Topology.Instances.CantorSet

/-!

# Cantor

This file defines the Cantor-space and its components.

## Main definitions

- [`B[h]`](find/?pattern=ProbNetKAT.B_h#doc): The subbasic sets of the Cantor space topology
  (denoted $B_h$ in the paper).
- [`B{b}`](find/?pattern=ProbNetKAT.B_b#doc): The subbasic sets extended to sets of the Cantor space
  topology (denoted $B_b$ in the paper).
- `â„¬`: The smallest Ïƒ-algebra generated by the Cantor-open sets.
- `â„¬.cantorSpace`: The Cantor space topology.
- `â„¬.borel`: The Borel measurable space generated from the Cantor space topology.
- [`â„¬{b}`](find/?pattern=ProbNetKAT.â„¬_b#doc): The smallest Set Algebra generated by `{B[h] | h âˆˆ b}`
  (denoted $â„¬_b$ in the paper).
- [`A{a,b}`](find/?pattern=ProbNetKAT.A_ab#doc): The atoms of `â„¬{b}`.

-/

set_option grind.warning false

namespace ProbNetKAT

open Topology MeasureTheory

variable {P : Type} [Countable P]

abbrev H P := List P

notation "H[" P "]" => H P

/-! ## The subbasic sets `B[h]` and `B{b}` -/

/-- **Equation (1.1)**

$$B[h] = \{ c âˆ£ h âˆˆ c \}$$
-/
def B_h (h : H P) := {c : Set H[P] | h âˆˆ c}
/-- **Equation (1.1)**

$$B\{b\} = \{ c âˆ£ b âŠ† c \}$$
-/
def B_b (b : Set H[P]) := {c : Set H[P] | b âŠ† c}

@[inherit_doc] notation "B[" h "]" => B_h h
@[inherit_doc] notation "B{" b "}" => B_b b

@[simp] theorem B_b_h_eq_B_h : B{{h}} = B[h] := by simp [B_h, B_b]
/-- **Lemma 1.** (i) -/
@[simp] theorem B_b_subset_iff : B{c} âŠ† B{b} â†” b âŠ† c := by
  simp [B_b]; exact âŸ¨(Â· c (by rfl)), fun h _ h' â†¦ subset_trans h h'âŸ©
/-- **Lemma 1.** (ii) -/
@[simp] theorem B_b_union_eq_inter : B{b âˆª c} = B{b} âˆ© B{c} := by ext a; simp [B_b]
/-- **Lemma 1.** (iii) -/
@[simp] theorem B_b_empty : B{(âˆ… : Set H[P])} = Set.univ := by ext a; simp [B_b]

@[simp]
def â„¬.generatingSet : Set (Set (Set H[P])) := ({B[h] | h} âˆª {B[h]á¶œ | h})

/-- The sets `B[h]` and `B[h]á¶œ` are the subbasic open sets of the Cantor space topology on 2H. -/
def â„¬.cantorSpace : TopologicalSpace (Set H[P]) :=
  TopologicalSpace.generateFrom generatingSet
/-- The Borel measurable space generated by the Cantor-topology. -/
def â„¬.borel : MeasurableSpace (Set H[P]) := @_root_.borel _ â„¬.cantorSpace

theorem â„¬.generatingSet_countable : ({B[(h : H[P])] | h} âˆª {B[h]á¶œ | h}).Countable := by
  have : {B[(h : H[P])] | h} = ((B[Â·]) '' Set.univ) := by ext; simp
  have : {B[(h : H[P])]á¶œ | h} = ((B[Â·]á¶œ) '' Set.univ) := by ext; simp
  simp [Set.countable_range, *]

open scoped Classical in
noncomputable def â„¬.dist : Set H[P] â†’ Set H[P] â†’ â„ := fun a b â†¦
  if a = b then 0 else (1 : â„) / 2^(â¨… s âˆˆ symmDiff a b, s.length)

@[simp]
noncomputable instance â„¬.instDist : Dist (Set H[P]) := âŸ¨distâŸ©


/-- The Cantor space $2^H$ is second countable. -/
instance â„¬.secondCountable : @SecondCountableTopology (Set H[P]) â„¬.cantorSpace :=
  letI := (â„¬.cantorSpace (P:=P))
  âŸ¨Exists.intro _ âŸ¨â„¬.generatingSet_countable, rflâŸ©âŸ©

@[simp]
noncomputable instance â„¬.pseudoMetricSpace : PseudoMetricSpace (Set H[P]) where
  dist_self := by simp [dist]
  dist_comm x y := by simp [dist, symmDiff_comm]; split_ifs <;> simp_all
  dist_triangle x y z := by
    simp [dist]
    split_ifs <;> subst_eqs <;> try simp_all
    Â· apply Right.add_nonneg <;> simp
    Â· sorry
      -- generalize hâ‚ : dist (symmDiff x y) z = dâ‚
      -- generalize hâ‚‚ : dist x (symmDiff y z) = dâ‚‚
      -- simp_all [dist, symmDiff_assoc]

example : sInf (âˆ… : Set â„•) = 0 := by simp

noncomputable def â„¬.metricSpace : MetricSpace (Set H[P]) := by
  refine { toPseudoMetricSpace := pseudoMetricSpace, eq_of_dist_eq_zero := ?_ }
  intro x y
  simp [pseudoMetricSpace, dist]

noncomputable instance â„¬.uniformSpace : UniformSpace (Set H[P]) :=
  PseudoMetricSpace.toUniformSpace

instance â„¬.isCompletelyMetrizableSpace :
    @TopologicalSpace.IsCompletelyMetrizableSpace (Set H[P]) â„¬.cantorSpace := by
  letI := â„¬.cantorSpace (P:=P)
  -- letI : UniformSpace (Set H[P]) := â„¬.uniformSpace
  refine { complete := ?_ }
  use â„¬.metricSpace
  constructor
  Â· refine TopologicalSpace.ext ?_
    ext x
    constructor
    Â· intro h
      sorry
    Â· intro h
      sorry

  Â· refine completeSpace_iff_isComplete_univ.mpr ?_
    sorry

/-- The Cantor space $2^H$ is a Polish space. -/
instance â„¬.polishSpace : @PolishSpace (Set H[P]) â„¬.cantorSpace :=
  letI := â„¬.cantorSpace (P:=P)
  letI : SecondCountableTopology (Set H[P]) := â„¬.secondCountable
  instPolishSpaceOfSeparableSpaceOfIsCompletelyMetrizableSpace

/-! ## The Set Algebra `â„¬` -/

/-- The family of Borel sets `â„¬` is the smallest Ïƒ-algebra containing the Cantor-open sets.

The theorem `â„¬_is_borel` establishes this connection.
-/
def â„¬ : Set (Set (Set H[P])) := generateSetAlgebra â„¬.cantorSpace.IsOpen

omit [Countable P] in
section

@[simp] theorem â„¬_IsSetAlgebra : IsSetAlgebra (â„¬ (P:=P)) := isSetAlgebra_generateSetAlgebra
@[simp] theorem â„¬_IsSetRing : IsSetRing (â„¬ (P:=P)) := â„¬_IsSetAlgebra.isSetRing
@[simp] theorem â„¬_IsSetSemiring : IsSetSemiring (â„¬ (P:=P)) := â„¬_IsSetRing.isSetSemiring
@[simp] theorem â„¬_mem_empty : âˆ… âˆˆ (â„¬ (P:=P)) := generateSetAlgebra.empty
@[simp] theorem â„¬_mem_univ : Set.univ âˆˆ (â„¬ (P:=P)) := IsSetAlgebra.univ_mem â„¬_IsSetAlgebra
@[simp] theorem â„¬_mem_compl : sá¶œ âˆˆ (â„¬ (P:=P)) â†” s âˆˆ (â„¬ (P:=P)) := by
  constructor
  Â· intro h
    have := generateSetAlgebra.compl _ h
    simp_all
    exact this
  Â· intro h; apply generateSetAlgebra.compl _ h
@[simp] theorem â„¬_mem_union : s âˆˆ (â„¬ (P:=P)) âˆ§ t âˆˆ (â„¬ (P:=P)) â†’ s âˆª t âˆˆ (â„¬ (P:=P)) := by
  intro h; apply generateSetAlgebra.union _ _ h.left h.right
@[simp] theorem â„¬_mem_inter : s âˆˆ (â„¬ (P:=P)) âˆ§ t âˆˆ (â„¬ (P:=P)) â†’ s âˆ© t âˆˆ (â„¬ (P:=P)) := by
  intro h; apply IsSetAlgebra.inter_mem â„¬_IsSetAlgebra h.left h.right

/-- All set `B[b]` are open in the Cantor-space topology. -/
@[simp] theorem B_b_IsOpen_of_mem : IsOpen[â„¬.cantorSpace] B[b] := by
  refine TopologicalSpace.isOpen_generateFrom_of_mem ?_
  simp

/-- All set `B[b]` are closed in the Cantor-space topology. -/
@[simp] theorem B_b_IsClosed_of_mem : IsClosed[â„¬.cantorSpace] B[b] :=
  (@isOpen_compl_iff _ _ â„¬.cantorSpace).mp (TopologicalSpace.isOpen_generateFrom_of_mem (by simp))

@[simp] theorem â„¬.isClosed_of_isOpen (h : IsOpen[â„¬.cantorSpace] S) : IsClosed[â„¬.cantorSpace] S := by
  induction h with
  | basic s hs =>
    simp_all
    obtain (âŸ¨w, hwâŸ© | âŸ¨w, hwâŸ©) := hs
    all_goals (subst_eqs; simp_all)
  | univ => exact @isClosed_univ _ â„¬.cantorSpace
  | inter _ _ _ _ ihâ‚ ihâ‚‚ => exact @IsClosed.inter _ _ _ â„¬.cantorSpace ihâ‚ ihâ‚‚
  | sUnion S hsS ih =>
    sorry

/-- From [Wikipedia](https://en.wikipedia.org/wiki/Clopen_set#Properties):

> Using the union and intersection as operations, the clopen subsets of a given topological space X
> form a Boolean algebra. Every Boolean algebra can be obtained in this way from a suitable
> topological space: see Stone's representation theorem for Boolean algebras.
-/
@[simp] theorem â„¬.isClosed_iff_isOpen : IsClosed[â„¬.cantorSpace] S â†” IsOpen[â„¬.cantorSpace] S := by
  constructor
  Â· intro h
    apply (@isOpen_compl_iff _ _ â„¬.cantorSpace).mpr at h
    generalize h' : Sá¶œ = S'
    suffices IsOpen[â„¬.cantorSpace] S'á¶œ by subst_eqs; simp_all
    simp_all
  Â· simp_all

/-- All set in `â„¬` are open in the Cantor-space topology. -/
theorem â„¬.IsOpen_of_mem (h : b âˆˆ â„¬) : IsOpen[â„¬.cantorSpace] b := by
  induction h with
  | base s s_mem => exact s_mem
  | empty => simp
  | compl y hy ih => simp_all
  | union _ _ _ _ ihâ‚ ihâ‚‚ =>
    exact @IsOpen.union _ _ _ â„¬.cantorSpace ihâ‚ ihâ‚‚

/-- The family of Borel sets `â„¬` is the smallest Ïƒ-algebra containing the Cantor-open sets. -/
theorem â„¬_is_borel : S âˆˆ â„¬ â†” MeasurableSet[â„¬.borel] S := by
  constructor
  Â· intro h
    induction h with
    | base s s_mem => exact MeasurableSpace.measurableSet_generateFrom s_mem
    | empty => simp
    | compl _ _ ih => exact MeasurableSet.compl_iff.mpr ih
    | union => exact MeasurableSet.union (by assumption) (by assumption)
  Â· intro h
    induction h with
    | basic s s_mem => exact generateSetAlgebra.base s s_mem
    | empty => simp
    | compl _ _ ih => exact IsSetAlgebra.compl_mem â„¬_IsSetAlgebra ih
    | iUnion f hâ‚ hâ‚‚ =>
      apply MeasureTheory.self_subset_generateSetAlgebra (@isOpen_iUnion _ _ â„¬.cantorSpace _ _)
      exact fun i â†¦ â„¬.IsOpen_of_mem (hâ‚‚ i)

/-! ## The Set Algebra `â„¬{b}` -/

/-- Let `â„¬{b}` be the Boolean subalgebra of `â„¬` generated by `{B[h] | h âˆˆ b}`. -/
def â„¬_b (b : Set H[P]) := generateSetAlgebra {B[h] | h âˆˆ b}
@[inherit_doc] notation "â„¬{" b "}" => â„¬_b b

theorem â„¬_b_mono {a b : Set H[P]} (h : a âŠ† b) : â„¬{a} âŠ† â„¬{b} := by
  apply generateSetAlgebra_mono
  simp only [Set.setOf_subset_setOf, forall_exists_index, and_imp, forall_apply_eq_imp_iffâ‚‚]
  exact fun x hx â†¦ âŸ¨x, h hx, rflâŸ©

@[simp] theorem â„¬_b_IsSetAlgebra : IsSetAlgebra (â„¬{b}) := isSetAlgebra_generateSetAlgebra
@[simp] theorem â„¬_b_IsSetRing : IsSetRing (â„¬{b}) := â„¬_b_IsSetAlgebra.isSetRing
@[simp] theorem â„¬_b_IsSetSemiring : IsSetSemiring (â„¬{b}) := â„¬_b_IsSetRing.isSetSemiring
@[simp] theorem â„¬_b_mem_empty {b : Set H[P]} : âˆ… âˆˆ â„¬{b} := generateSetAlgebra.empty
@[simp] theorem â„¬_b_mem_univ {b : Set H[P]} : Set.univ âˆˆ â„¬{b} :=
  IsSetAlgebra.univ_mem â„¬_b_IsSetAlgebra
@[simp] theorem â„¬_b_mem_compl {b : Set H[P]} : sá¶œ âˆˆ â„¬{b} â†” s âˆˆ â„¬{b} := by
  constructor
  Â· intro h
    rw [â† compl_compl (x:=s)]
    exact IsSetAlgebra.compl_mem (by simp) h
  Â· intro h; apply generateSetAlgebra.compl _ h
@[simp] theorem â„¬_b_mem_union {b : Set H[P]} : s âˆˆ â„¬{b} âˆ§ t âˆˆ â„¬{b} â†’ s âˆª t âˆˆ â„¬{b} :=
  fun h â†¦ generateSetAlgebra.union _ _ h.left h.right
@[simp] theorem â„¬_b_mem_inter {b : Set H[P]} : s âˆˆ â„¬{b} âˆ§ t âˆˆ â„¬{b} â†’ s âˆ© t âˆˆ â„¬{b} :=
  fun h â†¦ IsSetAlgebra.inter_mem â„¬_b_IsSetAlgebra h.left h.right

@[simp] theorem B_h_mem_â„¬_b_univ : B[i] âˆˆ â„¬{Set.univ} := by
  apply generateSetAlgebra.base; use i; simp
@[simp] theorem B_h_mem_â„¬_b (hi : i âˆˆ b) : B[i] âˆˆ â„¬{b} := by apply generateSetAlgebra.base; use i
@[simp] theorem B_h_mem_â„¬ : B[i] âˆˆ â„¬ := generateSetAlgebra.base _ B_b_IsOpen_of_mem

/-- If `b` is finite, so is `â„¬{b}`. -/
theorem â„¬_b_finite_of_finite (h : b.Finite) : â„¬{b}.Finite := sorry

/-- For a set `X`, we let `â„˜Ï‰(X)` denote the finite subsets of `X`. -/
def â„˜Ï‰ (X : Set Î±) := {Y âŠ† X | Y.Finite}

/-- **Lemma 1.** (iv) -/
theorem â„¬_b_eq_iUnion : â„¬{(Set.univ : Set H[P])} = â‹ƒ b âˆˆ â„˜Ï‰ Set.univ, â„¬{b} := by
  ext A
  simp only [â„˜Ï‰, Set.subset_univ, true_and, Set.mem_setOf_eq, Set.mem_iUnion, exists_prop]
  constructor
  Â· intro h
    induction h with
    | base B hB =>
      obtain âŸ¨h, hhâŸ© := hB
      use {h}, Set.finite_singleton h
      exact generateSetAlgebra.base _ (by simp_all)
    | empty => use {}; simp
    | compl B hB ih =>
      obtain âŸ¨C, hC, hC'âŸ© := ih
      use C, hC
      exact generateSetAlgebra.compl _ hC'
    | union B C hB hC ihB ihC =>
      replace hB : B âˆˆ â„¬{Set.univ} := hB
      replace hC : C âˆˆ â„¬{Set.univ} := hC
      obtain âŸ¨X, hXâ‚, hXâ‚‚âŸ© := ihB
      obtain âŸ¨Y, hYâ‚, hYâ‚‚âŸ© := ihC
      use X âˆª Y
      constructor
      Â· exact Set.Finite.union hXâ‚ hYâ‚
      Â· apply generateSetAlgebra.union _ _ <;> show _ âˆˆ â„¬{X âˆª Y}
        Â· apply generateSetAlgebra_mono _ hXâ‚‚
          simp_all only [Set.mem_union, Set.setOf_subset_setOf, forall_exists_index, and_imp,
            forall_apply_eq_imp_iffâ‚‚]
          intro h hh; use h
          simp_all only [true_or, and_self]
        Â· apply generateSetAlgebra_mono _ hYâ‚‚
          simp_all only [Set.mem_union, Set.setOf_subset_setOf, forall_exists_index, and_imp,
            forall_apply_eq_imp_iffâ‚‚]
          intro h hh; use h
          simp_all only [or_true, and_self]
  Â· rintro âŸ¨B, hB, hB'âŸ©; apply MeasureTheory.generateSetAlgebra_mono (by simp) hB'

theorem â„¬_b_mem_iff_exists : B âˆˆ â„¬{(Set.univ : Set H[P])} â†” âˆƒ i, i.Finite âˆ§ B âˆˆ â„¬{i} := by
  simp [â„¬_b_eq_iUnion, â„˜Ï‰]

end

@[simp]
theorem â„¬_borel_le_generateFrom :
    â„¬.borel (P:=P) â‰¤ MeasurableSpace.generateFrom â„¬{Set.univ} := by
  simp [â„¬.borel]
  rw [@borel_eq_generateFrom_of_subbasis _ _ â„¬.cantorSpace â„¬.secondCountable rfl]
  refine MeasurableSpace.generateFrom_mono ?_
  simp_all
  constructor
  all_goals intro a; simp_all; rintro _ âŸ¨_âŸ©; simp

/-! ## The atoms `A{a,b}` -/

/-- The atoms of `â„¬{b}` are in one-to-one correspondence with the subsets `a âŠ† b`, the subset `a`
    determining which `B[h]` occur positively in the construction of the atom:

```
A{a,b} = â‹‚ h âˆˆ a, B[h] âˆ© â‹‚ h âˆˆ b \ a, B[h]á¶œ = B{a} \ â‹ƒ a âŠ‚ c âˆ§ c âŠ† b, B{c} = {c | a = c âˆ© b}
```

Formulated in in `A_ab_eqâ‚`, `A_ab_eqâ‚‚`, and, `A_ab_eqâ‚ƒ`.
-/
def A_ab (a b : Set H[P]) := {c | a = c âˆ© b}
@[inherit_doc] notation "A{" a "," b "}" => A_ab a b

/-- **Definition (i)** of `A{a,b}`. -/
def A_ab_eqâ‚ (hab : a âŠ† b) : A{a,b} = (â‹‚ h âˆˆ a, B[h]) âˆ© (â‹‚ h âˆˆ (b \ a), B[h]á¶œ) := by
  ext c
  simp only [A_ab, Set.mem_setOf_eq, B_h, Set.mem_diff, Set.mem_inter_iff, Set.mem_iInter,
    Set.mem_compl_iff, and_imp]
  constructor
  Â· rintro âŸ¨_âŸ©
    simp_all only [Set.mem_inter_iff, implies_true, and_true, not_false_eq_true, and_self]
  Â· simp_all only [and_imp]
    intro h h'
    simp [not_imp_not] at h'
    replace h' : âˆ€ i, i âˆˆ b â†’ i âˆˆ c â†’ i âˆˆ a := h'
    replace h' : âˆ€ i, i âˆˆ c â†’ i âˆˆ b â†’ i âˆˆ a := by exact fun i hâ‚ hâ‚‚ => h' i hâ‚‚ hâ‚
    ext v
    simp_all
    constructor
    Â· intro hâ‚
      exact âŸ¨h v hâ‚, hab hâ‚âŸ©
    Â· intro âŸ¨hâ‚, hâ‚‚âŸ©
      exact h' v hâ‚ hâ‚‚

/-- **Definition (ii)** of `A{a,b}`. -/
theorem A_ab_eqâ‚‚ (hab : a âŠ† b) : A{a,b} = B{a} \ â‹ƒ (c : {c | a âŠ‚ c âˆ§ c âŠ† b}), B{c} := by
  ext c
  constructor
  Â· rintro âŸ¨_âŸ©
    simp [A_ab, B_b]
    intro c hcbc hcb
    contrapose! hcbc
    simp_all [not_ssubset_of_subset]
  Â· simp_all [A_ab_eqâ‚ hab, B_h, B_b]
    intro h h'
    contrapose h'
    simp_all
    replace h' := h' h
    obtain âŸ¨w, hwb, hwa, hwcâŸ© := h'
    use (b âˆ© c) âˆª {w}
    constructor
    Â· simp
      refine (Set.ssubset_iff_of_subset ?_).mpr ?_
      Â· simp_all
      Â· use w; simp_all
    Â· simp_all

/-- **Definition (iii)** of `A{a,b}`. -/
theorem A_ab_eqâ‚ƒ (_hab : a âŠ† b) : A{a,b} = {c | a = c âˆ© b} := rfl

@[simp] theorem A_ab_a_mem (hab : a âŠ† b) : a âˆˆ A{a,b} := by simp [hab, A_ab]

@[simp] theorem A_ab_same_eq_B_b : A{b,b} = B{b} := by ext; simp [A_ab_eqâ‚ƒ, B_b]

omit [Countable P] in
theorem A_ab_mem_â„¬_b {a b : Set H[P]} (hb : b.Finite) (hab : a âŠ† b) : A{a,b} âˆˆ â„¬{b} := by
  rw [A_ab_eqâ‚ hab]
  refine â„¬_b_mem_inter ?_
  constructor
  Â· have : a.Finite := Set.Finite.subset hb hab
    have := IsSetAlgebra.biInter_mem (ğ’œ:=â„¬{b}) (S:=this.toFinset) (s:=B_h)
    simp_all
    apply this
    intro i hi
    exact B_h_mem_â„¬_b (hab hi)
  Â· have : (b \ a).Finite := Set.Finite.diff hb
    have := IsSetAlgebra.biInter_mem (ğ’œ:=â„¬{b}) (S:=this.toFinset) (s:=(B[Â·]á¶œ))
    simp_all

omit [Countable P] in
theorem A_ab_mem_â„¬ {a b : Set H[P]} (hb : b.Finite) (hab : a âŠ† b) : A{a,b} âˆˆ â„¬ := by
  rw [A_ab_eqâ‚ hab]
  apply IsSetAlgebra.inter_mem (by simp)
  Â· have : a.Finite := Set.Finite.subset hb hab
    have := IsSetAlgebra.biInter_mem (ğ’œ:=â„¬) (S:=this.toFinset) (s:=B_h) (by simp)
    simp_all
  Â· have : (b \ a).Finite := Set.Finite.diff hb
    have := IsSetAlgebra.biInter_mem (ğ’œ:=â„¬) (S:=this.toFinset) (s:=(B[Â·]á¶œ))
    simp_all

/-- **Lemma 2.** -/
theorem B_b_eq_iUnion_A_ab (hab : a âŠ† b) : B{a} = â‹ƒ c âˆˆ {c | a âŠ† c âˆ§ c âŠ† b}, A{c,b} := by
  symm
  calc
    â‹ƒ c âˆˆ {c | a âŠ† c âˆ§ c âŠ† b}, A{c,b} = â‹ƒ c âˆˆ {c | a âŠ† c âˆ§ c âŠ† b}, {d | c = d âˆ© b} := by simp [A_ab]
    _ = {d | a âŠ† d} := by ext; simp_all

/-- **Lemma 2.** rephrased for `B[h]` -/
theorem B_h_eq_iUnion_A_ab (hab : a âˆˆ b) : B[a] = â‹ƒ c âˆˆ {c | a âˆˆ c âˆ§ c âŠ† b}, A{c,b} := by
  have := B_b_eq_iUnion_A_ab (by simp [hab] : {a} âŠ† b)
  simp_all

/-- **Lemma 3.** (i) -/
theorem A_ab_subset_iff (hab : a âŠ† b) (hab' : a' âŠ† b') :
    A{a,b} âŠ† A{a',b'} â†” a' âŠ† a âˆ§ b' \ a' âŠ† b \ a := by
  sorry

/-- **Lemma 3.** (ii) -/
theorem A_ab_rel (hab : a âŠ† b) (hab' : a' âŠ† b') :
    A{a,b} âŠ† A{a',b'} âˆ¨ A{a',b'} âŠ† A{a,b} âˆ¨ A{a,b} âˆ© A{a',b'} = âˆ… := by
  by_contra q
  simp at q
  obtain âŸ¨qâ‚, qâ‚‚, qâ‚ƒâŸ© := q
  sorry

end ProbNetKAT
