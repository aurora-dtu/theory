import Mathlib.MeasureTheory.Constructions.BorelSpace.Basic
import Mathlib.MeasureTheory.SetAlgebra
import Mathlib.Order.CompletePartialOrder
import Mathlib.Topology.MetricSpace.Polish

/-!

# Cantor

This file defines the Cantor-space and its components.

## Main definitions

- [`B[h]`](find/?pattern=ProbNetKAT.B_h#doc): The subbasic sets of the Cantor space topology
  (denoted $B_h$ in the paper).
- [`B{b}`](find/?pattern=ProbNetKAT.B_b#doc): The subbasic sets extended to sets of the Cantor space
  topology (denoted $B_b$ in the paper).
- `ℬ`: The smallest σ-algebra generated by the Cantor-open sets.
- `ℬ.cantorSpace`: The Cantor space topology.
- `ℬ.borel`: The Borel measurable space generated from the Cantor space topology.
- [`ℬ{b}`](find/?pattern=ProbNetKAT.ℬ_b#doc): The smallest Set Algebra generated by `{B[h] | h ∈ b}`
  (denoted $ℬ_b$ in the paper).
- [`A{a,b}`](find/?pattern=ProbNetKAT.A_ab#doc): The atoms of `ℬ{b}`.

-/

set_option grind.warning false

namespace ProbNetKAT

open Topology MeasureTheory

variable {H : Type}

/-! ## The subbasic sets `B[h]` and `B{b}` -/

/-- **Equation (1.1)**

$$B[h] = \{ c ∣ h ∈ c \}$$
-/
def B_h (h : H) := {c : Set H | h ∈ c}
/-- **Equation (1.1)**

$$B\{b\} = \{ c ∣ b ⊆ c \}$$
-/
def B_b (b : Set H) := {c : Set H | b ⊆ c}

@[inherit_doc] notation "B[" h "]" => B_h h
@[inherit_doc] notation "B{" b "}" => B_b b

@[simp] theorem B_b_h_eq_B_h : B{{h}} = B[h] := by simp [B_h, B_b]
/-- **Lemma 1.** (i) -/
@[simp] theorem B_b_subset_iff : B{c} ⊆ B{b} ↔ b ⊆ c := by
  simp [B_b]; exact ⟨(· c (by rfl)), fun h _ h' ↦ subset_trans h h'⟩
/-- **Lemma 1.** (ii) -/
@[simp] theorem B_b_union_eq_inter : B{b ∪ c} = B{b} ∩ B{c} := by ext a; simp [B_b]
/-- **Lemma 1.** (iii) -/
@[simp] theorem B_b_empty : B{(∅ : Set H)} = Set.univ := by ext a; simp [B_b]

/-- The sets `B[h]` and `B[h]ᶜ` are the subbasic open sets of the Cantor space topology on 2H. -/
def ℬ.cantorSpace : TopologicalSpace (Set H) :=
  TopologicalSpace.generateFrom ({B[h] | h} ∪ {B[h]ᶜ | h})
/-- The Borel measurable space generated by the Cantor-topology. -/
def ℬ.borel : MeasurableSpace (Set H) := @_root_.borel _ ℬ.cantorSpace

/-- The Cantor space $2^H$ is a Polish space. -/
instance ℬ.polishSpace : @PolishSpace (Set H) ℬ.cantorSpace := sorry

/-- The Cantor space $2^H$ is second countable. -/
instance ℬ.secondCountable : @SecondCountableTopology (Set H) ℬ.cantorSpace :=
  PolishSpace.toSecondCountableTopology

/-! ## The Set Algebra `ℬ` -/

/-- The family of Borel sets `ℬ` is the smallest σ-algebra containing the Cantor-open sets.

The theorem `ℬ_is_borel` establishes this connection.
-/
def ℬ : Set (Set (Set H)) := generateSetAlgebra ℬ.cantorSpace.IsOpen

@[simp] theorem ℬ_IsSetAlgebra : IsSetAlgebra (ℬ (H:=H)) := isSetAlgebra_generateSetAlgebra
@[simp] theorem ℬ_IsSetRing : IsSetRing (ℬ (H:=H)) := ℬ_IsSetAlgebra.isSetRing
@[simp] theorem ℬ_IsSetSemiring : IsSetSemiring (ℬ (H:=H)) := ℬ_IsSetRing.isSetSemiring
@[simp] theorem ℬ_mem_empty : ∅ ∈ (ℬ (H:=H)) := generateSetAlgebra.empty
@[simp] theorem ℬ_mem_univ : Set.univ ∈ (ℬ (H:=H)) := IsSetAlgebra.univ_mem ℬ_IsSetAlgebra
@[simp] theorem ℬ_mem_compl : sᶜ ∈ (ℬ (H:=H)) ↔ s ∈ (ℬ (H:=H)) := by
  constructor
  · intro h
    have := generateSetAlgebra.compl _ h
    simp_all
    exact this
  · intro h; apply generateSetAlgebra.compl _ h
@[simp] theorem ℬ_mem_union : s ∈ (ℬ (H:=H)) ∧ t ∈ (ℬ (H:=H)) → s ∪ t ∈ (ℬ (H:=H)) := by
  intro h; apply generateSetAlgebra.union _ _ h.left h.right
@[simp] theorem ℬ_mem_inter : s ∈ (ℬ (H:=H)) ∧ t ∈ (ℬ (H:=H)) → s ∩ t ∈ (ℬ (H:=H)) := by
  intro h; apply IsSetAlgebra.inter_mem ℬ_IsSetAlgebra h.left h.right

/-- All set `B[b]` are open in the Cantor-space topology. -/
@[simp] theorem B_b_IsOpen_of_mem : IsOpen[ℬ.cantorSpace] B[b] := by
  refine TopologicalSpace.isOpen_generateFrom_of_mem ?_
  simp

/-- All set `B[b]` are closed in the Cantor-space topology. -/
@[simp] theorem B_b_IsClosed_of_mem : IsClosed[ℬ.cantorSpace] B[b] :=
  (@isOpen_compl_iff _ _ ℬ.cantorSpace).mp (TopologicalSpace.isOpen_generateFrom_of_mem (by simp))

@[simp] theorem ℬ.isClosed_of_isOpen (h : IsOpen[ℬ.cantorSpace] S) : IsClosed[ℬ.cantorSpace] S := by
  induction h with
  | basic s hs =>
    simp_all
    obtain (⟨w, hw⟩ | ⟨w, hw⟩) := hs
    all_goals (subst_eqs; simp_all)
  | univ => exact @isClosed_univ _ ℬ.cantorSpace
  | inter _ _ _ _ ih₁ ih₂ => exact @IsClosed.inter _ _ _ ℬ.cantorSpace ih₁ ih₂
  | sUnion S hsS ih =>
    sorry

/-- From [Wikipedia](https://en.wikipedia.org/wiki/Clopen_set#Properties):

> Using the union and intersection as operations, the clopen subsets of a given topological space X
> form a Boolean algebra. Every Boolean algebra can be obtained in this way from a suitable
> topological space: see Stone's representation theorem for Boolean algebras.
-/
@[simp] theorem ℬ.isClosed_iff_isOpen : IsClosed[ℬ.cantorSpace] S ↔ IsOpen[ℬ.cantorSpace] S := by
  constructor
  · intro h
    apply (@isOpen_compl_iff _ _ ℬ.cantorSpace).mpr at h
    generalize h' : Sᶜ = S'
    suffices IsOpen[ℬ.cantorSpace] S'ᶜ by subst_eqs; simp_all
    simp_all
  · simp_all

/-- All set in `ℬ` are open in the Cantor-space topology. -/
theorem ℬ.IsOpen_of_mem (h : b ∈ ℬ) : IsOpen[ℬ.cantorSpace] b := by
  induction h with
  | base s s_mem => exact s_mem
  | empty => simp
  | compl y hy ih => simp_all
  | union _ _ _ _ ih₁ ih₂ =>
    exact @IsOpen.union _ _ _ ℬ.cantorSpace ih₁ ih₂

/-- The family of Borel sets `ℬ` is the smallest σ-algebra containing the Cantor-open sets. -/
theorem ℬ_is_borel : S ∈ ℬ ↔ MeasurableSet[ℬ.borel] S := by
  constructor
  · intro h
    induction h with
    | base s s_mem => exact MeasurableSpace.measurableSet_generateFrom s_mem
    | empty => simp
    | compl _ _ ih => exact MeasurableSet.compl_iff.mpr ih
    | union => exact MeasurableSet.union (by assumption) (by assumption)
  · intro h
    induction h with
    | basic s s_mem => exact generateSetAlgebra.base s s_mem
    | empty => simp
    | compl _ _ ih => exact IsSetAlgebra.compl_mem ℬ_IsSetAlgebra ih
    | iUnion f h₁ h₂ =>
      apply MeasureTheory.self_subset_generateSetAlgebra (@isOpen_iUnion _ _ ℬ.cantorSpace _ _)
      exact fun i ↦ ℬ.IsOpen_of_mem (h₂ i)

/-! ## The Set Algebra `ℬ{b}` -/

/-- Let `ℬ{b}` be the Boolean subalgebra of `ℬ` generated by `{B[h] | h ∈ b}`. -/
def ℬ_b (b : Set H) := generateSetAlgebra {B[h] | h ∈ b}
@[inherit_doc] notation "ℬ{" b "}" => ℬ_b b

theorem ℬ_b_mono {a b : Set H} (h : a ⊆ b) : ℬ{a} ⊆ ℬ{b} := by
  apply generateSetAlgebra_mono
  simp only [Set.setOf_subset_setOf, forall_exists_index, and_imp, forall_apply_eq_imp_iff₂]
  exact fun x hx ↦ ⟨x, h hx, rfl⟩

@[simp] theorem ℬ_b_IsSetAlgebra : IsSetAlgebra (ℬ{b}) := isSetAlgebra_generateSetAlgebra
@[simp] theorem ℬ_b_IsSetRing : IsSetRing (ℬ{b}) := ℬ_b_IsSetAlgebra.isSetRing
@[simp] theorem ℬ_b_IsSetSemiring : IsSetSemiring (ℬ{b}) := ℬ_b_IsSetRing.isSetSemiring
@[simp] theorem ℬ_b_mem_empty {b : Set H} : ∅ ∈ ℬ{b} := generateSetAlgebra.empty
@[simp] theorem ℬ_b_mem_univ {b : Set H} : Set.univ ∈ ℬ{b} := IsSetAlgebra.univ_mem ℬ_b_IsSetAlgebra
@[simp] theorem ℬ_b_mem_compl {b : Set H} : sᶜ ∈ ℬ{b} ↔ s ∈ ℬ{b} := by
  constructor
  · intro h
    rw [← compl_compl (x:=s)]
    exact IsSetAlgebra.compl_mem (by simp) h
  · intro h; apply generateSetAlgebra.compl _ h
@[simp] theorem ℬ_b_mem_union {b : Set H} : s ∈ ℬ{b} ∧ t ∈ ℬ{b} → s ∪ t ∈ ℬ{b} :=
  fun h ↦ generateSetAlgebra.union _ _ h.left h.right
@[simp] theorem ℬ_b_mem_inter {b : Set H} : s ∈ ℬ{b} ∧ t ∈ ℬ{b} → s ∩ t ∈ ℬ{b} :=
  fun h ↦ IsSetAlgebra.inter_mem ℬ_b_IsSetAlgebra h.left h.right

@[simp] theorem B_h_mem_ℬ_b_univ : B[i] ∈ ℬ{Set.univ} := by
  apply generateSetAlgebra.base; use i; simp
@[simp] theorem B_h_mem_ℬ_b (hi : i ∈ b) : B[i] ∈ ℬ{b} := by apply generateSetAlgebra.base; use i
@[simp] theorem B_h_mem_ℬ : B[i] ∈ ℬ := generateSetAlgebra.base _ B_b_IsOpen_of_mem

/-- If `b` is finite, so is `ℬ{b}`. -/
theorem ℬ_b_finite_of_finite (h : b.Finite) : ℬ{b}.Finite := sorry

/-- For a set `X`, we let `℘ω(X)` denote the finite subsets of `X`. -/
def ℘ω (X : Set α) := {Y ⊆ X | Y.Finite}

/-- **Lemma 1.** (iv) -/
theorem ℬ_b_eq_iUnion : ℬ{(Set.univ : Set H)} = ⋃ b ∈ ℘ω Set.univ, ℬ{b} := by
  ext A
  simp only [℘ω, Set.subset_univ, true_and, Set.mem_setOf_eq, Set.mem_iUnion, exists_prop]
  constructor
  · intro h
    induction h with
    | base B hB =>
      obtain ⟨h, hh⟩ := hB
      use {h}, Set.finite_singleton h
      exact generateSetAlgebra.base _ (by simp_all)
    | empty => use {}; simp
    | compl B hB ih =>
      obtain ⟨C, hC, hC'⟩ := ih
      use C, hC
      exact generateSetAlgebra.compl _ hC'
    | union B C hB hC ihB ihC =>
      replace hB : B ∈ ℬ{Set.univ} := hB
      replace hC : C ∈ ℬ{Set.univ} := hC
      obtain ⟨X, hX₁, hX₂⟩ := ihB
      obtain ⟨Y, hY₁, hY₂⟩ := ihC
      use X ∪ Y
      constructor
      · exact Set.Finite.union hX₁ hY₁
      · apply generateSetAlgebra.union _ _ <;> show _ ∈ ℬ{X ∪ Y}
        · apply generateSetAlgebra_mono _ hX₂
          simp_all only [Set.mem_union, Set.setOf_subset_setOf, forall_exists_index, and_imp,
            forall_apply_eq_imp_iff₂]
          intro h hh; use h
          simp_all only [true_or, and_self]
        · apply generateSetAlgebra_mono _ hY₂
          simp_all only [Set.mem_union, Set.setOf_subset_setOf, forall_exists_index, and_imp,
            forall_apply_eq_imp_iff₂]
          intro h hh; use h
          simp_all only [or_true, and_self]
  · rintro ⟨B, hB, hB'⟩; apply MeasureTheory.generateSetAlgebra_mono (by simp) hB'

theorem ℬ_b_mem_iff_exists : B ∈ ℬ{(Set.univ : Set H)} ↔ ∃ i, i.Finite ∧ B ∈ ℬ{i} := by
  simp [ℬ_b_eq_iUnion, ℘ω]

@[simp]
theorem ℬ_borel_le_generateFrom : ℬ.borel (H:=H) ≤ MeasurableSpace.generateFrom ℬ{Set.univ} := by
  simp [ℬ.borel]
  rw [@borel_eq_generateFrom_of_subbasis _ _ ℬ.cantorSpace ℬ.secondCountable rfl]
  refine MeasurableSpace.generateFrom_mono ?_
  simp_all
  constructor
  all_goals intro a; simp_all; rintro _ ⟨_⟩; simp

/-! ## The atoms `A{a,b}` -/

/-- The atoms of `ℬ{b}` are in one-to-one correspondence with the subsets `a ⊆ b`, the subset `a`
    determining which `B[h]` occur positively in the construction of the atom:

```
A{a,b} = ⋂ h ∈ a, B[h] ∩ ⋂ h ∈ b \ a, B[h]ᶜ = B{a} \ ⋃ a ⊂ c ∧ c ⊆ b, B{c} = {c | a = c ∩ b}
```

Formulated in in `A_ab_eq₁`, `A_ab_eq₂`, and, `A_ab_eq₃`.
-/
def A_ab (a b : Set H) := {c | a = c ∩ b}
@[inherit_doc] notation "A{" a "," b "}" => A_ab a b

/-- **Definition (i)** of `A{a,b}`. -/
def A_ab_eq₁ (hab : a ⊆ b) : A{a,b} = (⋂ h ∈ a, B[h]) ∩ (⋂ h ∈ (b \ a), B[h]ᶜ) := by
  ext c
  simp only [A_ab, Set.mem_setOf_eq, B_h, Set.mem_diff, Set.mem_inter_iff, Set.mem_iInter,
    Set.mem_compl_iff, and_imp]
  constructor
  · rintro ⟨_⟩
    simp_all only [Set.mem_inter_iff, implies_true, and_true, not_false_eq_true, and_self]
  · simp_all only [and_imp]
    intro h h'
    simp [not_imp_not] at h'
    replace h' : ∀ i, i ∈ b → i ∈ c → i ∈ a := h'
    replace h' : ∀ i, i ∈ c → i ∈ b → i ∈ a := by exact fun i h₁ h₂ => h' i h₂ h₁
    ext v
    simp_all
    constructor
    · intro h₁
      exact ⟨h v h₁, hab h₁⟩
    · intro ⟨h₁, h₂⟩
      exact h' v h₁ h₂

/-- **Definition (ii)** of `A{a,b}`. -/
theorem A_ab_eq₂ (hab : a ⊆ b) : A{a,b} = B{a} \ ⋃ (c : {c | a ⊂ c ∧ c ⊆ b}), B{c} := by
  ext c
  constructor
  · rintro ⟨_⟩
    simp [A_ab, B_b]
    intro c hcbc hcb
    contrapose! hcbc
    simp_all [not_ssubset_of_subset]
  · simp_all [A_ab_eq₁ hab, B_h, B_b]
    intro h h'
    contrapose h'
    simp_all
    replace h' := h' h
    obtain ⟨w, hwb, hwa, hwc⟩ := h'
    use (b ∩ c) ∪ {w}
    constructor
    · simp
      refine (Set.ssubset_iff_of_subset ?_).mpr ?_
      · simp_all
      · use w; simp_all
    · simp_all

/-- **Definition (iii)** of `A{a,b}`. -/
theorem A_ab_eq₃ (_hab : a ⊆ b) : A{a,b} = {c | a = c ∩ b} := rfl

@[simp] theorem A_ab_a_mem (hab : a ⊆ b) : a ∈ A{a,b} := by simp [hab, A_ab]

@[simp] theorem A_ab_same_eq_B_b : A{b,b} = B{b} := by ext; simp [A_ab_eq₃, B_b]

theorem A_ab_mem_ℬ_b {a b : Set H} (hb : b.Finite) (hab : a ⊆ b) : A{a,b} ∈ ℬ{b} := by
  rw [A_ab_eq₁ hab]
  refine ℬ_b_mem_inter ?_
  constructor
  · have : a.Finite := Set.Finite.subset hb hab
    have := IsSetAlgebra.biInter_mem (𝒜:=ℬ{b}) (S:=this.toFinset) (s:=B_h)
    simp_all
    apply this
    intro i hi
    exact B_h_mem_ℬ_b (hab hi)
  · have : (b \ a).Finite := Set.Finite.diff hb
    have := IsSetAlgebra.biInter_mem (𝒜:=ℬ{b}) (S:=this.toFinset) (s:=(B[·]ᶜ))
    simp_all

theorem A_ab_mem_ℬ {a b : Set H} (hb : b.Finite) (hab : a ⊆ b) : A{a,b} ∈ ℬ := by
  rw [A_ab_eq₁ hab]
  apply IsSetAlgebra.inter_mem (by simp)
  · have : a.Finite := Set.Finite.subset hb hab
    have := IsSetAlgebra.biInter_mem (𝒜:=ℬ) (S:=this.toFinset) (s:=B_h) (by simp)
    simp_all
  · have : (b \ a).Finite := Set.Finite.diff hb
    have := IsSetAlgebra.biInter_mem (𝒜:=ℬ) (S:=this.toFinset) (s:=(B[·]ᶜ))
    simp_all

/-- **Lemma 2.** -/
theorem B_b_eq_iUnion_A_ab (hab : a ⊆ b) : B{a} = ⋃ c ∈ {c | a ⊆ c ∧ c ⊆ b}, A{c,b} := by
  symm
  calc
    ⋃ c ∈ {c | a ⊆ c ∧ c ⊆ b}, A{c,b} = ⋃ c ∈ {c | a ⊆ c ∧ c ⊆ b}, {d | c = d ∩ b} := by simp [A_ab]
    _ = {d | a ⊆ d} := by ext; simp_all

/-- **Lemma 2.** rephrased for `B[h]` -/
theorem B_h_eq_iUnion_A_ab (hab : a ∈ b) : B[a] = ⋃ c ∈ {c | a ∈ c ∧ c ⊆ b}, A{c,b} := by
  have := B_b_eq_iUnion_A_ab (by simp [hab] : {a} ⊆ b)
  simp_all

/--
For any `B ∈ ℬ{b}` there exists **finite** set of **subsets of `b`**, call it `q`, who's **disjoint
union** satisfies `B = ⋃ a ∈ q, A{a,b}`.
-/
def ℬ_b_exists_cover (hsb : B ∈ ℬ{b}) (hb : b.Finite) :
    ∃ q : Set (Set H),
      B = ⋃ a ∈ q, A{a,b}
      ∧ Set.PairwiseDisjoint q (A{·,b})
      ∧ q.Finite
      ∧ (B.Nonempty ↔ q.Nonempty)
      ∧ ∀ a ∈ q, a ⊆ b := by
  induction hsb with clear B
  | base s hs =>
    simp only [Set.mem_setOf_eq] at hs
    obtain ⟨w, hw, _, _⟩ := hs
    nth_rw 1 [B_h_eq_iUnion_A_ab hw]
    simp
    apply Exists.intro
    · split_ands
      · rfl
      · intro x hx y hy hxy a hax hay q hq
        simp_all
        replace hax := hax hq
        replace hqy := hay hq
        simp_all [A_ab]
      · show {a | w ∈ a ∧ a ⊆ b}.Finite
        suffices {a | a ⊆ b}.Finite by exact Set.Finite.subset this (by simp)
        exact Set.Finite.finite_subsets hb
      · constructor
        · intro _
          use {w}
          show w ∈ ({w} : Set H) ∧ {w} ⊆ b
          simp [hw]
        · intro h
          replace h : {c | w ∈ c ∧ c ⊆ b}.Nonempty := h
          obtain ⟨c, h₁, h₂⟩ := h
          use {w}
          simp [B_h]
      · show ∀ a ∈ {c | w ∈ c ∧ c ⊆ b}, a ⊆ b
        simp
  | empty => use {}; simp
  | compl s hs ih =>
    replace hs : s ∈ ℬ{b} := hs
    obtain ⟨w, ⟨_, _, _⟩, hw⟩ := ih
    simp_all
    clear hs
    use {a ∈ wᶜ | a ⊆ b}
    split_ands
    · ext a
      simp_all [A_ab]
      constructor
      · intro h
        exact fun a_1 ↦ h (a ∩ b) a_1 rfl
      · intro h i hi q
        subst_eqs
        contradiction
    · intro x hx y hy hxy a hax hay q hq
      simp_all
      replace hax := hax hq
      replace hqy := hay hq
      simp_all [A_ab]
    · suffices {a | a ⊆ b}.Finite by exact Set.Finite.subset this (by simp)
      exact Set.Finite.finite_subsets hb
    · simp
      constructor
      · simp
        intro x hx
        if hw : w.Nonempty then
          simp_all
          obtain ⟨c, hc⟩ := hw
          have : ∀ i, x ∈ A{i,b} → i ∉ w := fun i a a_1 ↦ hx i a_1 a
          simp [A_ab] at this
          use x ∩ b
          simp_all
        else
          simp_all
          have : w = ∅ := by exact Set.not_nonempty_iff_eq_empty.mp hw
          subst_eqs
          simp_all
          use b
          simp
      · rintro ⟨x, hx₁, hx₂⟩
        simp [A_ab]
        if hwN : w.Nonempty then
          simp_all
          have ⟨q, hq₁, hq₂⟩ := hw.right.right.left
          contrapose! hx₁
          obtain ⟨y, hy⟩ := hq₂
          simp [A_ab] at hy
          subst_eqs
          simp_all
          have := hx₁ x
          have : x ∩ b = x := by simp_all
          simp_all
        else
          have : w = ∅ := Set.not_nonempty_iff_eq_empty.mp hwN
          subst_eqs
          simp_all
    · simp
  | union s t hs ht ihs iht =>
    replace hs : s ∈ ℬ{b} := hs
    replace ht : t ∈ ℬ{b} := ht
    obtain ⟨s, ⟨_, _, _⟩, ihs⟩ := ihs
    obtain ⟨t, ⟨_, _, _⟩, iht⟩ := iht
    use s ∪ t
    split_ands
    · ext x
      simp_all
      constructor
      · rintro (⟨i, his, hxi⟩ | ⟨i, hit, hxi⟩)
        all_goals (use i; simp_all)
      · rintro ⟨i, (hsi | hti), hi⟩
        · left; use i
        · right; use i
    · intro x hx y hy hxy a hax hay q hq
      simp_all only [Set.nonempty_iUnion, exists_prop, Set.mem_union, ne_eq, Set.le_eq_subset,
        Set.bot_eq_empty, Set.mem_empty_iff_false]
      replace hax := hax hq
      replace hqy := hay hq
      simp_all [A_ab]
    · refine Set.Finite.union ihs.right.left iht.right.left
    · simp_all only [Set.nonempty_iUnion, exists_prop, Set.union_nonempty]
    · simp_all
      rintro a (ha | ha)
      · exact ihs.right.right.right _ ha
      · exact iht.right.right.right _ ha


theorem ℬ_b_unique_exists_cover.base (hb : b.Finite) (hs : s ∈ {x | ∃ h ∈ b, B[h] = x}) :
    ∃! q : Set (Set H),
        s = ⋃ a ∈ q, A{a,b}
      ∧ (q.PairwiseDisjoint fun x ↦ A{x,b})
      ∧ q.Finite
      ∧ (s.Nonempty ↔ q.Nonempty)
      ∧ ∀ a ∈ q, a ⊆ b := by
  simp only [Set.mem_setOf_eq] at hs
  obtain ⟨w, hw, _, _⟩ := hs
  nth_rw 1 [B_h_eq_iUnion_A_ab hw]
  simp
  apply Exists.intro
  · split_ands
    · rfl
    · intro x hx y hy hxy a hax hay q hq
      simp_all
      replace hax := hax hq
      replace hqy := hay hq
      simp_all [A_ab]
    · show {a | w ∈ a ∧ a ⊆ b}.Finite
      suffices {a | a ⊆ b}.Finite by exact Set.Finite.subset this (by simp)
      exact Set.Finite.finite_subsets hb
    · constructor
      · intro _
        use {w}
        show w ∈ ({w} : Set H) ∧ {w} ⊆ b
        simp [hw]
      · intro h
        replace h : {c | w ∈ c ∧ c ⊆ b}.Nonempty := h
        obtain ⟨c, h₁, h₂⟩ := h
        use {w}
        simp [B_h]
    · show ∀ a ∈ {c | w ∈ c ∧ c ⊆ b}, a ⊆ b
      simp
    · simp_all only [and_imp]
      intro y hy h_disjoint h_fin h_nonempty h
      show y = {c | w ∈ c ∧ c ⊆ b}
      simp [Set.ext_iff] at hy
      ext x
      simp_all only [Set.mem_setOf_eq]
      constructor
      · intro hxy
        replace hy := hy x |>.mpr
        simp_all only [forall_exists_index, and_imp, and_true]
        have ⟨i, ⟨h₁, h₂⟩, h₃⟩ := hy x hxy (A_ab_a_mem (h x hxy)); clear hy
        simp only [A_ab, Set.mem_setOf_eq] at h₃
        subst_eqs
        simp_all only [Set.mem_inter_iff, and_true, Set.inter_subset_right]
      · intro ⟨h₁, h₂⟩
        replace hy := hy x |>.mp
        simp_all only [A_ab, Set.mem_setOf_eq, exists_eq_right, Set.mem_inter_iff, and_self,
          Set.inter_subset_right, forall_const]
        induction y, h_fin using Set.Finite.induction_on with
        | empty => simp_all only [Set.pairwiseDisjoint_empty, Set.not_nonempty_empty, iff_false,
          Set.mem_empty_iff_false, IsEmpty.forall_iff, implies_true]
        | insert hsy ih h₃ =>
          rename_i s y
          simp_all only [Set.insert_nonempty, true_iff, Set.mem_insert_iff, or_true, implies_true,
            forall_const, iff_true, forall_eq_or_imp]
          rcases hy with hy | hy
          · subst_eqs
            simp_all only [IsEmpty.forall_iff, implies_true, Set.inter_subset_right, true_and,
              Set.left_eq_inter, true_or]
          · simp_all only [forall_const]
            right
            apply h₃ _ (Set.nonempty_of_mem hy)
            intro u huy v hvy huv
            exact h_disjoint (Set.mem_insert_of_mem s huy) (Set.mem_insert_of_mem s hvy) huv

theorem ℬ_b_unique_exists_cover.empty (hb : b.Finite) :
    ∃! q : Set (Set H), ∅ = ⋃ a ∈ q, A{a,b}
      ∧ (q.PairwiseDisjoint fun x ↦ A{x,b})
      ∧ q.Finite
      ∧ ((∅ : Set (Set H)).Nonempty ↔ q.Nonempty)
      ∧ ∀ a ∈ q, a ⊆ b := by
  use {}
  simp
  intro y h_empty h_disjoint h_fin h_nonempty h
  exact Set.not_nonempty_iff_eq_empty.mp h_nonempty

theorem A_ab_inj {b : Set H} : Function.Injective (fun (a : {a | a ⊆ b}) ↦ A{a,b}) := by
  intro ⟨a₁, hab₁⟩ ⟨a₂, hab₂⟩ h
  simp_all [A_ab, Set.ext_iff]
  simp_all [A_ab, Set.ext_iff]
  intro x
  constructor
  · intro h'
    have h₁ := h a₁
    have h₂ := h a₂
    clear h
    simp_all [hab₁]
    replace h₁ := h₁.mp (fun x a ↦ hab₁ a)
    simp_all
  · intro h'
    have h₁ := h a₁
    clear h
    simp_all
    replace h₁ := h₁.mp (fun x a ↦ hab₁ a)
    simp_all

@[simp] theorem A_ab_mem_iff : x ∈ A{a,b} ↔ a = x ∩ b := by simp [A_ab]

set_option maxHeartbeats 5000000 in
/--
For any `B ∈ ℬ{b}` there exists **finite** set of **subsets of `b`**, call it `q`, who's **disjoint
union** satisfies `B = ⋃ a ∈ q, A{a,b}`.
-/
def ℬ_b_unique_exists_cover (hsb : B ∈ ℬ{b}) (hb : b.Finite) :
    ∃! q : Set (Set H),
      B = ⋃ a ∈ q, A{a,b}
      ∧ Set.PairwiseDisjoint q (A{·,b})
      ∧ q.Finite
      ∧ (B.Nonempty ↔ q.Nonempty)
      ∧ ∀ a ∈ q, a ⊆ b := by
  induction hsb with clear B
  | base s hs => exact ℬ_b_unique_exists_cover.base hb hs
  | empty => exact ℬ_b_unique_exists_cover.empty hb
  | compl s hs ih =>
    sorry
    -- replace hs : s ∈ ℬ{b} := hs
    -- obtain ⟨w, ⟨_, _, _⟩, hw⟩ := ih
    -- simp_all
    -- clear hs
    -- use {a ∈ wᶜ | a ⊆ b}
    -- split_ands
    -- · ext a
    --   simp_all [A_ab]
    --   constructor
    --   · intro h
    --     exact fun a_1 ↦ h (a ∩ b) a_1 rfl
    --   · intro h i hi q
    --     subst_eqs
    --     contradiction
    -- · intro x hx y hy hxy a hax hay q hq
    --   simp_all
    --   replace hax := hax hq
    --   replace hqy := hay hq
    --   simp_all [A_ab]
    -- · suffices {a | a ⊆ b}.Finite by exact Set.Finite.subset this (by simp)
    --   exact Set.Finite.finite_subsets hb
    -- · simp
    --   constructor
    --   · simp
    --     intro x hx
    --     if hw : w.Nonempty then
    --       simp_all
    --       obtain ⟨c, hc⟩ := hw
    --       have : ∀ i, x ∈ A{i,b} → i ∉ w := fun i a a_1 ↦ hx i a_1 a
    --       simp [A_ab] at this
    --       use x ∩ b
    --       simp_all
    --     else
    --       simp_all
    --       have : w = ∅ := by exact Set.not_nonempty_iff_eq_empty.mp hw
    --       subst_eqs
    --       simp_all
    --       use b
    --       simp
    --   · rintro ⟨x, hx₁, hx₂⟩
    --     simp [A_ab]
    --     if hwN : w.Nonempty then
    --       simp_all
    --       have ⟨q, hq₁, hq₂⟩ := hw.right.right.left
    --       contrapose! hx₁
    --       obtain ⟨y, hy⟩ := hq₂
    --       simp [A_ab] at hy
    --       subst_eqs
    --       simp_all
    --       have := hx₁ x
    --       have : x ∩ b = x := by simp_all
    --       simp_all
    --     else
    --       have : w = ∅ := Set.not_nonempty_iff_eq_empty.mp hwN
    --       subst_eqs
    --       simp_all
    -- · simp
  | union s t hs ht ihs iht =>
    replace hs : s ∈ ℬ{b} := hs
    replace ht : t ∈ ℬ{b} := ht
    obtain ⟨s, ⟨⟨_⟩, _, s_finite, s_nonempty, hsab⟩, ihs⟩ := ihs
    obtain ⟨t, ⟨⟨_⟩, _, t_finite, t_nonempty, htab⟩, iht⟩ := iht
    use s ∪ t
    simp only [Set.nonempty_iUnion, exists_prop, and_imp, Set.mem_union, Set.finite_union,
      Set.union_nonempty] at *
    split_ands
    · ext x
      sorry
      -- constructor
      -- · rintro (⟨i, his, hxi⟩ | ⟨i, hit, hxi⟩)
      --   all_goals (use i; simp_all)
      -- · rintro ⟨i, (hsi | hti), hi⟩
      --   · left; use i
      --   · right; use i
    · intro x hx y hy hxy a hax hay q hq
      simp only [Set.nonempty_iUnion, exists_prop, and_imp, Set.mem_union, ne_eq, Set.le_eq_subset,
        Set.bot_eq_empty, Set.mem_empty_iff_false] at *
      replace hax := hax hq
      replace hay := hay hq
      simp [A_ab] at *
      subst_eqs
      contradiction
    · exact s_finite
    · clear ihs iht
      simp_all only [Set.nonempty_iUnion, exists_prop, Set.union_nonempty]
    · exact or_congr s_nonempty t_nonempty
    · intro y hy
      rcases hy with hy | hy
      · simp [*]
      · simp [*]
    · intro y hy hy_disjoint hy_finite h_nonemp h
      simp only [Set.ext_iff, Set.mem_union, Set.mem_iUnion, exists_prop] at hy ⊢
      intro x
      clear ihs iht
      replace hy := hy x
      constructor
      · intro h'
        sorry
      · intro h'

        sorry

def ℬ_b_cover {b : Set H} (hsb : B ∈ ℬ{b}) (hb : b.Finite) : Set (Set H) :=
  (ℬ_b_exists_cover hsb hb).choose
def ℬ_b_cover_spec {b : Set H} (hsb : B ∈ ℬ{b}) (hb : b.Finite) :
      B = ⋃ a ∈ (ℬ_b_cover hsb hb), A{a,b}
    ∧ Set.PairwiseDisjoint (ℬ_b_cover hsb hb) (A{·,b})
    ∧ (ℬ_b_cover hsb hb).Finite
    ∧ (B.Nonempty ↔ (ℬ_b_cover hsb hb).Nonempty)
    ∧ ∀ a ∈ (ℬ_b_cover hsb hb), a ⊆ b :=
  (ℬ_b_exists_cover hsb hb).choose_spec

theorem ℬ_cover_eq {b : Set H} (hsb : B ∈ ℬ{b}) (hb : b.Finite) :
    B = ⋃ a ∈ ℬ_b_cover hsb hb, A{a,b} := by
  have := ℬ_b_cover_spec hsb hb
  simp_all

/-- **Lemma 3.** (i) -/
theorem A_ab_subset_iff (hab : a ⊆ b) (hab' : a' ⊆ b') :
    A{a,b} ⊆ A{a',b'} ↔ a' ⊆ a ∧ b' \ a' ⊆ b \ a := by
  sorry

/-- **Lemma 3.** (ii) -/
theorem A_ab_rel (hab : a ⊆ b) (hab' : a' ⊆ b') :
    A{a,b} ⊆ A{a',b'} ∨ A{a',b'} ⊆ A{a,b} ∨ A{a,b} ∩ A{a',b'} = ∅ := by
  by_contra q
  simp at q
  obtain ⟨q₁, q₂, q₃⟩ := q
  sorry

end ProbNetKAT
