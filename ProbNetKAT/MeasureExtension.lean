import Mathlib.MeasureTheory.OuterMeasure.OfAddContent
import ProbNetKAT.Cantor
import ProbNetKAT.MathlibExt
import ProbNetKAT.AtomCover
import MDP.ENNRealExt

/-!

# Measure extension

Formulation of **Theorem 1** stating that:

> A function `Î¼ : { B{b} | b.Finite } â†’ [0,1]` extends to a measure `Î¼ : â„¬ â†’ [0,1]` under certain
> conditions.

The final definition realizing this theorem is `extend_measure`.

The general outline of the proof of this theorem is as follows:
- TODO: this is _CarathÃ©odory's extension theorem_ on `B âˆˆ â„¬{Set.univ}` to get `B âˆˆ â„¬`
- First determining a finite `b` s.t. any `B âˆˆ â„¬{Set.univ}` becomes a `B âˆˆ â„¬{b}`. TODO: fix for any
  B there exits a b
  - The `b` is given by `ProbNetKAT.â„¬_b_mem_iff_exists`.
  - The extension here is done by _CarathÃ©odory's extension theorem_, given by
    `MeasureTheory.AddContent.measure`.
- The measure `Î¼ B` of any such `B âˆˆ â„¬{b}` can be written as the **finite disjoint union of atoms**
  (see `ProbNetKAT.â„¬_b_exists_cover`), giving us `âˆ‘ a, Î¼ A{a,b}`.
- The measure `Î¼ A{a,b}` can be further decomposed using _inclusion-exclusion_ (see
  `MeasureTheory.ennreal_inclusion_exclusion`). This then becomes a sum over `B{b}` by
  `ProbNetKAT.B_b_union_eq_inter`.

Connecting the steps defines a new measure on `â„¬` defined only on `B{b}` for finite `b`.
-/

/-!

## Secondary outline

We are given $Î¼$ defined on $B\{b\}$ for $b$ finite.

$$Î¼(B\{b\}) = \text{given}$$

Using _inclusion-exclusion_ we can lift this definition to $A\{a,b\}$.

$$Î¼(A\{a,b\}) = \sum_{a âŠ† c âŠ† b} (-1)^{|c \setminus a|} Î¼(B\{c\})$$

We know that every $B âˆˆ â„¬\{b\}$ is the disjoint union of a finite set of atoms.

$$Î¼(B âˆˆ â„¬\{b\}) = \sum_{a âˆˆ ğ’œ(B)} Î¼(A\{a,b\})$$

We know that every $B âˆˆ â„¬\{2^H\}$ there exists a finite $b$ such that $B âˆˆ â„¬\{b\}$.

$$Î¼(B âˆˆ â„¬\{2^H\}) = Î¼(B âˆˆ â„¬\{b\})$$

By _CarathÃ©odory's extension theorem_ we can extend to the measurable sets.

$$Î¼(B âˆˆ â„¬) = Î¼(B âˆˆ â„¬\{2^H\})$$

-/

/-!

## Unrolled definition

Let $b_B$ denote the finite $b$ such that $B âˆˆ â„¬\{b\}$ where originally $B âˆˆ â„¬\{2^H\}$.

Let $ğ’œ(B âˆˆ â„¬\{2^H\})$ denote the finite cover of disjoint atoms such that $B = \bigcup_{a âˆˆ ğ’œ(B)}
A\{a,b_B\}$.

$$
\begin{aligned} Î¼(B âˆˆ â„¬\{2^H\}) &= Î¼(B âˆˆ â„¬\{b_B\}) \\\\
&= \sum_{a âˆˆ ğ’œ(B)} Î¼(A\{a, b_B\}) \\\\
&= \sum_{a âˆˆ ğ’œ(B)} \sum_{a âŠ† c âŠ† b_B} (-1)^{|c \setminus a|}Î¼(B\{c\}) \\\\
\end{aligned}
$$

-/

set_option grind.warning false

namespace ProbNetKAT

open Topology MeasureTheory

variable {P : Type} [Countable P]

/-- The set of all `B{b}` generated by `b` finite. -/
def B_b_fin : Set (Set (Set H[P])) := ((B{Â·}) '' {b : Set H[P] | b.Finite})

variable {a b : Set H[P]}

-- inductive Thingy : Set (Set H[P]) â†’ Set (Set (Set (Set H[P]))) where
--   | base (b : Set H[P]) (hb : b.Finite) : Thingy B{b} {B{b}}
--   | Aab (a b) (hab : a âŠ† b) (hb : b.Finite) : Thingy A{a,b}
--   -- | B_b (b) (hb : b.Finite) (B) (hB : B âˆˆ â„¬{b}) : Thingy B
--   -- | B (hB : B âˆˆ â„¬{Set.univ}) : Thingy B

abbrev SetOf (T : Type) : Set T := Set.univ

notation "â‚‚" H => SetOf H

example : x âˆˆ â‚‚H[P] := by
  simp

def join (S : Set (Set (Set H[P]))) : Set (Set H[P]) := â‹ƒâ‚€ S

def â„¬_b_gen {B : Set (Set H[P])} (hB : B âˆˆ â„¬{Set.univ}) : Set H[P] :=
  â„¬_b_mem_iff_exists.mp hB |>.choose
def â„¬_b_gen_spec {B : Set (Set H[P])} (hB : B âˆˆ â„¬{Set.univ}) :
    (â„¬_b_gen hB).Finite âˆ§ B âˆˆ â„¬{â„¬_b_gen hB} := â„¬_b_mem_iff_exists.mp hB |>.choose_spec

@[simp] theorem B_b_mem_â„¬_b : B{b} âˆˆ â„¬{b} := sorry
@[simp] theorem B_b_mem_â„¬_b_univ : B{b} âˆˆ â„¬{Set.univ} := sorry

-- open scoped Classical in
def b_B_gen (B : â„¬{â‚‚H[P]}) : Set H[P] :=
  -- if h : âˆƒ b : Set H, B = B{b} âˆ§ b.Finite then h.choose else
  -- if h : âˆƒ b a : Set H, B = A{a,b} âˆ§ b.Finite âˆ§ a âŠ† b then h.choose else
  â„¬_b_mem_iff_exists.mp B.prop |>.choose

notation "b{" B "}" => b_B_gen B

def b_B_gen_spec (B : â„¬{â‚‚H[P]}) :
    b{B}.Finite âˆ§ B.val âˆˆ â„¬{b{B}} := by
  -- simp [b_B_gen]
  -- split_ifs with h h
  -- Â· set b := h.choose
  --   have hb : B = B{b} âˆ§ b.Finite := h.choose_spec
  --   simp_all
  -- Â· set b := h.choose
  --   have hb : âˆƒ a, â†‘B = A{a,b} âˆ§ b.Finite âˆ§ a âŠ† b := h.choose_spec
  --   set a := hb.choose
  --   have ha : â†‘B = A{a,b} âˆ§ b.Finite âˆ§ a âŠ† b := hb.choose_spec
  --   obtain âŸ¨hâ‚, hâ‚‚, hâ‚ƒâŸ© := ha
  --   simp only [A_ab_mem_â„¬_b, and_self, hâ‚‚, hâ‚, hâ‚ƒ]
  Â· exact â„¬_b_mem_iff_exists.mp B.prop |>.choose_spec

-- theorem b_B_gen_B_b (hb : b.Finite) : b{âŸ¨B{b}, by simpâŸ©} âŠ† b := by
--   simp [b_B_gen]
--   split_ifs with h
--   Â· set b' := h.choose
--     set hb' : B{b} = B{b'} âˆ§ b'.Finite := h.choose_spec
--     obtain âŸ¨hâ‚, hâ‚‚âŸ© := hb'
--     sorry
--   all_goals simp at h; exact False.elim <| h b rfl hb


omit [Countable P] in
@[simp]
theorem b_B_Finite (B : â„¬{(Set.univ : Set H[P])}) : b{B}.Finite := b_B_gen_spec B |>.left
omit [Countable P] in
@[simp]
theorem B_mem_â„¬_b_B (B : â„¬{(Set.univ : Set H[P])}) : B.val âˆˆ â„¬{b{B}} := b_B_gen_spec B |>.right

-- def ğ’œ (B : â„¬{b}) (hb : b.Finite) : Set (Set H[P]) := â„¬_b_cover B.prop hb
-- def ğ’œ_spec (B : â„¬{b}) (hb : b.Finite) :
--     B.val = â‹ƒ a âˆˆ ğ’œ B hb, A{a,b} âˆ§
--     ((ğ’œ B hb).PairwiseDisjoint fun x â†¦ A{x,b}) âˆ§
--     (ğ’œ B hb).Finite âˆ§
--     (B.val.Nonempty â†” (ğ’œ B hb).Nonempty) âˆ§
--     âˆ€ a âˆˆ ğ’œ B hb, a âŠ† b
-- := â„¬_b_cover_spec B.prop hb
-- omit [Countable P] in
-- @[simp]
-- theorem ğ’œ_nonempty_iff (B : â„¬{b}) (hb : b.Finite) : (ğ’œ B hb).Nonempty â†” B.val.Nonempty :=
--   (ğ’œ_spec B hb).2.2.2.1.symm
-- omit [Countable P] in
-- @[simp]
-- theorem ğ’œ_empty_iff (B : â„¬{b}) (hb : b.Finite) : ğ’œ B hb = âˆ… â†” B.val = âˆ… :=
--   have := ğ’œ_nonempty_iff B hb |>.not
--   by simp_all [-ğ’œ_nonempty_iff, Set.not_nonempty_iff_eq_empty]

omit [Countable P] in
@[simp]
theorem middle_c_Finite (hb : b.Finite) (c : { c | a âŠ† c âˆ§ c âŠ† b }): c.val.Finite := by
  obtain âŸ¨c, hc, hc'âŸ© := c
  exact Set.Finite.subset hb hc'

noncomputable def IE (Î¼ : B_b_fin (P:=P) â†’ ENNReal) (a b : Set H[P]) (hb : b.Finite) : â„ :=
  âˆ‘' c : {c | a âŠ† c âˆ§ c âŠ† b},
    (-1 : â„)^(Nat.card â†‘(c.val \ a)) * (Î¼ âŸ¨B{c.val}, by use c; simp_allâŸ©).toReal

open scoped Classical in
noncomputable def wild (Î¼ : B_b_fin (P:=P) â†’ ENNReal) :
    (b : Set H[P]) â†’ b.Finite â†’ â„¬{b} â†’ ENNReal := fun b hb B â†¦
  âˆ‘' a : ğ’œ âŸ¨B, by simpâŸ© hb, ENNReal.ofReal (IE Î¼ a b hb)

open scoped Classical in
noncomputable def crazy (Î¼ : B_b_fin (P:=P) â†’ ENNReal) :
    â„¬{(Set.univ : Set H[P])} â†’ ENNReal := fun B â†¦
  wild Î¼ b{B} (b_B_Finite B) âŸ¨B, by simpâŸ©

omit [Countable P] in
theorem mah (hxb : x âˆ‰ b) (hab : a âŠ† b) : A{aâˆª{x},bâˆª{x}} âˆª A{a,bâˆª{x}} = A{a,b} := by
  ext y
  simp [A_ab]
  constructor
  Â· rintro (h | h)
    Â· ext z
      replace h := Set.ext_iff.mp h z
      simp_all
      constructor
      Â· intro hz
        simp_all only [Set.mem_insert_iff, or_true, Set.mem_inter_iff, true_iff, true_and]
        rcases h with âŸ¨h, h' | h'âŸ© <;> simp_all
        exact hxb (hab hz)
      Â· intro âŸ¨hzâ‚, hzâ‚‚âŸ©
        simp_all
        rcases h with h | h <;> simp_all
    Â· subst_eqs
      ext z
      simp_all only [Set.mem_inter_iff, Set.mem_insert_iff, and_congr_right_iff,
        or_iff_right_iff_imp, imp_false]
      rintro h' âŸ¨_âŸ©
      simp_all [(hxb <| hab Â·)]
  Â· rintro âŸ¨_âŸ©
    if hy : x âˆˆ y then exact .inl (Set.inter_insert_of_mem hy).symm
    else exact .inr (Set.inter_insert_of_notMem hy).symm

@[simp]
theorem ashjdas : B[s] âˆˆ â„¬{b} â†” s âˆˆ b := by
  constructor
  Â· intro h
    sorry
  Â· intro h
    exact B_h_mem_â„¬_b h

theorem B_mem_â„¬_b_has_lowerBound {bâ‚ bâ‚‚ : Set H[P]} (hbâ‚ : bâ‚.Finite) (hbâ‚‚ : bâ‚‚.Finite)
    (hBâ‚ : B âˆˆ â„¬{bâ‚}) (hBâ‚‚ : B âˆˆ â„¬{bâ‚‚}) : âˆƒ b', B âˆˆ â„¬{b'} âˆ§ b' âŠ† bâ‚ âˆ§ b' âŠ† bâ‚‚ := by
  have âŸ¨qâ‚, hâ‚, hâ‚_disjoint, hâ‚_finite, hâ‚_nonempty, hâ‚_subsetâŸ© := â„¬_b_exists_cover hBâ‚ hbâ‚
  have âŸ¨qâ‚‚, hâ‚‚, hâ‚‚_disjoint, hâ‚‚_finite, hâ‚‚_nonempty, hâ‚‚_subsetâŸ© := â„¬_b_exists_cover hBâ‚‚ hbâ‚‚
  subst_eqs
  simp_all
  -- simp_all [A_ab]
  use bâ‚ âˆ© bâ‚‚
  simp_all
  have := IsSetAlgebra.biUnion_mem (â„¬_b_IsSetAlgebra (b:=bâ‚âˆ©bâ‚‚)) hâ‚‚_finite.toFinset (s:=(A{Â·,bâ‚‚}))
  simp_all
  apply this
  intro i hiâ‚‚
  sorry


  -- induction hBâ‚ with
  -- | base s hs =>
  --   simp_all
  --   obtain âŸ¨s, hs, _, _âŸ© := hs
  --   use {s}
  --   simp_all
  -- | empty => simp_all; use âˆ…; simp
  -- | compl => simp_all
  -- | union s t hs ht ihs iht =>
  --   replace hs : s âˆˆ â„¬{bâ‚} := hs
  --   replace ht : t âˆˆ â„¬{bâ‚} := ht
  --   if hbâ‚â‚‚ : bâ‚ âŠ† bâ‚‚ then
  --     use bâ‚
  --     simp_all
  --     -- have := â„¬_b_mono hbâ‚â‚‚
  --     -- have âŸ¨bs, hs'âŸ© := ihs (this hs)
  --     -- have âŸ¨bt, ht'âŸ© := iht (this ht)
  --     -- use bs âˆª bt
  --     -- simp_all
  --     -- have := â„¬_b_mono (by simp_all : bs âˆª bt âŠ† bâ‚‚)
  --     -- sorry
  --   else
  --     contrapose hbâ‚â‚‚
  --     simp_all
  --     have := hbâ‚â‚‚ bâ‚ (by simp_all) (by rfl)
  --     simp_all
  --     sorry
  --   -- have := â„¬_b_mono
  --   -- have := ihs hbâ‚‚
  --   -- sorry

theorem dd :
      (ğ’œ âŸ¨â‹ƒ a âˆˆ ğ’œ âŸ¨B, hBâŸ© hb, A{a,b}, by rw [ğ’œ_covers âŸ¨B, hBâŸ© hb]; exact hBâŸ© hb)
    = â‹ƒ a âˆˆ ğ’œ âŸ¨B, hBâŸ© hb, A{a,b} := by
  -- have âŸ¨hâ‚, hâ‚‚, hâ‚ƒ, hâ‚„, hâ‚…âŸ© :=
  --   ğ’œ_spec âŸ¨â‹ƒ a âˆˆ ğ’œ âŸ¨B, hBâŸ© hb, A{a,b}, by rw [(ğ’œ_covers âŸ¨B, hBâŸ© hb).left]; exact hBâŸ© hb
  -- have âŸ¨pâ‚, pâ‚‚, pâ‚ƒ, pâ‚„, pâ‚…âŸ© := ğ’œ_spec âŸ¨B, hBâŸ© hb
  -- simp at *
  -- symm at hâ‚ pâ‚
  -- simp_all
  -- simp_all

  sorry

theorem wild_over_ğ’œ :
      wild Î¼ b hb âŸ¨â‹ƒ a âˆˆ ğ’œ âŸ¨B, hBâŸ© hb, A{a,b}, by rw [ğ’œ_covers âŸ¨B, hBâŸ© hb]; exact hBâŸ©
    = âˆ‘' a : ğ’œ âŸ¨B, hBâŸ© hb, wild Î¼ b hb âŸ¨A{a,b},
        A_ab_mem_â„¬_b hb (ğ’œ_spec âŸ¨B, hBâŸ© hb |>.right.right.right.right a a.prop)âŸ© := by
  simp [wild]
  sorry

theorem wild_same_on_b_subset {bâ‚ bâ‚‚ : Set H[P]} (hbâ‚‚ : bâ‚‚.Finite) (hbâ‚â‚‚ : bâ‚ âŠ† bâ‚‚) (hBâ‚ : B âˆˆ â„¬{bâ‚}) :
    wild Î¼ bâ‚ (Set.Finite.subset hbâ‚‚ hbâ‚â‚‚) âŸ¨B, hBâ‚âŸ© = wild Î¼ bâ‚‚ hbâ‚‚ âŸ¨B, â„¬_b_mono hbâ‚â‚‚ hBâ‚âŸ© := by
  have hbâ‚ : bâ‚.Finite := Set.Finite.subset hbâ‚‚ hbâ‚â‚‚
  have hBâ‚‚ : B âˆˆ â„¬{bâ‚‚} := â„¬_b_mono hbâ‚â‚‚ hBâ‚
  have hâ‚ := ğ’œ_covers âŸ¨B, hBâ‚âŸ© hbâ‚
  have hâ‚‚ := ğ’œ_covers âŸ¨B, hBâ‚‚âŸ© hbâ‚‚
  replace hâ‚ : (âŸ¨B, hBâ‚âŸ© : â„¬{bâ‚}) = âŸ¨â‹ƒ a âˆˆ ğ’œ âŸ¨B, hBâ‚âŸ© hbâ‚, A{a,bâ‚}, by rw [hâ‚]; exact hBâ‚âŸ© := by
    simp; exact hâ‚.symm
  replace hâ‚‚ : (âŸ¨B, hBâ‚‚âŸ© : â„¬{bâ‚‚}) = âŸ¨â‹ƒ a âˆˆ ğ’œ âŸ¨B, hBâ‚‚âŸ© hbâ‚‚, A{a,bâ‚‚}, by rw [hâ‚‚]; exact hBâ‚‚âŸ© := by
    simp; exact hâ‚‚.symm
  rw [hâ‚, hâ‚‚]; clear hâ‚ hâ‚‚


  -- simp only [ğ’œ_nonempty_iff, true_and] at *
  -- rw [ENNReal.tsum_biUnion'']

  sorry

theorem wild_same_on_b {bâ‚ bâ‚‚ : Set H[P]} (hbâ‚ : bâ‚.Finite) (hbâ‚‚ : bâ‚‚.Finite)
    (hBâ‚ : B âˆˆ â„¬{bâ‚}) (hBâ‚‚ : B âˆˆ â„¬{bâ‚‚}) : wild Î¼ bâ‚ hbâ‚ âŸ¨B, hBâ‚âŸ© = wild Î¼ bâ‚‚ hbâ‚‚ âŸ¨B, hBâ‚‚âŸ© := by
  obtain âŸ¨b, hBb, hâ‚, hâ‚‚âŸ© := B_mem_â„¬_b_has_lowerBound hbâ‚ hbâ‚‚ hBâ‚ hBâ‚‚
  rw [â† wild_same_on_b_subset hbâ‚ hâ‚ hBb]
  rw [â† wild_same_on_b_subset hbâ‚‚ hâ‚‚ hBb]

-- omit [Countable P] in
-- @[simp] theorem ğ’œ_empty : (ğ’œ âŸ¨(âˆ… : Set (Set H[P])), by simpâŸ©) = âˆ… := by simp_all

noncomputable instance ğ’œ_fintype : Fintype (ğ’œ B hb (P:=P)) := by
  refine Set.Finite.fintype ?_
  have âŸ¨hâ‚, hâ‚‚, hâ‚ƒ, hâ‚„âŸ© := ğ’œ_spec B hb
  exact hâ‚ƒ

noncomputable instance middle_c_Fintype (hb : b.Finite) : Fintype { c // a âŠ† c âˆ§ c âŠ† b } := by
  refine Set.fintypeOfFiniteUniv (Set.finite_univ_iff.mpr ?_)
  have hâ‚ƒ : { c | a âŠ† c âˆ§ c âŠ† b } âŠ† { c | c âŠ† b } := by simp
  exact Set.Finite.subset (Set.Finite.finite_subsets hb) hâ‚ƒ

noncomputable instance middle_c_Fintype' : Fintype { c // a âŠ† c âˆ§ c âŠ† b{B} } := by
  refine Set.fintypeOfFiniteUniv (Set.finite_univ_iff.mpr ?_)
  have hâ‚ƒ : { c | a âŠ† c âˆ§ c âŠ† b{B} } âŠ† { c | c âŠ† b{B} } := by simp
  exact Set.Finite.subset (Set.Finite.finite_subsets (b_B_Finite B)) hâ‚ƒ

-- example {a b : ENNReal} (h : a.toReal = b.toReal) : a = b := by
--   refine (ENNReal.toReal_eq_toReal_iff' ?_ ?_).mp h

-- open scoped Classical in
-- theorem ğ’œ_sUnion (I : Finset (Set (Set H[P]))) (hIsubset : I.toSet âŠ† â„¬{Set.univ})
--     (hIdisjoint : I.toSet.PairwiseDisjoint id) (hIunion : â‹ƒâ‚€ I.toSet âˆˆ â„¬{Set.univ}) :
--     ğ’œ âŸ¨â‹ƒâ‚€ I.toSet, hIunionâŸ© (b_B_Finite) = â‹ƒâ‚€ (I.attach.image (fun âŸ¨i, hiâŸ© â†¦ ğ’œ âŸ¨i, hIsubset hiâŸ©)) := by
--   have âŸ¨hâ‚, hâ‚‚, hâ‚ƒ, hâ‚„âŸ© := ğ’œ_spec âŸ¨â‹ƒâ‚€ I.toSet, hIunionâŸ©
--   simp at *
--   generalize hb : b{âŸ¨â‹ƒâ‚€ I.toSet, hIunionâŸ©} = b
--   simp [hb] at hâ‚ hâ‚‚ hâ‚ƒ hâ‚„
--   sorry

def bI (I : Finset (Set (Set H[P]))) (hIsubset : I.toSet âŠ† â„¬{Set.univ}) : Set H[P] :=
  â‹ƒ i : I, b{âŸ¨i.val, hIsubset i.propâŸ©}

notation "bI{" I "," hIsubset "}" => bI I hIsubset

omit [Countable P] in
theorem bI_finite (I : Finset (Set (Set H[P]))) (hI : I.toSet âŠ† â„¬{Set.univ}) : bI{I, hI}.Finite := by
  refine Set.finite_iUnion ?_
  exact fun i â†¦ b_B_Finite âŸ¨â†‘i, hI (Subtype.prop i)âŸ©

omit [Countable P] in
theorem bI_mem (I : Finset (Set (Set H[P]))) (hI : I.toSet âŠ† â„¬{Set.univ}) :
    âˆ€ i âˆˆ I, i âˆˆ â„¬{bI{I, hI}} := by
  intro i hi
  have âŸ¨hiâ‚, hiâ‚‚âŸ© := b_B_gen_spec âŸ¨i, hI hiâŸ©
  apply â„¬_b_mono _ hiâ‚‚
  intro x hx
  simp_all only [b_B_Finite, Set.mem_iUnion, Subtype.exists, bI]
  use i, hi

omit [Countable P] in
theorem bI_subset (I : Finset (Set (Set H[P]))) (hI : I.toSet âŠ† â„¬{Set.univ}) :
    I.toSet âŠ† â„¬{bI{I, hI}} := bI_mem I hI

omit [Countable P] in
theorem bI_mem' (I : Finset (Set (Set H[P]))) (hI : I.toSet âŠ† â„¬{Set.univ}) :
    â‹ƒâ‚€ I âˆˆ â„¬{bI{I, hI}} := by
  simp [Set.sUnion_eq_biUnion]
  exact IsSetAlgebra.biUnion_mem â„¬_b_IsSetAlgebra _ fun i hi â†¦
    â„¬_b_mono (fun _ h â†¦ by simp [bI]; exact BEx.intro i hi h) (b_B_gen_spec âŸ¨i, hI hiâŸ©).right

theorem ğ’œ_B_b {b : Set H[P]} (hb : b.Finite) : ğ’œ âŸ¨B{b}, by simpâŸ© hb = B{b} := by
  sorry
  -- have âŸ¨hâ‚, hâ‚‚, hâ‚ƒ, hâ‚„, hâ‚…âŸ© := ğ’œ_spec âŸ¨B{b}, by simpâŸ©
  -- symm at hâ‚
  -- ext x
  -- simp_all only [Set.mem_singleton_iff]
  -- constructor
  -- Â· intro h
  --   sorry
  -- Â· intro h
  --   have : A{b,b} = B{b} := by simp
  --   nth_rw 7 [â† this] at hâ‚
  --   sorry
    -- if B{b}.Nonempty then
    --   simp only [true_iff, *] at hâ‚„
    --   sorry
    -- if b = âˆ… then
    --   subst_eqs
    --   simp_all
    --   sorry
    -- else
    --   have : b.Nonempty := by (expose_names; exact Set.nonempty_iff_ne_empty.mpr h)
    --   obtain âŸ¨x, hxâŸ© := this

    --   sorry

theorem crazy_B_b {b : Set H[P]} (hb : b.Finite) :
    crazy Î¼ âŸ¨B{b}, by simpâŸ© = Î¼ âŸ¨B{b}, by use b; simp [hb]âŸ© := by
  simp [crazy]
  sorry
  -- rw [ğ’œ_B_b hb]
  -- rw [tsum_eq_single âŸ¨b, by simpâŸ© (by simp)]
  -- simp
  -- simp [IE]
  -- rw [tsum_eq_single âŸ¨b, by simp; sorryâŸ©]
  -- Â· simp
  -- Â· simp

theorem tsum_subtype_eq [AddCommMonoid Î²] [TopologicalSpace Î²] (A B : Set Î±) (h : A = B) (f : A â†’ Î²) :
    âˆ‘' a : A, f a = âˆ‘' b : B, f âŸ¨b.val, by simp_allâŸ© := by
  subst_eqs
  rfl

theorem IE_indep_of_b (Î¼ : B_b_fin (P:=P) â†’ ENNReal) (a bâ‚ bâ‚‚ : Set H[P])
    (hbâ‚ : bâ‚.Finite) (hbâ‚‚ : bâ‚‚.Finite) : -- (habâ‚ : a âŠ† bâ‚) (habâ‚‚ : a âŠ† bâ‚‚) :
    IE Î¼ a bâ‚ hbâ‚ = IE Î¼ a bâ‚‚ hbâ‚‚ := by
  letI := middle_c_Fintype (a:=a) hbâ‚
  letI := middle_c_Fintype (a:=a) hbâ‚‚
  simp [IE, tsum_fintype]
  sorry

def condition (Î¼ : B_b_fin (P:=P) â†’ ENNReal) : Prop :=
  âˆ€ a b, âˆ€ h : b.Finite, 0 â‰¤ IE Î¼ a b h

set_option maxHeartbeats 500000 in
open scoped Classical in
noncomputable def crazyAddContent' (Î¼ : B_b_fin (P:=P) â†’ ENNReal) (hÎ¼ : condition Î¼) :
    AddContent â„¬{(Set.univ : Set H[P])} where
  toFun B := if hB : B âˆˆ â„¬{Set.univ} then crazy Î¼ âŸ¨B, hBâŸ© else 0
  empty' := by simp [crazy, wild]
  sUnion' := by
    clear a b
    intro I hIsubset hIdisjoint hIunion
    have bIfinite := bI_finite I hIsubset
    have bIsubset := bI_subset I hIsubset
    have bIunion := bI_mem' I hIsubset
    simp_all only [dite_true]
    simp [Set.sUnion_eq_biUnion]
    simp_all only [crazy, dite_true]
    sorry

set_option maxHeartbeats 500000 in
open scoped Classical in
noncomputable def crazyAddContent (Î¼ : B_b_fin (P:=P) â†’ ENNReal) (hÎ¼ : condition Î¼) :
    AddContent â„¬{(Set.univ : Set H[P])} where
  toFun B := if hB : B âˆˆ â„¬{Set.univ} then crazy Î¼ âŸ¨B, hBâŸ© else 0
  empty' := by simp [crazy, wild]
  sUnion' := by
    sorry
    -- intro I hIsubset hIdisjoint hIunion
    -- simp_all only [crazy, Set.coe_setOf, Set.mem_setOf_eq, dite_true]
    -- have := ğ’œ_sUnion I hIsubset hIdisjoint hIunion
    -- simp_all only [Finset.coe_image, Finset.coe_attach, Set.image_univ, Set.sUnion_range]
    -- rw [tsum_subtype_eq _ _ this]
    -- apply (ENNReal.toReal_eq_toReal_iff' ?_ ?_).mp
    -- Â· rw [ENNReal.toReal_sum]
    --   Â· rw [tsum_fintype]
    --     rw [ENNReal.ofReal_sum_of_nonneg]
    --     Â· rw [â† tsum_fintype]
    --       rw [ENNReal.tsum_biUnion'' ?_]
    --       Â· simp only [tsum_fintype, Finset.univ_eq_attach]
    --         rw [ENNReal.toReal_sum]
    --         Â· simp only [Finset.mem_univ, ne_eq, ENNReal.ofReal_ne_top, not_false_eq_true, imp_self,
    --           implies_true, ENNReal.toReal_sum]
    --           apply Finset.sum_bij_ne_zero (fun âŸ¨x, _âŸ© _ _ â†¦ x)
    --           Â· simp only [Finset.mem_attach, ne_eq, Finset.coe_mem, implies_true, imp_self]
    --           Â· simp only [Finset.mem_attach, ne_eq, forall_const, Subtype.forall, Subtype.mk.injEq,
    --             imp_self, implies_true]
    --           Â· intro i hi
    --             simp only [hIsubset hi, â†“reduceDIte, ne_eq, exists_prop, Finset.mem_attach,
    --               exists_const, Subtype.exists, exists_and_right, exists_eq_right]
    --             intro h
    --             use i, hi
    --             simp only [and_true, true_and]
    --             rw [ENNReal.ofReal_sum_of_nonneg] at h
    --             Â· rw [ENNReal.toReal_sum] at h
    --               Â· contrapose! h
    --                 rw [â† h]; clear h
    --                 simp only [hÎ¼ _, ENNReal.toReal_ofReal]
    --                 congr with a
    --                 apply IE_indep_of_b
    --               Â· simp only [Finset.mem_univ, ne_eq, ENNReal.ofReal_ne_top, not_false_eq_true,
    --                 imp_self, implies_true]
    --             Â· simp only [Finset.mem_univ, forall_const, Subtype.forall]
    --               intro a ha
    --               exact hÎ¼ a b{âŸ¨i, hIsubset hiâŸ©} (b_B_Finite âŸ¨i, hIsubset hiâŸ©)
    --           Â· intro âŸ¨i, hiâŸ© ha' h
    --             simp only [ne_eq, hIsubset hi, â†“reduceDIte]
    --             rw [ENNReal.ofReal_sum_of_nonneg, ENNReal.toReal_sum]
    --             Â· simp only [hÎ¼ _, ENNReal.toReal_ofReal]
    --               congr with a
    --               apply IE_indep_of_b
    --             Â· simp only [Finset.mem_univ, ne_eq, ENNReal.ofReal_ne_top, not_false_eq_true,
    --               imp_self, implies_true]
    --             Â· simp only [Finset.mem_univ, forall_const, Subtype.forall]
    --               intro a ha
    --               exact hÎ¼ a b{âŸ¨i, hIsubset hiâŸ©} (b_B_Finite âŸ¨i, hIsubset hiâŸ©)
    --         Â· simp only [Finset.mem_attach, ne_eq, ENNReal.sum_eq_top, Finset.mem_univ,
    --           ENNReal.ofReal_ne_top, and_false, exists_false, not_false_eq_true, imp_self,
    --           implies_true]
    --       Â· intro x _ y _ hq s hsx hsy o ho
    --         simp_all only [Set.mem_univ, ne_eq, Set.le_eq_subset, Set.bot_eq_empty,
    --           Set.mem_empty_iff_false]
    --         contrapose! hq
    --         simp_all only [not_false_eq_true]
    --         have hox := hsx ho
    --         have hoy := hsy ho
    --         sorry
    --     Â· simp only [Finset.mem_univ, forall_const, Subtype.forall, Set.mem_iUnion, Subtype.exists,
    --       forall_exists_index]
    --       intro a i hi ha
    --       have := hÎ¼ a b{âŸ¨â‹ƒâ‚€ I.toSet, hIunionâŸ©} (b_B_Finite âŸ¨â‹ƒâ‚€ I.toSet, hIunionâŸ©)
    --       exact this
    --   Â· intros; split_ifs <;> simp
    -- Â· simp only [ne_eq, ENNReal.ofReal_ne_top, not_false_eq_true]
    -- Â· simp only [ne_eq, ENNReal.sum_eq_top, not_exists, not_and]; intros; split_ifs <;> simp




open scoped Classical in
noncomputable def the_thing (hb : b.Finite) (hab : a âŠ† b) (p : â„• â†’ Prop) :=
  letI : Fintype â†‘b := hb.fintype
  letI : Fintype â†‘a := b.fintypeSubset hab
  let aCard := a.toFinset.card
  Finset.nepowerset b.toFinset
    |>.filter (fun (c : Finset H[P]) â†¦ a âŠ† c.toSet âˆ§ p (c.val.card - aCard))

open scoped Classical in
/--
Extends a function from `{B{b} | b.Finite} â†’ ENNReal` to `{A{a,b} | a âŠ† b âˆ§ b.Finite} â†’ ENNReal`.
-/
noncomputable def extend_B_b_fin (Î¼ : B_b_fin (P:=P) â†’ ENNReal) :
    {(a, b) : Set H[P] Ã— Set H[P] | a âŠ† b âˆ§ b.Finite} â†’ ENNReal :=
  fun âŸ¨âŸ¨a, bâŸ©, hâŸ© â†¦
    letI : Fintype â†‘b := h.right.fintype
    letI : Fintype â†‘a := b.fintypeSubset h.left
    let aCard := a.toFinset.card
    (âˆ‘ c : the_thing h.right h.left Odd, Î¼ âŸ¨B{c.val}, by use c; simp_allâŸ©)
    - (âˆ‘ c : the_thing h.right h.left Even, Î¼ âŸ¨B{c.val}, by use c; simp_allâŸ©)

-- noncomputable def extend_B_b_fin (Î¼ : B_b_fin (P:=P) â†’ ENNReal) :
--     ((fun âŸ¨a, bâŸ© â†¦ A{a,b}) '' {(a, b) : Set H[P] Ã— Set H[P] | a âŠ† b âˆ§ b.Finite}) â†’ ENNReal :=
--   fun âŸ¨A, hâŸ© â†¦ by
--     simp_all

--     letI : Fintype â†‘b := h.right.fintype
--     letI : Fintype â†‘a := b.fintypeSubset h.left
--     let aCard := a.toFinset.card
--     (âˆ‘ c : the_thing h.right h.left Odd, Î¼ âŸ¨B{c.val}, by use c; simp_allâŸ©)
--     - (âˆ‘ c : the_thing h.right h.left Even, Î¼ âŸ¨B{c.val}, by use c; simp_allâŸ©)


theorem ahsjdjas (hb : b.Finite) (hX : X âˆˆ B{b}) :
    extend_B_b_fin Î¼ âŸ¨(b, b), by simp [hb]âŸ© = Î¼ âŸ¨B{b}, by simp [B_b_fin]; use bâŸ© := by
  simp [extend_B_b_fin]
  if b = âˆ… then
    subst_eqs
    simp_all
    sorry
  else
    sorry
    -- rw [Finset.sum_eq_single âŸ¨hb.toFinset, by simp_allâŸ©]
    -- Â· simp
    --   rw [Finset.sum_eq_zero]
    --   Â· simp
    --   Â· simp
    --     intro a âŸ¨ha, ha'âŸ© ha''
    --     have : a = b := Set.Subset.antisymm ha ha''
    --     subst_eqs
    --     simp_all

    --     sorry
    -- Â· simp
    --   sorry
    -- Â· simp
    --   sorry

/--
Extends a function from `{A{a,b} | a âŠ† b âˆ§ b.Finite} â†’ ENNReal` to `{B | B âˆˆ â„¬{b} âˆ§ b.Finite} â†’
ENNReal`.
-/
noncomputable def extend_A_ab (Î¼ : {(a, b) : Set H[P] Ã— Set H[P] | a âŠ† b âˆ§ b.Finite} â†’ ENNReal) :
    {(b, B) : Set H[P] Ã— Set (Set H[P]) | B âˆˆ â„¬{b} âˆ§ b.Finite} â†’ ENNReal :=
  fun âŸ¨âŸ¨b, BâŸ©, hâŸ© â†¦
    âˆ‘' a : ğ’œ âŸ¨B, h.leftâŸ© h.right, Î¼ âŸ¨âŸ¨a, bâŸ©, by
      obtain âŸ¨a, haâŸ© := a
      have := ğ’œ_spec âŸ¨B, h.leftâŸ© h.right
      have := h.right
      simp_allâŸ©

/--
Extends a function from `{B | B âˆˆ â„¬{b} âˆ§ b.Finite} â†’ ENNReal` to `{B : Set (Set H[P]) | B âˆˆ
â„¬{Set.univ}} â†’ ENNReal`.
-/
noncomputable def extend_B (Î¼ : {(b, B) : Set H[P] Ã— Set (Set H[P]) | B âˆˆ â„¬{b} âˆ§ b.Finite} â†’ ENNReal) :
    {B : Set (Set H[P]) | B âˆˆ â„¬{Set.univ}} â†’ ENNReal :=
  fun âŸ¨B, hâŸ© â†¦ Î¼ âŸ¨âŸ¨â„¬_b_gen h, BâŸ©, by simp [â„¬_b_gen_spec h]âŸ©

open scoped Classical in
noncomputable def extend_AddContent (Î¼ : B_b_fin (P:=P) â†’ ENNReal) :
    AddContent â„¬{(Set.univ : Set H[P])} where
  toFun := fun B â†¦
    if hB : B âˆˆ â„¬{Set.univ} then (Î¼ |> extend_B_b_fin |> extend_A_ab |> extend_B) âŸ¨B, hBâŸ© else 0
  empty' := by
    simp [extend_B_b_fin, extend_A_ab, extend_B]
  sUnion' := by
    simp_all only [extend_B, extend_A_ab, extend_B_b_fin, Finset.univ_eq_attach, dite_true]
    sorry

open scoped Classical in
noncomputable def extend_AddContent' (Î¼ : Set (Set H[P]) â†’ ENNReal) :
    AddContent â„¬{(Set.univ : Set H[P])} :=
  let Î¼' : B_b_fin (P:=P) â†’ ENNReal := fun B â†¦ Î¼ B.val
  {
  toFun := fun B â†¦
    if hB : B âˆˆ â„¬{Set.univ} then (Î¼' |> extend_B_b_fin |> extend_A_ab |> extend_B) âŸ¨B, hBâŸ© else 0
  empty' := by
    simp_all only [â„¬_b_mem_empty, extend_B, extend_A_ab, extend_B_b_fin, Finset.univ_eq_attach,
      dite_true, ENNReal.tsum_eq_zero, Subtype.forall, Î¼']
    sorry
  sUnion' := by
    simp_all [extend_B, extend_A_ab, extend_B_b_fin, Finset.univ_eq_attach, dite_true, Î¼']
    intro I hIsub hIdis hIunion
    sorry
  }

theorem extend_AddContent_IsSigmaSubadditive : (extend_AddContent (P:=P) Î¼).IsSigmaSubadditive := by
  refine isSigmaSubadditive_of_addContent_iUnion_eq_tsum â„¬_b_IsSetRing ?_
  intro f hf hfU hfDis
  simp_all [extend_AddContent, DFunLike.coe]
  sorry

open scoped Classical in
def extend_measure_requirement (Î¼ : B_b_fin (P:=P) â†’ ENNReal) : Prop :=
  âˆ€ {a b : Set H[P]} (hab : a âŠ† b) (h : B{b} âˆˆ B_b_fin (P:=P) âˆ§ b.Finite),
  let h : Fintype â†‘b := h.right.fintype
  (âˆ‘ c : Finset.nepowerset b.toFinset with a âŠ† c.val.toSet âˆ§ Even c.val.card,
    Î¼ âŸ¨B{c.val}, by use c; simp_allâŸ©) â‰¤
  (âˆ‘ c : Finset.nepowerset b.toFinset with a âŠ† c.val.toSet âˆ§ Odd c.val.card,
    Î¼ âŸ¨B{c.val}, by use c; simp_allâŸ©)

/--
Extends a function from `{B | B âˆˆ â„¬{Set.univ}} â†’ ENNReal` to measure on `â„¬`.
-/
noncomputable def extend_measure (Î¼ : B_b_fin (P:=P) â†’ ENNReal) (h : extend_measure_requirement Î¼) :
    Measure[â„¬.borel] (Set H[P])  :=
  @AddContent.measure _ _ â„¬.borel (extend_AddContent Î¼) â„¬_b_IsSetSemiring
    â„¬_borel_le_generateFrom extend_AddContent_IsSigmaSubadditive

end ProbNetKAT
