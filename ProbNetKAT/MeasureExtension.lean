import Mathlib.MeasureTheory.OuterMeasure.OfAddContent
import ProbNetKAT.Cantor
import ProbNetKAT.MathlibExt
import ProbNetKAT.AtomCover
import MDP.ENNRealExt

/-!

# Measure extension

Formulation of **Theorem 1** stating that:

> A function `μ : { B{b} | b.Finite } → [0,1]` extends to a measure `μ : ℬ → [0,1]` under certain
> conditions.

The final definition realizing this theorem is `extend_measure`.

The general outline of the proof of this theorem is as follows:
- TODO: this is _Carathéodory's extension theorem_ on `B ∈ ℬ{Set.univ}` to get `B ∈ ℬ`
- First determining a finite `b` s.t. any `B ∈ ℬ{Set.univ}` becomes a `B ∈ ℬ{b}`. TODO: fix for any
  B there exits a b
  - The `b` is given by `ProbNetKAT.ℬ_b_mem_iff_exists`.
  - The extension here is done by _Carathéodory's extension theorem_, given by
    `MeasureTheory.AddContent.measure`.
- The measure `μ B` of any such `B ∈ ℬ{b}` can be written as the **finite disjoint union of atoms**
  (see `ProbNetKAT.ℬ_b_exists_cover`), giving us `∑ a, μ A{a,b}`.
- The measure `μ A{a,b}` can be further decomposed using _inclusion-exclusion_ (see
  `MeasureTheory.ennreal_inclusion_exclusion`). This then becomes a sum over `B{b}` by
  `ProbNetKAT.B_b_union_eq_inter`.

Connecting the steps defines a new measure on `ℬ` defined only on `B{b}` for finite `b`.
-/

/-!

## Secondary outline

We are given $μ$ defined on $B\{b\}$ for $b$ finite.

$$μ(B\{b\}) = \text{given}$$

Using _inclusion-exclusion_ we can lift this definition to $A\{a,b\}$.

$$μ(A\{a,b\}) = \sum_{a ⊆ c ⊆ b} (-1)^{|c \setminus a|} μ(B\{c\})$$

We know that every $B ∈ ℬ\{b\}$ is the disjoint union of a finite set of atoms.

$$μ(B ∈ ℬ\{b\}) = \sum_{a ∈ 𝒜(B)} μ(A\{a,b\})$$

We know that every $B ∈ ℬ\{2^H\}$ there exists a finite $b$ such that $B ∈ ℬ\{b\}$.

$$μ(B ∈ ℬ\{2^H\}) = μ(B ∈ ℬ\{b\})$$

By _Carathéodory's extension theorem_ we can extend to the measurable sets.

$$μ(B ∈ ℬ) = μ(B ∈ ℬ\{2^H\})$$

-/

/-!

## Unrolled definition

Let $b_B$ denote the finite $b$ such that $B ∈ ℬ\{b\}$ where originally $B ∈ ℬ\{2^H\}$.

Let $𝒜(B ∈ ℬ\{2^H\})$ denote the finite cover of disjoint atoms such that $B = \bigcup_{a ∈ 𝒜(B)}
A\{a,b_B\}$.

$$
\begin{aligned} μ(B ∈ ℬ\{2^H\}) &= μ(B ∈ ℬ\{b_B\}) \\\\
&= \sum_{a ∈ 𝒜(B)} μ(A\{a, b_B\}) \\\\
&= \sum_{a ∈ 𝒜(B)} \sum_{a ⊆ c ⊆ b_B} (-1)^{|c \setminus a|}μ(B\{c\}) \\\\
\end{aligned}
$$

-/

set_option grind.warning false

namespace ProbNetKAT

open Topology MeasureTheory

variable {P : Type} [Countable P]

/-- The set of all `B{b}` generated by `b` finite. -/
def B_b_fin : Set (Set (Set H[P])) := ((B{·}) '' {b : Set H[P] | b.Finite})

variable {a b : Set H[P]}

-- inductive Thingy : Set (Set H[P]) → Set (Set (Set (Set H[P]))) where
--   | base (b : Set H[P]) (hb : b.Finite) : Thingy B{b} {B{b}}
--   | Aab (a b) (hab : a ⊆ b) (hb : b.Finite) : Thingy A{a,b}
--   -- | B_b (b) (hb : b.Finite) (B) (hB : B ∈ ℬ{b}) : Thingy B
--   -- | B (hB : B ∈ ℬ{Set.univ}) : Thingy B

abbrev SetOf (T : Type) : Set T := Set.univ

notation "₂" H => SetOf H

example : x ∈ ₂H[P] := by
  simp

def join (S : Set (Set (Set H[P]))) : Set (Set H[P]) := ⋃₀ S

def ℬ_b_gen {B : Set (Set H[P])} (hB : B ∈ ℬ{Set.univ}) : Set H[P] :=
  ℬ_b_mem_iff_exists.mp hB |>.choose
def ℬ_b_gen_spec {B : Set (Set H[P])} (hB : B ∈ ℬ{Set.univ}) :
    (ℬ_b_gen hB).Finite ∧ B ∈ ℬ{ℬ_b_gen hB} := ℬ_b_mem_iff_exists.mp hB |>.choose_spec

@[simp] theorem B_b_mem_ℬ_b : B{b} ∈ ℬ{b} := sorry
@[simp] theorem B_b_mem_ℬ_b_univ : B{b} ∈ ℬ{Set.univ} := sorry

-- open scoped Classical in
def b_B_gen (B : ℬ{₂H[P]}) : Set H[P] :=
  -- if h : ∃ b : Set H, B = B{b} ∧ b.Finite then h.choose else
  -- if h : ∃ b a : Set H, B = A{a,b} ∧ b.Finite ∧ a ⊆ b then h.choose else
  ℬ_b_mem_iff_exists.mp B.prop |>.choose

notation "b{" B "}" => b_B_gen B

def b_B_gen_spec (B : ℬ{₂H[P]}) :
    b{B}.Finite ∧ B.val ∈ ℬ{b{B}} := by
  -- simp [b_B_gen]
  -- split_ifs with h h
  -- · set b := h.choose
  --   have hb : B = B{b} ∧ b.Finite := h.choose_spec
  --   simp_all
  -- · set b := h.choose
  --   have hb : ∃ a, ↑B = A{a,b} ∧ b.Finite ∧ a ⊆ b := h.choose_spec
  --   set a := hb.choose
  --   have ha : ↑B = A{a,b} ∧ b.Finite ∧ a ⊆ b := hb.choose_spec
  --   obtain ⟨h₁, h₂, h₃⟩ := ha
  --   simp only [A_ab_mem_ℬ_b, and_self, h₂, h₁, h₃]
  · exact ℬ_b_mem_iff_exists.mp B.prop |>.choose_spec

-- theorem b_B_gen_B_b (hb : b.Finite) : b{⟨B{b}, by simp⟩} ⊆ b := by
--   simp [b_B_gen]
--   split_ifs with h
--   · set b' := h.choose
--     set hb' : B{b} = B{b'} ∧ b'.Finite := h.choose_spec
--     obtain ⟨h₁, h₂⟩ := hb'
--     sorry
--   all_goals simp at h; exact False.elim <| h b rfl hb


omit [Countable P] in
@[simp]
theorem b_B_Finite (B : ℬ{(Set.univ : Set H[P])}) : b{B}.Finite := b_B_gen_spec B |>.left
omit [Countable P] in
@[simp]
theorem B_mem_ℬ_b_B (B : ℬ{(Set.univ : Set H[P])}) : B.val ∈ ℬ{b{B}} := b_B_gen_spec B |>.right

-- def 𝒜 (B : ℬ{b}) (hb : b.Finite) : Set (Set H[P]) := ℬ_b_cover B.prop hb
-- def 𝒜_spec (B : ℬ{b}) (hb : b.Finite) :
--     B.val = ⋃ a ∈ 𝒜 B hb, A{a,b} ∧
--     ((𝒜 B hb).PairwiseDisjoint fun x ↦ A{x,b}) ∧
--     (𝒜 B hb).Finite ∧
--     (B.val.Nonempty ↔ (𝒜 B hb).Nonempty) ∧
--     ∀ a ∈ 𝒜 B hb, a ⊆ b
-- := ℬ_b_cover_spec B.prop hb
-- omit [Countable P] in
-- @[simp]
-- theorem 𝒜_nonempty_iff (B : ℬ{b}) (hb : b.Finite) : (𝒜 B hb).Nonempty ↔ B.val.Nonempty :=
--   (𝒜_spec B hb).2.2.2.1.symm
-- omit [Countable P] in
-- @[simp]
-- theorem 𝒜_empty_iff (B : ℬ{b}) (hb : b.Finite) : 𝒜 B hb = ∅ ↔ B.val = ∅ :=
--   have := 𝒜_nonempty_iff B hb |>.not
--   by simp_all [-𝒜_nonempty_iff, Set.not_nonempty_iff_eq_empty]

omit [Countable P] in
@[simp]
theorem middle_c_Finite (hb : b.Finite) (c : { c | a ⊆ c ∧ c ⊆ b }): c.val.Finite := by
  obtain ⟨c, hc, hc'⟩ := c
  exact Set.Finite.subset hb hc'

noncomputable def IE (μ : B_b_fin (P:=P) → ENNReal) (a b : Set H[P]) (hb : b.Finite) : ℝ :=
  ∑' c : {c | a ⊆ c ∧ c ⊆ b},
    (-1 : ℝ)^(Nat.card ↑(c.val \ a)) * (μ ⟨B{c.val}, by use c; simp_all⟩).toReal

open scoped Classical in
noncomputable def wild (μ : B_b_fin (P:=P) → ENNReal) :
    (b : Set H[P]) → b.Finite → ℬ{b} → ENNReal := fun b hb B ↦
  ∑' a : 𝒜 ⟨B, by simp⟩ hb, ENNReal.ofReal (IE μ a b hb)

open scoped Classical in
noncomputable def crazy (μ : B_b_fin (P:=P) → ENNReal) :
    ℬ{(Set.univ : Set H[P])} → ENNReal := fun B ↦
  wild μ b{B} (b_B_Finite B) ⟨B, by simp⟩

omit [Countable P] in
theorem mah (hxb : x ∉ b) (hab : a ⊆ b) : A{a∪{x},b∪{x}} ∪ A{a,b∪{x}} = A{a,b} := by
  ext y
  simp [A_ab]
  constructor
  · rintro (h | h)
    · ext z
      replace h := Set.ext_iff.mp h z
      simp_all
      constructor
      · intro hz
        simp_all only [Set.mem_insert_iff, or_true, Set.mem_inter_iff, true_iff, true_and]
        rcases h with ⟨h, h' | h'⟩ <;> simp_all
        exact hxb (hab hz)
      · intro ⟨hz₁, hz₂⟩
        simp_all
        rcases h with h | h <;> simp_all
    · subst_eqs
      ext z
      simp_all only [Set.mem_inter_iff, Set.mem_insert_iff, and_congr_right_iff,
        or_iff_right_iff_imp, imp_false]
      rintro h' ⟨_⟩
      simp_all [(hxb <| hab ·)]
  · rintro ⟨_⟩
    if hy : x ∈ y then exact .inl (Set.inter_insert_of_mem hy).symm
    else exact .inr (Set.inter_insert_of_notMem hy).symm

@[simp]
theorem ashjdas : B[s] ∈ ℬ{b} ↔ s ∈ b := by
  constructor
  · intro h
    sorry
  · intro h
    exact B_h_mem_ℬ_b h

theorem B_mem_ℬ_b_has_lowerBound {b₁ b₂ : Set H[P]} (hb₁ : b₁.Finite) (hb₂ : b₂.Finite)
    (hB₁ : B ∈ ℬ{b₁}) (hB₂ : B ∈ ℬ{b₂}) : ∃ b', B ∈ ℬ{b'} ∧ b' ⊆ b₁ ∧ b' ⊆ b₂ := by
  have ⟨q₁, h₁, h₁_disjoint, h₁_finite, h₁_nonempty, h₁_subset⟩ := ℬ_b_exists_cover hB₁ hb₁
  have ⟨q₂, h₂, h₂_disjoint, h₂_finite, h₂_nonempty, h₂_subset⟩ := ℬ_b_exists_cover hB₂ hb₂
  subst_eqs
  simp_all
  -- simp_all [A_ab]
  use b₁ ∩ b₂
  simp_all
  have := IsSetAlgebra.biUnion_mem (ℬ_b_IsSetAlgebra (b:=b₁∩b₂)) h₂_finite.toFinset (s:=(A{·,b₂}))
  simp_all
  apply this
  intro i hi₂
  sorry


  -- induction hB₁ with
  -- | base s hs =>
  --   simp_all
  --   obtain ⟨s, hs, _, _⟩ := hs
  --   use {s}
  --   simp_all
  -- | empty => simp_all; use ∅; simp
  -- | compl => simp_all
  -- | union s t hs ht ihs iht =>
  --   replace hs : s ∈ ℬ{b₁} := hs
  --   replace ht : t ∈ ℬ{b₁} := ht
  --   if hb₁₂ : b₁ ⊆ b₂ then
  --     use b₁
  --     simp_all
  --     -- have := ℬ_b_mono hb₁₂
  --     -- have ⟨bs, hs'⟩ := ihs (this hs)
  --     -- have ⟨bt, ht'⟩ := iht (this ht)
  --     -- use bs ∪ bt
  --     -- simp_all
  --     -- have := ℬ_b_mono (by simp_all : bs ∪ bt ⊆ b₂)
  --     -- sorry
  --   else
  --     contrapose hb₁₂
  --     simp_all
  --     have := hb₁₂ b₁ (by simp_all) (by rfl)
  --     simp_all
  --     sorry
  --   -- have := ℬ_b_mono
  --   -- have := ihs hb₂
  --   -- sorry

theorem dd :
      (𝒜 ⟨⋃ a ∈ 𝒜 ⟨B, hB⟩ hb, A{a,b}, by rw [𝒜_covers ⟨B, hB⟩ hb]; exact hB⟩ hb)
    = ⋃ a ∈ 𝒜 ⟨B, hB⟩ hb, A{a,b} := by
  -- have ⟨h₁, h₂, h₃, h₄, h₅⟩ :=
  --   𝒜_spec ⟨⋃ a ∈ 𝒜 ⟨B, hB⟩ hb, A{a,b}, by rw [(𝒜_covers ⟨B, hB⟩ hb).left]; exact hB⟩ hb
  -- have ⟨p₁, p₂, p₃, p₄, p₅⟩ := 𝒜_spec ⟨B, hB⟩ hb
  -- simp at *
  -- symm at h₁ p₁
  -- simp_all
  -- simp_all

  sorry

theorem wild_over_𝒜 :
      wild μ b hb ⟨⋃ a ∈ 𝒜 ⟨B, hB⟩ hb, A{a,b}, by rw [𝒜_covers ⟨B, hB⟩ hb]; exact hB⟩
    = ∑' a : 𝒜 ⟨B, hB⟩ hb, wild μ b hb ⟨A{a,b},
        A_ab_mem_ℬ_b hb (𝒜_spec ⟨B, hB⟩ hb |>.right.right.right.right a a.prop)⟩ := by
  simp [wild]
  sorry

theorem wild_same_on_b_subset {b₁ b₂ : Set H[P]} (hb₂ : b₂.Finite) (hb₁₂ : b₁ ⊆ b₂) (hB₁ : B ∈ ℬ{b₁}) :
    wild μ b₁ (Set.Finite.subset hb₂ hb₁₂) ⟨B, hB₁⟩ = wild μ b₂ hb₂ ⟨B, ℬ_b_mono hb₁₂ hB₁⟩ := by
  have hb₁ : b₁.Finite := Set.Finite.subset hb₂ hb₁₂
  have hB₂ : B ∈ ℬ{b₂} := ℬ_b_mono hb₁₂ hB₁
  have h₁ := 𝒜_covers ⟨B, hB₁⟩ hb₁
  have h₂ := 𝒜_covers ⟨B, hB₂⟩ hb₂
  replace h₁ : (⟨B, hB₁⟩ : ℬ{b₁}) = ⟨⋃ a ∈ 𝒜 ⟨B, hB₁⟩ hb₁, A{a,b₁}, by rw [h₁]; exact hB₁⟩ := by
    simp; exact h₁.symm
  replace h₂ : (⟨B, hB₂⟩ : ℬ{b₂}) = ⟨⋃ a ∈ 𝒜 ⟨B, hB₂⟩ hb₂, A{a,b₂}, by rw [h₂]; exact hB₂⟩ := by
    simp; exact h₂.symm
  rw [h₁, h₂]; clear h₁ h₂


  -- simp only [𝒜_nonempty_iff, true_and] at *
  -- rw [ENNReal.tsum_biUnion'']

  sorry

theorem wild_same_on_b {b₁ b₂ : Set H[P]} (hb₁ : b₁.Finite) (hb₂ : b₂.Finite)
    (hB₁ : B ∈ ℬ{b₁}) (hB₂ : B ∈ ℬ{b₂}) : wild μ b₁ hb₁ ⟨B, hB₁⟩ = wild μ b₂ hb₂ ⟨B, hB₂⟩ := by
  obtain ⟨b, hBb, h₁, h₂⟩ := B_mem_ℬ_b_has_lowerBound hb₁ hb₂ hB₁ hB₂
  rw [← wild_same_on_b_subset hb₁ h₁ hBb]
  rw [← wild_same_on_b_subset hb₂ h₂ hBb]

-- omit [Countable P] in
-- @[simp] theorem 𝒜_empty : (𝒜 ⟨(∅ : Set (Set H[P])), by simp⟩) = ∅ := by simp_all

noncomputable instance 𝒜_fintype : Fintype (𝒜 B hb (P:=P)) := by
  refine Set.Finite.fintype ?_
  have ⟨h₁, h₂, h₃, h₄⟩ := 𝒜_spec B hb
  exact h₃

noncomputable instance middle_c_Fintype (hb : b.Finite) : Fintype { c // a ⊆ c ∧ c ⊆ b } := by
  refine Set.fintypeOfFiniteUniv (Set.finite_univ_iff.mpr ?_)
  have h₃ : { c | a ⊆ c ∧ c ⊆ b } ⊆ { c | c ⊆ b } := by simp
  exact Set.Finite.subset (Set.Finite.finite_subsets hb) h₃

noncomputable instance middle_c_Fintype' : Fintype { c // a ⊆ c ∧ c ⊆ b{B} } := by
  refine Set.fintypeOfFiniteUniv (Set.finite_univ_iff.mpr ?_)
  have h₃ : { c | a ⊆ c ∧ c ⊆ b{B} } ⊆ { c | c ⊆ b{B} } := by simp
  exact Set.Finite.subset (Set.Finite.finite_subsets (b_B_Finite B)) h₃

-- example {a b : ENNReal} (h : a.toReal = b.toReal) : a = b := by
--   refine (ENNReal.toReal_eq_toReal_iff' ?_ ?_).mp h

-- open scoped Classical in
-- theorem 𝒜_sUnion (I : Finset (Set (Set H[P]))) (hIsubset : I.toSet ⊆ ℬ{Set.univ})
--     (hIdisjoint : I.toSet.PairwiseDisjoint id) (hIunion : ⋃₀ I.toSet ∈ ℬ{Set.univ}) :
--     𝒜 ⟨⋃₀ I.toSet, hIunion⟩ (b_B_Finite) = ⋃₀ (I.attach.image (fun ⟨i, hi⟩ ↦ 𝒜 ⟨i, hIsubset hi⟩)) := by
--   have ⟨h₁, h₂, h₃, h₄⟩ := 𝒜_spec ⟨⋃₀ I.toSet, hIunion⟩
--   simp at *
--   generalize hb : b{⟨⋃₀ I.toSet, hIunion⟩} = b
--   simp [hb] at h₁ h₂ h₃ h₄
--   sorry

def bI (I : Finset (Set (Set H[P]))) (hIsubset : I.toSet ⊆ ℬ{Set.univ}) : Set H[P] :=
  ⋃ i : I, b{⟨i.val, hIsubset i.prop⟩}

notation "bI{" I "," hIsubset "}" => bI I hIsubset

omit [Countable P] in
theorem bI_finite (I : Finset (Set (Set H[P]))) (hI : I.toSet ⊆ ℬ{Set.univ}) : bI{I, hI}.Finite := by
  refine Set.finite_iUnion ?_
  exact fun i ↦ b_B_Finite ⟨↑i, hI (Subtype.prop i)⟩

omit [Countable P] in
theorem bI_mem (I : Finset (Set (Set H[P]))) (hI : I.toSet ⊆ ℬ{Set.univ}) :
    ∀ i ∈ I, i ∈ ℬ{bI{I, hI}} := by
  intro i hi
  have ⟨hi₁, hi₂⟩ := b_B_gen_spec ⟨i, hI hi⟩
  apply ℬ_b_mono _ hi₂
  intro x hx
  simp_all only [b_B_Finite, Set.mem_iUnion, Subtype.exists, bI]
  use i, hi

omit [Countable P] in
theorem bI_subset (I : Finset (Set (Set H[P]))) (hI : I.toSet ⊆ ℬ{Set.univ}) :
    I.toSet ⊆ ℬ{bI{I, hI}} := bI_mem I hI

omit [Countable P] in
theorem bI_mem' (I : Finset (Set (Set H[P]))) (hI : I.toSet ⊆ ℬ{Set.univ}) :
    ⋃₀ I ∈ ℬ{bI{I, hI}} := by
  simp [Set.sUnion_eq_biUnion]
  exact IsSetAlgebra.biUnion_mem ℬ_b_IsSetAlgebra _ fun i hi ↦
    ℬ_b_mono (fun _ h ↦ by simp [bI]; exact BEx.intro i hi h) (b_B_gen_spec ⟨i, hI hi⟩).right

theorem 𝒜_B_b {b : Set H[P]} (hb : b.Finite) : 𝒜 ⟨B{b}, by simp⟩ hb = B{b} := by
  sorry
  -- have ⟨h₁, h₂, h₃, h₄, h₅⟩ := 𝒜_spec ⟨B{b}, by simp⟩
  -- symm at h₁
  -- ext x
  -- simp_all only [Set.mem_singleton_iff]
  -- constructor
  -- · intro h
  --   sorry
  -- · intro h
  --   have : A{b,b} = B{b} := by simp
  --   nth_rw 7 [← this] at h₁
  --   sorry
    -- if B{b}.Nonempty then
    --   simp only [true_iff, *] at h₄
    --   sorry
    -- if b = ∅ then
    --   subst_eqs
    --   simp_all
    --   sorry
    -- else
    --   have : b.Nonempty := by (expose_names; exact Set.nonempty_iff_ne_empty.mpr h)
    --   obtain ⟨x, hx⟩ := this

    --   sorry

theorem crazy_B_b {b : Set H[P]} (hb : b.Finite) :
    crazy μ ⟨B{b}, by simp⟩ = μ ⟨B{b}, by use b; simp [hb]⟩ := by
  simp [crazy]
  sorry
  -- rw [𝒜_B_b hb]
  -- rw [tsum_eq_single ⟨b, by simp⟩ (by simp)]
  -- simp
  -- simp [IE]
  -- rw [tsum_eq_single ⟨b, by simp; sorry⟩]
  -- · simp
  -- · simp

theorem tsum_subtype_eq [AddCommMonoid β] [TopologicalSpace β] (A B : Set α) (h : A = B) (f : A → β) :
    ∑' a : A, f a = ∑' b : B, f ⟨b.val, by simp_all⟩ := by
  subst_eqs
  rfl

theorem IE_indep_of_b (μ : B_b_fin (P:=P) → ENNReal) (a b₁ b₂ : Set H[P])
    (hb₁ : b₁.Finite) (hb₂ : b₂.Finite) : -- (hab₁ : a ⊆ b₁) (hab₂ : a ⊆ b₂) :
    IE μ a b₁ hb₁ = IE μ a b₂ hb₂ := by
  letI := middle_c_Fintype (a:=a) hb₁
  letI := middle_c_Fintype (a:=a) hb₂
  simp [IE, tsum_fintype]
  sorry

def condition (μ : B_b_fin (P:=P) → ENNReal) : Prop :=
  ∀ a b, ∀ h : b.Finite, 0 ≤ IE μ a b h

set_option maxHeartbeats 500000 in
open scoped Classical in
noncomputable def crazyAddContent' (μ : B_b_fin (P:=P) → ENNReal) (hμ : condition μ) :
    AddContent ℬ{(Set.univ : Set H[P])} where
  toFun B := if hB : B ∈ ℬ{Set.univ} then crazy μ ⟨B, hB⟩ else 0
  empty' := by simp [crazy, wild]
  sUnion' := by
    clear a b
    intro I hIsubset hIdisjoint hIunion
    have bIfinite := bI_finite I hIsubset
    have bIsubset := bI_subset I hIsubset
    have bIunion := bI_mem' I hIsubset
    simp_all only [dite_true]
    simp [Set.sUnion_eq_biUnion]
    simp_all only [crazy, dite_true]
    sorry

set_option maxHeartbeats 500000 in
open scoped Classical in
noncomputable def crazyAddContent (μ : B_b_fin (P:=P) → ENNReal) (hμ : condition μ) :
    AddContent ℬ{(Set.univ : Set H[P])} where
  toFun B := if hB : B ∈ ℬ{Set.univ} then crazy μ ⟨B, hB⟩ else 0
  empty' := by simp [crazy, wild]
  sUnion' := by
    sorry
    -- intro I hIsubset hIdisjoint hIunion
    -- simp_all only [crazy, Set.coe_setOf, Set.mem_setOf_eq, dite_true]
    -- have := 𝒜_sUnion I hIsubset hIdisjoint hIunion
    -- simp_all only [Finset.coe_image, Finset.coe_attach, Set.image_univ, Set.sUnion_range]
    -- rw [tsum_subtype_eq _ _ this]
    -- apply (ENNReal.toReal_eq_toReal_iff' ?_ ?_).mp
    -- · rw [ENNReal.toReal_sum]
    --   · rw [tsum_fintype]
    --     rw [ENNReal.ofReal_sum_of_nonneg]
    --     · rw [← tsum_fintype]
    --       rw [ENNReal.tsum_biUnion'' ?_]
    --       · simp only [tsum_fintype, Finset.univ_eq_attach]
    --         rw [ENNReal.toReal_sum]
    --         · simp only [Finset.mem_univ, ne_eq, ENNReal.ofReal_ne_top, not_false_eq_true, imp_self,
    --           implies_true, ENNReal.toReal_sum]
    --           apply Finset.sum_bij_ne_zero (fun ⟨x, _⟩ _ _ ↦ x)
    --           · simp only [Finset.mem_attach, ne_eq, Finset.coe_mem, implies_true, imp_self]
    --           · simp only [Finset.mem_attach, ne_eq, forall_const, Subtype.forall, Subtype.mk.injEq,
    --             imp_self, implies_true]
    --           · intro i hi
    --             simp only [hIsubset hi, ↓reduceDIte, ne_eq, exists_prop, Finset.mem_attach,
    --               exists_const, Subtype.exists, exists_and_right, exists_eq_right]
    --             intro h
    --             use i, hi
    --             simp only [and_true, true_and]
    --             rw [ENNReal.ofReal_sum_of_nonneg] at h
    --             · rw [ENNReal.toReal_sum] at h
    --               · contrapose! h
    --                 rw [← h]; clear h
    --                 simp only [hμ _, ENNReal.toReal_ofReal]
    --                 congr with a
    --                 apply IE_indep_of_b
    --               · simp only [Finset.mem_univ, ne_eq, ENNReal.ofReal_ne_top, not_false_eq_true,
    --                 imp_self, implies_true]
    --             · simp only [Finset.mem_univ, forall_const, Subtype.forall]
    --               intro a ha
    --               exact hμ a b{⟨i, hIsubset hi⟩} (b_B_Finite ⟨i, hIsubset hi⟩)
    --           · intro ⟨i, hi⟩ ha' h
    --             simp only [ne_eq, hIsubset hi, ↓reduceDIte]
    --             rw [ENNReal.ofReal_sum_of_nonneg, ENNReal.toReal_sum]
    --             · simp only [hμ _, ENNReal.toReal_ofReal]
    --               congr with a
    --               apply IE_indep_of_b
    --             · simp only [Finset.mem_univ, ne_eq, ENNReal.ofReal_ne_top, not_false_eq_true,
    --               imp_self, implies_true]
    --             · simp only [Finset.mem_univ, forall_const, Subtype.forall]
    --               intro a ha
    --               exact hμ a b{⟨i, hIsubset hi⟩} (b_B_Finite ⟨i, hIsubset hi⟩)
    --         · simp only [Finset.mem_attach, ne_eq, ENNReal.sum_eq_top, Finset.mem_univ,
    --           ENNReal.ofReal_ne_top, and_false, exists_false, not_false_eq_true, imp_self,
    --           implies_true]
    --       · intro x _ y _ hq s hsx hsy o ho
    --         simp_all only [Set.mem_univ, ne_eq, Set.le_eq_subset, Set.bot_eq_empty,
    --           Set.mem_empty_iff_false]
    --         contrapose! hq
    --         simp_all only [not_false_eq_true]
    --         have hox := hsx ho
    --         have hoy := hsy ho
    --         sorry
    --     · simp only [Finset.mem_univ, forall_const, Subtype.forall, Set.mem_iUnion, Subtype.exists,
    --       forall_exists_index]
    --       intro a i hi ha
    --       have := hμ a b{⟨⋃₀ I.toSet, hIunion⟩} (b_B_Finite ⟨⋃₀ I.toSet, hIunion⟩)
    --       exact this
    --   · intros; split_ifs <;> simp
    -- · simp only [ne_eq, ENNReal.ofReal_ne_top, not_false_eq_true]
    -- · simp only [ne_eq, ENNReal.sum_eq_top, not_exists, not_and]; intros; split_ifs <;> simp




open scoped Classical in
noncomputable def the_thing (hb : b.Finite) (hab : a ⊆ b) (p : ℕ → Prop) :=
  letI : Fintype ↑b := hb.fintype
  letI : Fintype ↑a := b.fintypeSubset hab
  let aCard := a.toFinset.card
  Finset.nepowerset b.toFinset
    |>.filter (fun (c : Finset H[P]) ↦ a ⊆ c.toSet ∧ p (c.val.card - aCard))

open scoped Classical in
/--
Extends a function from `{B{b} | b.Finite} → ENNReal` to `{A{a,b} | a ⊆ b ∧ b.Finite} → ENNReal`.
-/
noncomputable def extend_B_b_fin (μ : B_b_fin (P:=P) → ENNReal) :
    {(a, b) : Set H[P] × Set H[P] | a ⊆ b ∧ b.Finite} → ENNReal :=
  fun ⟨⟨a, b⟩, h⟩ ↦
    letI : Fintype ↑b := h.right.fintype
    letI : Fintype ↑a := b.fintypeSubset h.left
    let aCard := a.toFinset.card
    (∑ c : the_thing h.right h.left Odd, μ ⟨B{c.val}, by use c; simp_all⟩)
    - (∑ c : the_thing h.right h.left Even, μ ⟨B{c.val}, by use c; simp_all⟩)

-- noncomputable def extend_B_b_fin (μ : B_b_fin (P:=P) → ENNReal) :
--     ((fun ⟨a, b⟩ ↦ A{a,b}) '' {(a, b) : Set H[P] × Set H[P] | a ⊆ b ∧ b.Finite}) → ENNReal :=
--   fun ⟨A, h⟩ ↦ by
--     simp_all

--     letI : Fintype ↑b := h.right.fintype
--     letI : Fintype ↑a := b.fintypeSubset h.left
--     let aCard := a.toFinset.card
--     (∑ c : the_thing h.right h.left Odd, μ ⟨B{c.val}, by use c; simp_all⟩)
--     - (∑ c : the_thing h.right h.left Even, μ ⟨B{c.val}, by use c; simp_all⟩)


theorem ahsjdjas (hb : b.Finite) (hX : X ∈ B{b}) :
    extend_B_b_fin μ ⟨(b, b), by simp [hb]⟩ = μ ⟨B{b}, by simp [B_b_fin]; use b⟩ := by
  simp [extend_B_b_fin]
  if b = ∅ then
    subst_eqs
    simp_all
    sorry
  else
    sorry
    -- rw [Finset.sum_eq_single ⟨hb.toFinset, by simp_all⟩]
    -- · simp
    --   rw [Finset.sum_eq_zero]
    --   · simp
    --   · simp
    --     intro a ⟨ha, ha'⟩ ha''
    --     have : a = b := Set.Subset.antisymm ha ha''
    --     subst_eqs
    --     simp_all

    --     sorry
    -- · simp
    --   sorry
    -- · simp
    --   sorry

/--
Extends a function from `{A{a,b} | a ⊆ b ∧ b.Finite} → ENNReal` to `{B | B ∈ ℬ{b} ∧ b.Finite} →
ENNReal`.
-/
noncomputable def extend_A_ab (μ : {(a, b) : Set H[P] × Set H[P] | a ⊆ b ∧ b.Finite} → ENNReal) :
    {(b, B) : Set H[P] × Set (Set H[P]) | B ∈ ℬ{b} ∧ b.Finite} → ENNReal :=
  fun ⟨⟨b, B⟩, h⟩ ↦
    ∑' a : 𝒜 ⟨B, h.left⟩ h.right, μ ⟨⟨a, b⟩, by
      obtain ⟨a, ha⟩ := a
      have := 𝒜_spec ⟨B, h.left⟩ h.right
      have := h.right
      simp_all⟩

/--
Extends a function from `{B | B ∈ ℬ{b} ∧ b.Finite} → ENNReal` to `{B : Set (Set H[P]) | B ∈
ℬ{Set.univ}} → ENNReal`.
-/
noncomputable def extend_B (μ : {(b, B) : Set H[P] × Set (Set H[P]) | B ∈ ℬ{b} ∧ b.Finite} → ENNReal) :
    {B : Set (Set H[P]) | B ∈ ℬ{Set.univ}} → ENNReal :=
  fun ⟨B, h⟩ ↦ μ ⟨⟨ℬ_b_gen h, B⟩, by simp [ℬ_b_gen_spec h]⟩

open scoped Classical in
noncomputable def extend_AddContent (μ : B_b_fin (P:=P) → ENNReal) :
    AddContent ℬ{(Set.univ : Set H[P])} where
  toFun := fun B ↦
    if hB : B ∈ ℬ{Set.univ} then (μ |> extend_B_b_fin |> extend_A_ab |> extend_B) ⟨B, hB⟩ else 0
  empty' := by
    simp [extend_B_b_fin, extend_A_ab, extend_B]
  sUnion' := by
    simp_all only [extend_B, extend_A_ab, extend_B_b_fin, Finset.univ_eq_attach, dite_true]
    sorry

open scoped Classical in
noncomputable def extend_AddContent' (μ : Set (Set H[P]) → ENNReal) :
    AddContent ℬ{(Set.univ : Set H[P])} :=
  let μ' : B_b_fin (P:=P) → ENNReal := fun B ↦ μ B.val
  {
  toFun := fun B ↦
    if hB : B ∈ ℬ{Set.univ} then (μ' |> extend_B_b_fin |> extend_A_ab |> extend_B) ⟨B, hB⟩ else 0
  empty' := by
    simp_all only [ℬ_b_mem_empty, extend_B, extend_A_ab, extend_B_b_fin, Finset.univ_eq_attach,
      dite_true, ENNReal.tsum_eq_zero, Subtype.forall, μ']
    sorry
  sUnion' := by
    simp_all [extend_B, extend_A_ab, extend_B_b_fin, Finset.univ_eq_attach, dite_true, μ']
    intro I hIsub hIdis hIunion
    sorry
  }

theorem extend_AddContent_IsSigmaSubadditive : (extend_AddContent (P:=P) μ).IsSigmaSubadditive := by
  refine isSigmaSubadditive_of_addContent_iUnion_eq_tsum ℬ_b_IsSetRing ?_
  intro f hf hfU hfDis
  simp_all [extend_AddContent, DFunLike.coe]
  sorry

open scoped Classical in
def extend_measure_requirement (μ : B_b_fin (P:=P) → ENNReal) : Prop :=
  ∀ {a b : Set H[P]} (hab : a ⊆ b) (h : B{b} ∈ B_b_fin (P:=P) ∧ b.Finite),
  let h : Fintype ↑b := h.right.fintype
  (∑ c : Finset.nepowerset b.toFinset with a ⊆ c.val.toSet ∧ Even c.val.card,
    μ ⟨B{c.val}, by use c; simp_all⟩) ≤
  (∑ c : Finset.nepowerset b.toFinset with a ⊆ c.val.toSet ∧ Odd c.val.card,
    μ ⟨B{c.val}, by use c; simp_all⟩)

/--
Extends a function from `{B | B ∈ ℬ{Set.univ}} → ENNReal` to measure on `ℬ`.
-/
noncomputable def extend_measure (μ : B_b_fin (P:=P) → ENNReal) (h : extend_measure_requirement μ) :
    Measure[ℬ.borel] (Set H[P])  :=
  @AddContent.measure _ _ ℬ.borel (extend_AddContent μ) ℬ_b_IsSetSemiring
    ℬ_borel_le_generateFrom extend_AddContent_IsSigmaSubadditive

end ProbNetKAT
