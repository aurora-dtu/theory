import Mathlib.MeasureTheory.OuterMeasure.OfAddContent
import ProbNetKAT.Cantor
import ProbNetKAT.MathlibExt

/-!

# Measure extension

Formulation of **Theorem 1** stating that:

> A function `μ : { B{b} | b.Finite } → [0,1]` extends to a measure `μ : ℬ → [0,1]` under certain
> conditions.

The general outline of the proof of this theorem is as follows:
- First determining a finite `b` s.t. any `B ∈ ℬ` becomes a `B ∈ ℬ{b}`.
  - The `b` is given by `ProbNetKAT.ℬ_b_mem_iff_exists`.
  - The extension here is done by _Carathéodory's extension theorem_, given by
    `MeasureTheory.AddContent.measure`.
- The measure `μ B` of any such `B` can be written as the **finite disjoint union of atoms** (see
  `ProbNetKAT.ℬ_b_exists_decomposition`), giving us `∑ a, μ A{a,b}`.
- The measure `μ A{a,b}` can be further decomposed using _inclusion-exclusion_ (see
  `MeasureTheory.ennreal_inclusion_exclusion`). This then becomes a sum over `B{b}` by
  `ProbNetKAT.B_b_union_eq_inter`.

Connecting the steps defines a new measure on `ℬ` defined only on `B{b}` for finite `b`.

-/

set_option grind.warning false

namespace ProbNetKAT

open Topology MeasureTheory

variable {H : Type}

theorem asdadss (μ : @Measure (Set H) (ℬ.borel)) (hb : b.Finite) (hB : B ∈ ℬ{b}) :
    ∃ q : Set (Set H), μ B = ∑' a : q, μ A{a,b} := by
  obtain ⟨q, ⟨_⟩, hqDis, hqFin, hqSub⟩ := ℬ_b_exists_decomposition hB hb
  exact ⟨q, measure_biUnion hqFin.countable hqDis (ℬ_is_borel.mp ∘ A_ab_mem_ℬ hb <| hqSub · ·)⟩

theorem asdadss' (μ : @Measure (Set H) (ℬ.borel)) (hB : B ∈ ℬ{Set.univ}) :
    ∃ b, ∃ q : Set (Set H), μ B = ∑' a : q, μ A{a,b} := by
  replace ⟨b, hb, hB⟩ := ℬ_b_mem_iff_exists.mp hB
  exact ⟨b, asdadss μ hb hB⟩

/-- The set of all `B{b}` generated by `b` finite. -/
def B_b_fin : Set (Set (Set H)) := ((B{·}) '' {b : Set H | b.Finite})

noncomputable instance {b : Set H} (hb : b.Finite) : Fintype ↑{c | a ⊆ c ∧ c ⊆ b} := by
  simp only [Set.coe_setOf]
  have : {c | a ⊆ c ∧ c ⊆ b}.Finite := Set.Finite.subset (Set.Finite.finite_subsets hb) (by simp)
  have : Finite {c // a ⊆ c ∧ c ⊆ b} := this
  apply Fintype.ofFinite

noncomputable def mid_set {b : Finset H} (hab : a ⊆ b) : Finset (Finset H) :=
  have : Fintype ↑{c : Finset H | a ⊆ ↑c ∧ c ⊆ b} := by
    refine Set.Finite.fintype ?_
    have h₁ : { c : Finset H | a ⊆ c ∧ c ⊆ b } ⊆ { c : Finset H | c ⊆ b } := by simp_all
    have h₂ : {c | c ⊆ b}.Finite := by sorry
    exact Set.Finite.subset h₂ h₁
  @Set.toFinset _ {c | a ⊆ c ∧ c ⊆ b} this

@[simp]
theorem mid_set_mem_iff {a b : Finset H} {hab : a ⊆ b} :
    c ∈ mid_set hab ↔ a ⊆ c ∧ c ⊆ b := by simp [mid_set]

open scoped Classical in
@[simp]
theorem mid_set_insert {w : H} {a b : Finset H} (hab : a ⊆ insert w b) :
    mid_set hab = {c | a ⊆ c ∧ c ⊆ b} ∪ ((insert w ·) '' {c | a ⊆ c ∧ c ⊆ b}) := by
  ext c
  simp_all [Finset.insert_eq]
  constructor
  · simp_all
    intro hac hcwb
    if c ⊆ b then
      simp_all
    else
      simp_all
      have : c = {w} ∪ b := by
        ext
        simp_all
        sorry
      subst_eqs
      simp_all
      use b
      simp_all

      sorry
  · rintro (⟨h, h'⟩ | ⟨w', h, _, _⟩)
    · simp_all
      apply subset_trans h'
      simp
    · split_ands
      · apply subset_trans h.left Finset.subset_union_right
      · refine Finset.union_subset_union_right h.right


open scoped Classical in
theorem A_ab_inclusion_exclusion {a b : Finset H} (μ : Set (Set H) → ENNReal) (hab : a ⊆ b) :
    μ A{a,b} =
      (∑ c ∈ mid_set hab, if (c \ a).card % 2 = 0 then μ B{c} else 0)
      - ∑ c ∈ mid_set hab, if (c \ a).card % 2 = 1 then μ B{c} else 0 := by
  rw [A_ab_eq₂ (by simp_all)]
  simp
  induction b using Finset.induction with
  | empty =>
    have : a = ∅ := Finset.subset_empty.mp hab
    subst_eqs
    simp_all
    have : mid_set hab = {∅} := by ext; simp
    simp_all
    congr with
    simp
  | insert w b hwb ih =>
    have := mid_set_insert hab
    have : Fintype ↑({c | a ⊆ c ∧ c ⊆ b}) := sorry
    have : Fintype ↑((fun x => insert w x) '' {c | a ⊆ c ∧ c ⊆ b}) := sorry
    have : mid_set hab = ({c | a ⊆ c ∧ c ⊆ b} ∪ (fun x => insert w x) '' {c | a ⊆ c ∧ c ⊆ b}).toFinset := sorry
    have : mid_set hab = ({c | a ⊆ c ∧ c ⊆ b}).toFinset ∪ ((fun x => insert w x) '' {c | a ⊆ c ∧ c ⊆ b}).toFinset := sorry
    simp [this]
    rw [Finset.sum_union]
    · simp_all only [Set.toFinset_union, Set.toFinset_image, Finset.coe_union, Set.coe_toFinset,
      Finset.coe_image]

      sorry
    · intro S h₁ h₂ q hq
      simp_all
      have hwq : w ∈ q := by
        have := h₂ hq
        simp_all
        obtain ⟨_, _, _, _⟩ := this
        simp
      have : w ∈ b := by
        have := h₁ hq
        simp at this
        exact this.right hwq
      contradiction

def measure_of_fin_req (μ : B_b_fin (H:=H) → ENNReal) : Prop :=
  ∀ (a b : Finset H), (hab : a ⊆ b) →
    0 ≤ ∑' c : mid_set hab, (1/- **TODO:** this should be -1. -/)^sorry * μ ⟨B{c.val}, by
      use c; simp [B_b_fin]
      -- obtain ⟨c, hc⟩ := c
      -- have : c ⊆ b := by simp_all only [Set.mem_setOf_eq]
      -- exact Set.Finite.subset hb this
      ⟩

def ℬ_b_pick (B : Set (Set H)) (h : B ∈ ℬ{Set.univ}) : Set H := ℬ_b_mem_iff_exists.mp h |>.choose
def ℬ_b_pick_spec (B : Set (Set H)) (h : B ∈ ℬ{Set.univ}) :
    (ℬ_b_pick B h).Finite ∧ B ∈ ℬ{ℬ_b_pick B h} := ℬ_b_mem_iff_exists.mp h |>.choose_spec

theorem ℬ_b_decompsoe (hb : b.Finite) (hB : B ∈ ℬ{b}) :
    ∃ A : Set (Set H), (∀ a ∈ A, a ⊆ b) ∧ B = ⋃ a ∈ A, A{a,b} := by
  sorry

def ℬ_b_decompsoe_pick (b : Set H) (hb : b.Finite) (B : Set (Set H)) (hB : B ∈ ℬ{b}) : Set (Set H) :=
  (ℬ_b_decompsoe hb hB).choose
def ℬ_b_decompsoe_pick_spec (b : Set H) (hb : b.Finite) (B : Set (Set H)) (hB : B ∈ ℬ{b}) :
    (∀ a ∈ ℬ_b_decompsoe_pick b hb B hB, a ⊆ b) ∧ B = ⋃ a ∈ ℬ_b_decompsoe_pick b hb B hB, A{a,b} :=
  (ℬ_b_decompsoe hb hB).choose_spec

@[simp]
theorem ℬ_b_decompsoe_pick_empty_is_empty : ℬ_b_decompsoe_pick b hb ∅ (by simp) = ∅ := by
  have ⟨h₁, h₂⟩ := ℬ_b_decompsoe_pick_spec b hb ∅ (by simp)
  simp_all
  ext S
  simp_all
  constructor
  · intro h
    use S
    simp_all
  · simp
    intro S' hS' hS''
    absurd h₂
    rw [Set.ext_iff]
    simp
    use S, S'

/-- Extension to `μ(A{a,b})` for `a ⊆ b` and finite `b`. -/
noncomputable def extend_B_b_fin_A_ab (μ : B_b_fin (H:=H) → ENNReal) (a b : Set H) (ha : a ⊆ b) : ENNReal :=
  ∑' c : {c | a ⊆ c ∧ c ⊆ b}, μ ⟨B{c}, by
    exists c; simp
    suffices c.val.Finite by exact this
    sorry⟩

/-- Extension to `μ(B)` where `B ∈ ℬ{b}` for finite `b`. -/
noncomputable def extend_B_b_fin (μ : B_b_fin (H:=H) → ENNReal) (b : Set H) (hb : b.Finite) : ℬ{b} → ENNReal :=
  fun ⟨B, hB⟩ ↦
    ∑' a : ℬ_b_decompsoe_pick b hb B hB, extend_B_b_fin_A_ab μ a b ((ℬ_b_decompsoe_pick_spec b hb B hB).left a a.prop)

@[simp]
theorem extend_B_b_fin_apply (μ : B_b_fin (H:=H) → ENNReal) (b : Set H) (hb : b.Finite) (B : ℬ{b}) :
      extend_B_b_fin μ b hb B
    = ∑' a : ℬ_b_decompsoe_pick b hb B B.prop, extend_B_b_fin_A_ab μ a b ((ℬ_b_decompsoe_pick_spec b hb B B.prop).left a a.prop) := by
  simp [extend_B_b_fin]

/-- Extension to `μ(B)` where `B ∈ ℬ{Set.univ}`. -/
noncomputable def extend_B_b_fin' (μ : B_b_fin (H:=H) → ENNReal) : ℬ{(Set.univ : Set H)} → ENNReal :=
  fun ⟨B, hB⟩ ↦ extend_B_b_fin μ (ℬ_b_pick B hB) (ℬ_b_pick_spec B hB).left ⟨B, (ℬ_b_pick_spec B hB).right⟩

@[simp]
theorem extend_B_b_fin_empty (μ : B_b_fin (H:=H) → ENNReal) (b : Set H) (hb : b.Finite) :
    extend_B_b_fin μ b hb ⟨∅, by simp⟩ = 0 := by
  simp [extend_B_b_fin_A_ab]

@[simp]
theorem extend_B_b_fin'_apply' (μ : B_b_fin (H:=H) → ENNReal) (B) :
    extend_B_b_fin' μ B = extend_B_b_fin μ (ℬ_b_pick B B.prop) (ℬ_b_pick_spec B.val B.prop).left ⟨B, (ℬ_b_pick_spec B.val B.prop).right⟩ := by
  rfl

open scoped Classical in
noncomputable def AddContent_ofFin (μ : B_b_fin (H:=H) → ENNReal) (h : measure_of_fin_req μ) :
    AddContent ℬ{(Set.univ : Set H)} where
  toFun B := if hB : B ∈ ℬ{Set.univ} then extend_B_b_fin' μ ⟨B, hB⟩ else 0
  empty' := by simp
  sUnion' := by
    simp_all
    intro I hI hID hIU
    simp_all [extend_B_b_fin_A_ab]
    sorry

theorem AddContent_ofFin_IsSigmaSubadditive : (AddContent_ofFin μ h).IsSigmaSubadditive := by
  intro f hf hU
  simp_all [DFunLike.coe, AddContent_ofFin, dite_true, extend_B_b_fin_A_ab]
  sorry

-- μ(B) = μ(B') for B ∈ ℬ, s.t. B = B' where B' ∈ ℬ{2H}
-- μ(B) = μ(B') for B ∈ ℬ{2H} ∃ b finite, s.t. B = B' where B' ∈ ℬ{b}
-- μ(B) = μ(⋃ a ∈ q, A{a,b}) for B ∈ ℬ{b}
-- ...
-- μ(A{a,b}) = ∑ a ⊆ c ⊆ b, (-1)^|c \ a| • B{c}

/-- **Theorem 1.** A function `μ : {B{b} | b finite} → [0, 1]` extends to a measure `μ : ℬ → [0, 1]`
  iff for all finite `b` and all `a ⊆ b`

$$
∑_{a ⊆ c ⊆ b} (-1)^{|c \ a|} μ(B\{c\}) ≥ 0
$$

Moreover, the extension to `ℬ` is unique. -/
noncomputable def measure_of_fin (μ : B_b_fin (H:=H) → ENNReal) (h : measure_of_fin_req μ) :
    @Measure (Set H) (ℬ.borel) :=
  @AddContent.measure _ _ (ℬ.borel) (AddContent_ofFin μ h) ℬ_b_IsSetSemiring
    (by sorry) AddContent_ofFin_IsSigmaSubadditive

end ProbNetKAT
