import MDP.MarkovChain
import MDP.Paths.Prob

namespace MDP

variable {State Act : Type*}

@[grind =, simp]
theorem P'_get {M : MDP State Act} {h} : (M.P' s Î±).get h s' = M.P s Î± s' := by
  simp [P]
  split
  Â· grind only [= Option.get_some]
  Â· rename_i h'
    specialize h' ((M.P' s Î±).get (by grind))
    grind

@[grind =, simp]
theorem MScheduler.P'_isSome {M : MDP State Act} (â„’ : ğ”[M]) : (M.P' s (â„’ {s})).isSome = true := by
  have := (â„’.toScheduler.property {s})
  simp [act] at this
  unfold MDP.P at this
  split at this
  Â· grind
  Â· contrapose this; ext; simp

@[grind =, simp]
theorem Scheduler.P'_isSome {M : MDP State Act} (ğ’® : ğ”–[M]) (Ï€ : M.Path) :
    (M.P' Ï€.last (ğ’® Ï€)).isSome = true := by
  have := (ğ’®.property Ï€)
  simp [act] at this
  unfold MDP.P at this
  split at this
  Â· grind
  Â· contrapose this; ext; simp

def inducedMC (M : MDP State Act) (â„’ : ğ”[M]) (Î¹ : State) : MarkovChain State where
  P s := (M.P' s (â„’ {s})).get (by simp)
  Î¹ := Î¹

variable {M : MDP State Act} {â„’ : ğ”[M]} {Î¹ : State}

@[grind =, simp]
theorem inducedMC_P : (M.inducedMC â„’ Î¹).P s s' = M.P s (â„’ {s}) s' := by
  simp [inducedMC, MDP.P]

def Path.toMC (Ï€ : M.Path) (h : Ï€.Prob â„’ â‰  0) (h' : Ï€[0] = Î¹ := by rfl) :
    (M.inducedMC â„’ Î¹).Path where
  states := Ï€.states
  initial := by grind [inducedMC]
  property := by
    simp
    simp [Prob, Finset.prod_eq_zero_iff] at h
    intro i hi
    specialize h âŸ¨i, by grindâŸ©
    grind

/-- The probability of a path `Ï€` with memoryless scheduler `â„’` is the measure of the cylinder set
  generated by `Ï€` on the induced Markov Chain using `â„’`. -/
theorem inducedMC_cyl (Ï€ : M.Path) (h' : Ï€.Prob â„’ â‰  0) :
    (M.inducedMC â„’ Ï€[0]).Pr (Ï€.toMC h').Cyl = Ï€.Prob â„’ := by
  simp [MarkovChain.Pr_cyl, Path.toMC, Path.Prob]

/-- info: 'MDP.inducedMC_cyl' depends on axioms: [propext, Classical.choice, Quot.sound] -/
#guard_msgs in
#print axioms inducedMC_cyl

noncomputable def Path.pmf (Ï€ : M.Path) (ğ’® : ğ”–[M]) : PMF M.Path :=
  ((M.P' Ï€.last (ğ’® Ï€)).get (by simp)).bindOnSupport
    (fun s hs â†¦ PMF.pure (Ï€.extend âŸ¨s, by simp_all [MDP.succs_univ, MDP.succs]; grindâŸ©))

noncomputable def inducedMC' (M : MDP State Act) (ğ’® : ğ”–[M]) (Î¹ : State) :
    MarkovChain M.Path where
  P Ï€ := Ï€.pmf ğ’®
  Î¹ := {Î¹}

variable {ğ’® : ğ”–[M]}

@[grind =, simp]
theorem inducedMC'_P : (M.inducedMC' ğ’® Î¹).P s s' = s.pmf ğ’® s' := by
  simp [inducedMC']

def Path.toMC' (Ï€ : M.Path) (h : Ï€.Prob ğ’® â‰  0) (h' : Ï€[0] = Î¹ := by rfl) :
    (M.inducedMC' ğ’® Î¹).Path where
  states := List.ofFn (n:=â€–Ï€â€–) (Ï€.take Â·.val)
  initial := by grind [inducedMC']
  property := by
    simp
    simp [Prob, Finset.prod_eq_zero_iff] at h
    intro i hi
    specialize h âŸ¨i, by grindâŸ©
    simp [pmf]
    use Ï€[i + 1]
    use by grind
    ext
    Â· simp; grind
    Â· simp [take]
      grind

set_option maxHeartbeats 500000 in
/-- The probability of a path `Ï€` with scheduler `ğ’®` is the measure of the cylinder set generated
  by `Ï€` on the induced Markov Chain using `ğ’®`. -/
theorem inducedMC'_cyl (Ï€ : M.Path) (h' : Ï€.Prob ğ’® â‰  0) :
    (M.inducedMC' ğ’® Ï€[0]).Pr (Ï€.toMC' h').Cyl = Ï€.Prob ğ’® := by
  simp [MarkovChain.Pr_cyl, Path.toMC', Path.Prob]
  simp [Path.pmf]
  apply Finset.prod_bij_ne_one fun âŸ¨x, _âŸ© _ _ â†¦ âŸ¨x, by grindâŸ©
  Â· grind
  Â· grind
  Â· simp_all only [ne_eq, Finset.mem_univ, exists_true_left, forall_const]
    intro âŸ¨i, hiâŸ© h
    use âŸ¨i, by grindâŸ©
    simp
    rw [tsum_eq_single Ï€[i + 1]]
    Â· split_ifs
      Â· simp_all
      Â· grind
      Â· simp_all
    Â· simp_all only [ne_eq, dite_eq_left_iff, ite_eq_right_iff, imp_false]
      simp_all [Path.take, Path.extend]
      intro s' hs' h''
      contrapose! hs'
      have :
            ((List.take (i + 1 + 1) Ï€.states)[i + 1]'(by grind))
          = ((List.take (i + 1) Ï€.states ++ [s'])[i + 1]'(by grind)) := by grind
      grind
  Â· simp_all only [ne_eq, Finset.mem_univ, forall_true_left]
    intro âŸ¨i, hiâŸ© h
    rw [tsum_eq_single (Ï€[i + 1]'(by grind))]
    Â· simp_all only
      split_ifs with h h'
      Â· grind
      Â· grind
      Â· contrapose! h'
        ext
        Â· grind
        Â· simp [Path.take]; grind
    Â· simp_all only [ne_eq, dite_eq_left_iff, ite_eq_right_iff, imp_false]
      intro s' hs' h
      contrapose! hs'
      simp [Path.take, Path.extend] at hs'
      have :
            ((List.take (i + 1 + 1) Ï€.states)[i + 1]'(by grind))
          = ((List.take (i + 1) Ï€.states ++ [s'])[i + 1]'(by grind)) := by grind
      grind

/-- info: 'MDP.inducedMC'_cyl' depends on axioms: [propext, Classical.choice, Quot.sound] -/
#guard_msgs in
#print axioms inducedMC'_cyl

end MDP
