import WGCL.Syntax
import Mathlib.Algebra.Order.Monoid.Defs
import Mathlib.Algebra.Order.Monoid.Unbundled.Basic
import Mathlib.Algebra.Ring.Defs
import Mathlib.Data.ENNReal.Operations
import Mathlib.Order.FixedPoints
import Mathlib.Order.Notation
import Mathlib.Topology.Algebra.InfiniteSum.Defs
import Mathlib.Topology.Algebra.InfiniteSum.Order

class Subst (W Var E : Type) where
  /-- Written using `a[x ‚Ü¶ e]`. Substitutes all `x` in `a` with `e`. -/
  subst : W ‚Üí Var ‚Üí E ‚Üí W

@[inherit_doc Subst.subst]
syntax:max term noWs "[" withoutPosition(term) ppHardSpace "‚Ü¶" ppHardSpace withoutPosition(term) "]"
  : term
macro_rules | `($x[$i ‚Ü¶ $j]) => `(Subst.subst $x $i $j)

open Lean PrettyPrinter Delaborator SubExpr in
@[app_unexpander Subst.subst]
def Subst.substUnexpander : Unexpander
| `($(_) $m $x $v) => `($m[$x ‚Ü¶ $v])
| _ => throw ()

instance [BEq Œ±] [Hashable Œ±] : Subst (Std.HashMap Œ± Œ≤) Œ± Œ≤ where
  subst m x v := m.insert x v

section

variable (ùí≤ : Type) (‚Ñ≥ : Type)
variable [Monoid ùí≤] [AddCommMonoid ‚Ñ≥]

alias MonoidModule := DistribMulAction

variable [DistribMulAction ùí≤ ‚Ñ≥] (v w : ùí≤) (a b : ‚Ñ≥)

/-- (1) Scalar multiplication is associative. -/
example : (v * w) ‚Ä¢ a = v ‚Ä¢ (w ‚Ä¢ a) := MulAction.mul_smul v w a
/-- (2) Scalar multiplication is distributive. -/
example : v ‚Ä¢ (a + b) = (v ‚Ä¢ a) + (v ‚Ä¢ b) := DistribSMul.smul_add v a b
/-- (3) Scalar multiplication by one is identity. -/
example : v ‚Ä¢ (0 : ‚Ñ≥) = 0 := DistribMulAction.smul_zero v

variable (Var : Type)

abbrev ùïé (‚Ñ≥ : Type) (Var : Type) := Var ‚Üí ‚Ñ≥

instance Pi.instDistribMulAction : DistribMulAction ùí≤ (Œπ ‚Üí ‚Ñ≥) where
  smul_zero := by simp
  smul_add := by simp

instance : DistribMulAction ùí≤ (ùïé ‚Ñ≥ Var) := Pi.instDistribMulAction ùí≤ ‚Ñ≥

instance {ùíÆ : Type} [inst : Semiring ùíÆ] : DistribMulAction ùíÆ ùíÆ where
  smul_zero := by simp
  smul_add a b c := by simp [left_distrib]

class OmegaCompleteSemiring (ùíÆ : Type) [TopologicalSpace ùíÆ] extends Semiring ùíÆ where
  protected sum_mul_left {f : Œπ ‚Üí ùíÆ} {a : ùíÆ} : ‚àë' x, a * f x = a * ‚àë' x, f x
  protected sum_mul_right {f : Œπ ‚Üí ùíÆ} {a : ùíÆ} : ‚àë' x, f x * a = (‚àë' x, f x) * a
  protected sum_biUnion {S : Set Œπ} {f : Œ± ‚Üí ùíÆ} {t : Œπ ‚Üí Set Œ±}
    (h : S.PairwiseDisjoint t) : ‚àë' x : ‚ãÉ i ‚àà S, t i, f x = ‚àë' (i : S), ‚àë' (x : t i), f x

end

namespace List

def pairs (l : List Œ±) : List (Œ± √ó Œ±) := match l with
  | a :: b :: tail => (a, b) :: (b :: tail).pairs
  | _ => []

variable {l : List Œ±}

@[simp]
theorem pairs_cons (h : 0 < l.length) : (a :: l).pairs = (a, l[0]) :: l.pairs := by
  induction l with
  | nil => simp_all [pairs]; simp_all [pairs]
  | cons head tail ih => simp_all [pairs]

theorem pairs_of_tail (h : (a, b) ‚àà l.tail.pairs) : (a, b) ‚àà l.pairs := by
  induction l with
  | nil => simp_all [pairs]
  | cons head tail ih =>
    simp_all [pairs]
    if 0 < tail.length then
      simp_all
    else
      simp_all [pairs]

@[simp] theorem pairs_empty : ([] : List Œ±).pairs = [] := by simp [pairs]

@[simp]
theorem succ_mem_pairs (h : n + 1 < l.length) : (l[n], l[n + 1]) ‚àà l.pairs := by
  induction l generalizing n with
  | nil => simp_all; simp_all
  | cons head tail ih =>
    simp at h
    simp_all
    rw [getElem_cons]
    split_ifs
    ¬∑ subst_eqs
      rw [List.pairs_cons h]
      simp
    ¬∑ rw [List.pairs_cons]
      ¬∑ simp_all
        right
        have := ih (n:=n - 1) (by simp_all; omega)
        convert this
        omega
      ¬∑ omega

end List

namespace WGCL

variable {W Var : Type}

variable [Semiring W]
variable [CompleteLattice W]

set_option linter.unusedVariables false in
def AExpr.eval (E : AExpr Var) (œÉ : Mem W Var) : W :=
  match E with
  | .Const n => n
  | .Var x => œÉ x
  | wgcl_aexpr {~l + ~ r} => l.eval œÉ + r.eval œÉ
  | wgcl_aexpr {~l - ~ r} => 0 -- TODO: l.eval œÉ - r.eval œÉ
  | wgcl_aexpr {~l * ~ r} => l.eval œÉ * r.eval œÉ
  | wgcl_aexpr {~l / ~ r} => 0 -- TODO: l.eval œÉ / r.eval œÉ
  | wgcl_aexpr {-~l} => 0 -- TODO: -l.eval œÉ
def BExpr.eval (B : BExpr Var) (œÉ : Mem W Var) : Prop :=
  match B with
  | .Const b => b
  | wgcl_bexpr { ~l ‚àß ~ r } => l.eval œÉ ‚àß r.eval œÉ
  | wgcl_bexpr { ~l ‚à® ~ r } => l.eval œÉ ‚à® r.eval œÉ
  | wgcl_bexpr { ~l ‚Üí ~ r } => l.eval œÉ ‚Üí r.eval œÉ
  | wgcl_bexpr { ~l ‚Üî ~ r } => l.eval œÉ ‚Üî r.eval œÉ
  | wgcl_bexpr { ~l < ~ r } => l.eval œÉ < r.eval œÉ
  | wgcl_bexpr { ~l ‚â§ ~ r } => l.eval œÉ ‚â§ r.eval œÉ
  | wgcl_bexpr { ~l ‚â• ~ r } => l.eval œÉ ‚â• r.eval œÉ
  | wgcl_bexpr { ~l > ~ r } => l.eval œÉ > r.eval œÉ
  | wgcl_bexpr { ~l = ~ r } => l.eval œÉ = r.eval œÉ
  | wgcl_bexpr { ~l ‚â† ~ r } => l.eval œÉ ‚â† r.eval œÉ
  | .Uni .Not l => ¬¨l.eval œÉ

def BExpr.not (B : BExpr Var) : BExpr Var := .Uni .Not B

variable [DecidableEq Var]

instance : Subst (Mem W Var) Var W where
  subst œÉ x v := fun y ‚Ü¶ if x = y then v else œÉ y

instance : Subst (Weigting W Var) Var (AExpr Var) where
  subst f x E := fun œÉ ‚Ü¶ f œÉ[x ‚Ü¶ E.eval œÉ]

theorem Weigting.subst_mono {f‚ÇÅ f‚ÇÇ : Weigting W Var} (h : f‚ÇÅ ‚â§ f‚ÇÇ) (x : Var) (y : AExpr Var) :
    f‚ÇÅ[x ‚Ü¶ y] ‚â§ f‚ÇÇ[x ‚Ü¶ y] := by
  intro œÉ
  exact h fun y_1 => if x = y_1 then y.eval œÉ else œÉ y_1

variable [‚àÄ (B : BExpr Var) (œÉ : Mem W Var), Decidable (B.eval œÉ)]

def BExpr.iver (B : BExpr Var) : Weigting W Var := fun œÉ ‚Ü¶ if B.eval œÉ then 1 else 0

/-- A version of `OrderHom.lfp` that does not require `f` the `Monotone` upfront. -/
protected def wp.lfp {Œ±} [CompleteLattice Œ±] (f : Œ± ‚Üí Œ±) : Œ± := sInf {a | f a ‚â§ a}

namespace wp.lfp

variable [CompleteLattice Œ±]

theorem monotone : Monotone (wp.lfp (Œ±:=Œ±)) := by
  intro f g h
  simp_all [wp.lfp]
  intro x h'
  apply sInf_le
  simp [le_trans (h x) h']

@[simp] theorem wp_lfp_eq_lfp (f : Œ± ‚Üí Œ±) (h : Monotone f) : wp.lfp f = OrderHom.lfp ‚ü®f, h‚ü© := rfl
@[simp] theorem wp_lfp_eq_lfp_OrderHom (f : Œ± ‚Üío Œ±) : wp.lfp f = OrderHom.lfp f := rfl

end wp.lfp

instance : Semiring (Weigting W Var) := Pi.semiring
instance : CompleteLattice (Weigting W Var) := Pi.instCompleteLattice

@[simp]
instance : HMul W (Weigting W Var) (Weigting W Var) where
  hMul w f := fun œÉ ‚Ü¶ w * f œÉ

def wGCL.wp (C : wGCL W Var) (f : Weigting W Var) : Weigting W Var := match C with
| wgcl { ~x := ~E }                     => f[x ‚Ü¶ E]
| wgcl { ~C‚ÇÅ; ~C‚ÇÇ }                     => C‚ÇÅ.wp (C‚ÇÇ.wp f)
| wgcl { if (~œÜ) { ~C‚ÇÅ } else { ~C‚ÇÇ } } => œÜ.iver * C‚ÇÅ.wp f + œÜ.not.iver * C‚ÇÇ.wp f
| wgcl { { ~C‚ÇÅ } ‚äï { ~C‚ÇÇ } }            => C‚ÇÅ.wp f + C‚ÇÇ.wp f
| wgcl { ‚äô ~a }                         => a * f
| wgcl { while (~œÜ) { ~C' } }           => wp.lfp fun X ‚Ü¶ œÜ.iver * C'.wp X + œÜ.not.iver * f

@[simp] theorem wGCL.wp_assign {f : Weigting W Var} :
    (wgcl{~x := ~E}).wp f = f[x ‚Ü¶ E] := by simp [wp]
@[simp] theorem wGCL.wp_seq {f : Weigting W Var} :
    (wgcl{~C‚ÇÅ; ~C‚ÇÇ}).wp f = C‚ÇÅ.wp (C‚ÇÇ.wp f) := by simp [wp]
@[simp] theorem wGCL.wp_ite {f : Weigting W Var} :
    (wgcl{if (~œÜ) {~C‚ÇÅ} else {~C‚ÇÇ}}).wp f = œÜ.iver * C‚ÇÅ.wp f + œÜ.not.iver * C‚ÇÇ.wp f := by simp [wp]
@[simp] theorem wGCL.wp_branch {f : Weigting W Var} :
    (wgcl{{ ~C‚ÇÅ } ‚äï { ~C‚ÇÇ }}).wp f = C‚ÇÅ.wp f + C‚ÇÇ.wp f := by simp [wp]
@[simp] theorem wGCL.wp_weight {f : Weigting W Var} :
    (wgcl{‚äô ~a}).wp f = a * f := by simp [wp]

variable [AddRightMono W] [AddLeftMono W] [MulLeftMono W]

attribute [local simp] Function.swap
instance : AddRightMono (Weigting W Var) := ‚ü®by intro f‚ÇÅ f‚ÇÇ f‚ÇÉ h œÉ; simp; gcongr; apply_assumption‚ü©
instance : AddLeftMono  (Weigting W Var) := ‚ü®by intro f‚ÇÅ f‚ÇÇ f‚ÇÉ h œÉ; simp; gcongr; apply_assumption‚ü©
instance : MulLeftMono  (Weigting W Var) := ‚ü®by intro f‚ÇÅ f‚ÇÇ f‚ÇÉ h œÉ; simp; gcongr; apply_assumption‚ü©

theorem wGCL.wp_monotone (C : wGCL W Var) : Monotone C.wp := by
  induction C with (intro f‚ÇÅ f‚ÇÇ h; simp only [wp])
  | Branch C‚ÇÅ C‚ÇÇ ih‚ÇÅ ih‚ÇÇ => gcongr <;> (apply_assumption; assumption)
  | Weighting => gcongr
  | Assign => apply Weigting.subst_mono h
  | Ite => gcongr <;> apply_assumption <;> assumption
  | Seq => repeat (first | apply_assumption | assumption)
  | While => exact wp.lfp.monotone fun f ‚Ü¶ by gcongr

@[simp]
theorem wGCL.wp_while {C' : wGCL W Var} :
    wgcl { while (~œÜ) { ~C' } }.wp = fun f ‚Ü¶ OrderHom.lfp ‚ü®fun X ‚Ü¶ œÜ.iver * C'.wp X + œÜ.not.iver * f, by
      intro f‚ÇÅ f‚ÇÇ h
      simp
      gcongr
      exact wp_monotone _ h‚ü©
:= rfl

instance {n : ‚Ñï} : OfNat Bool n := ‚ü®n % 2 == 1‚ü©
-- instance : Semiring Bool where

def P‚ÇÅ : wGCL ‚Ñï String := wgcl {
  x := 0; y := 1;
  while (x ‚â† p) {
    if (x < y) { ‚äô1; x := x + 1 }
    else { ‚äô1; x := x - 1 };
    if (x = y) { y := -2 * y }
  }
}

/--
info: wgcl {x := 0; y := 1; while (x ‚â† p) {
        if (x < y) {
            ‚äô1; x := x + 1
          } else {
            ‚äô1; x := x - 1
          }; if (x = y) {
            y := -2 * y
          }
      }}
-/
#guard_msgs in
#eval P‚ÇÅ

inductive Act | N | L | R deriving Lean.ToExpr

structure Conf (W : Type) (Var : Type) where
  C : WithBot (wGCL W Var)
  œÉ : Mem W Var
  n : W
  Œ≤ : List Act

section Syntax

open Lean PrettyPrinter Delaborator SubExpr

syntax "conf" ppHardSpace "‚ü®" cwgcl_progr "," term "," term "," term "‚ü©" : term
syntax "conf" ppHardSpace "‚ü®" "‚ä•" "," term "," term "," term "‚ü©" : term

macro_rules
| `(conf ‚ü®‚ä•, $œÉ, $n, $Œ≤‚ü©) => `(({C:=‚ä•,œÉ:=$œÉ,n:=$n,Œ≤:=$Œ≤} : Conf _ _))
| `(conf ‚ü®$C, $œÉ, $n, $Œ≤‚ü©) => `(({C:=some wgcl{$C},œÉ:=$œÉ,n:=$n,Œ≤:=$Œ≤} : Conf _ _))

@[app_unexpander Conf.mk]
def Conf.unexpand : Unexpander
| `($(_) ‚ä• $œÉ $n $Œ≤) => `(conf ‚ü®‚ä•, $œÉ, $n, $Œ≤‚ü©)
| `($(_) $C $œÉ $n $Œ≤) =>
  match C with
  | `($_ wgcl {$C}) => `(conf ‚ü®$C, $œÉ, $n, $Œ≤‚ü©)
  | _ => throw ()
-- | `($(_) (some (wgcl{$C})) $œÉ $n $Œ≤) => `(conf ‚ü®$C, $œÉ, $n, $Œ≤‚ü©)
| _ => throw ()

end Syntax

/-- info: fun œÉ n Œ≤ ‚Ü¶ conf ‚ü®‚ä•,œÉ,n,Œ≤‚ü© : Mem W String ‚Üí W ‚Üí List Act ‚Üí Conf W String -/
#guard_msgs in
#check fun (œÉ : Mem W String) n Œ≤ ‚Ü¶ conf ‚ü®‚ä•, œÉ, n, Œ≤‚ü©

/-- info: fun œÉ n Œ≤ ‚Ü¶ conf ‚ü®x := E,œÉ,n,Œ≤‚ü© : Mem W String ‚Üí W ‚Üí List Act ‚Üí Conf W String -/
#guard_msgs in
#check fun (œÉ : Mem W String) n Œ≤ ‚Ü¶ conf ‚ü®x := E, œÉ, n, Œ≤‚ü©

syntax "op_rule" ppHardSpace
  "‚ü®" cwgcl_progr "," term "," term "," term "‚ü©"
  "‚ä¢[" term "]"
  "‚ü®" cwgcl_progr "," term "," term "," term "‚ü©"
  : term
syntax "‚ä•" : cwgcl_progr

@[aesop safe [constructors, cases]]
inductive Op : Conf W Var ‚Üí W ‚Üí Conf W Var ‚Üí Prop where
  | Assign : Op (conf ‚ü®~x := ~E, œÉ, n, Œ≤‚ü©) 1 (conf ‚ü®‚ä•, œÉ[x ‚Ü¶ E.eval œÉ], n+1, Œ≤‚ü©)
  | Weight : Op (conf ‚ü®‚äô ~a, œÉ, n, Œ≤‚ü©) a (conf ‚ü®‚ä•, œÉ, n+1, Œ≤‚ü©)
  | Seq‚ÇÅ :
      Op (conf ‚ü®~C‚ÇÅ, œÉ, n, Œ≤‚ü©) a (conf ‚ü®‚ä•, œÉ', n+1, Œ≤‚ü©) ‚Üí
    Op (conf ‚ü®~C‚ÇÅ ; ~C‚ÇÇ, œÉ, n, Œ≤‚ü©) a (conf ‚ü®~C‚ÇÇ, œÉ', n+1, Œ≤‚ü©)
  | Seq‚ÇÇ :
      Op (conf ‚ü®~C‚ÇÅ, œÉ, n, Œ≤‚ü©) a (conf ‚ü®~C‚ÇÅ', œÉ', n+1, Œ≤‚ü©) ‚Üí
    Op (conf ‚ü®~C‚ÇÅ ; ~C‚ÇÇ, œÉ, n, Œ≤‚ü©) a (conf ‚ü®~C‚ÇÅ' ; ~C‚ÇÇ, œÉ', n+1, Œ≤‚ü©)
  | If : (h : œÜ.eval œÉ) ‚Üí
    Op (conf ‚ü®if (~œÜ) {~C‚ÇÅ} else {~C‚ÇÇ}, œÉ, n, Œ≤‚ü©) 1 (conf ‚ü®~C‚ÇÅ, œÉ, n+1, Œ≤‚ü©)
  | Else : (h : ¬¨œÜ.eval œÉ) ‚Üí
    Op (conf ‚ü®if (~œÜ) {~C‚ÇÅ} else {~C‚ÇÇ}, œÉ, n, Œ≤‚ü©) 1 (conf ‚ü®~C‚ÇÇ, œÉ, n+1, Œ≤‚ü©)
  | BranchL :
    Op (conf ‚ü®{~C‚ÇÅ} ‚äï {~C‚ÇÇ}, œÉ, n, Œ≤‚ü©) 1 (conf ‚ü®~C‚ÇÅ, œÉ, n+1, .L::Œ≤‚ü©)
  | BranchR :
    Op (conf ‚ü®{~C‚ÇÅ} ‚äï {~C‚ÇÇ}, œÉ, n, Œ≤‚ü©) 1 (conf ‚ü®~C‚ÇÇ, œÉ, n+1, .R::Œ≤‚ü©)
  | While : (h : œÜ.eval œÉ) ‚Üí
    Op (conf ‚ü®while (~œÜ) {~C}, œÉ, n, Œ≤‚ü©) 1 (conf ‚ü®~C ; while (~œÜ) {~C}, œÉ, n+1, Œ≤‚ü©)
  | Break : (h : ¬¨œÜ.eval œÉ) ‚Üí
    Op (conf ‚ü®while (~œÜ) {~C}, œÉ, n, Œ≤‚ü©) 1 (conf ‚ü®‚ä•, œÉ, n+1, Œ≤‚ü©)

set_option quotPrecheck false in
macro_rules
| `(wgcl {‚ä•}) => `(‚ä•)
| `(op_rule ‚ü®$C, $œÉ, $n, $Œ≤‚ü© ‚ä¢[$a] ‚ü®$C', $œÉ', $n', $Œ≤'‚ü©) =>
  `(Op (conf ‚ü®$C,$œÉ,$n,$Œ≤‚ü©) $a (conf ‚ü®$C',$œÉ',$n',$Œ≤'‚ü©))

@[simp]
theorem Op.branch_iff {C‚ÇÅ C‚ÇÇ : wGCL W Var} :
      Op (conf ‚ü®{~C‚ÇÅ} ‚äï {~C‚ÇÇ}, œÉ, n, Œ≤‚ü©) a r
    ‚Üî a = 1 ‚àß (r = conf ‚ü®~C‚ÇÅ, œÉ, n+1, .L::Œ≤‚ü© ‚à® r = conf ‚ü®~C‚ÇÇ, œÉ, n+1, .R::Œ≤‚ü©) := by aesop

structure Paths (W : Type) (Var : Type) [Semiring W] [CompleteLattice W] [DecidableEq Var] where
  states : List (Conf W Var)
  h_pos : 0 < states.length
  pairwise : ‚àÄ ùí¶‚ÇÅ ùí¶‚ÇÇ, (ùí¶‚ÇÅ, ùí¶‚ÇÇ) ‚àà states.pairs ‚Üí ‚àÉ a, Op ùí¶‚ÇÅ a ùí¶‚ÇÇ

@[simp] def Paths.length_pos (œÄ : Paths W Var) : 0 < œÄ.states.length := œÄ.h_pos
@[simp] def Paths.nonempty (œÄ : Paths W Var) : œÄ.states ‚â† [] :=
  List.ne_nil_of_length_pos (œÄ.length_pos)
def Paths.last (œÄ : Paths W Var) : Conf W Var := œÄ.states.getLast (by simp)
def Paths.IsTerminal (œÄ : Paths W Var) : Prop := œÄ.last.C = ‚ä•

def TPaths (ùí¶‚ÇÄ : Conf W Var) : Set (Paths W Var) :=
  ‚ãÉ n, {œÄ | œÄ.states.length = n ‚àß œÄ.states[0] = ùí¶‚ÇÄ ‚àß œÄ.IsTerminal}

noncomputable def Conf.wgt (ùí¶‚ÇÅ ùí¶‚ÇÇ : Conf W Var) : W :=
  have : Decidable (‚àÉ Œ±, Op ùí¶‚ÇÅ Œ± ùí¶‚ÇÇ) := Classical.propDecidable _
  if h : ‚àÉ Œ±, Op ùí¶‚ÇÅ Œ± ùí¶‚ÇÇ then h.choose else 0

noncomputable def Paths.wgt (œÄ : Paths W Var) : W :=
  œÄ.states.pairs.map (fun (ùí¶‚ÇÅ, ùí¶‚ÇÇ) ‚Ü¶ ùí¶‚ÇÅ.wgt ùí¶‚ÇÇ) |>.sum

variable [TopologicalSpace W]

noncomputable def wGCL.op (C : wGCL W Var) (f : Weigting W Var) : Weigting W Var :=
  fun œÉ ‚Ü¶ ‚àë' œÄ : TPaths (conf ‚ü®~C, œÉ, 0, []‚ü©), œÄ.val.wgt * f œÄ.val.last.œÉ

def Succs (C : wGCL W Var) (œÉ : Mem W Var) :=
  { (a, C', œÉ') | ‚àÉ n Œ≤ Œ≤', Op (conf ‚ü®~C, œÉ, n, Œ≤‚ü©) a ‚ü®C', œÉ', n+1, Œ≤'‚ü© }

noncomputable def wGCL.Œ¶ (c : wGCL W Var ‚Üí Weigting W Var ‚Üí Weigting W Var) (C : wGCL W Var)
    (f : Weigting W Var) : Weigting W Var :=
  fun œÉ ‚Ü¶ ‚àë' X : Succs C œÉ, match X with | ‚ü®‚ü®a, some C', œÉ'‚ü©, _‚ü© => a * c C' f œÉ' | _ => 0


open OrderHom

variable [DecidableEq Var]
variable [Semiring W] [CompleteLattice W]
variable [TopologicalSpace W]
variable [IsOrderedAddMonoid W]
variable [SupConvergenceClass W] [CanonicallyOrderedAdd W]

@[simp] theorem W_hasSum {f : Œ± ‚Üí W} : HasSum f (‚®Ü s : Finset Œ±, ‚àë a ‚àà s, f a) :=
  tendsto_atTop_iSup fun _ _ ‚Ü¶ Finset.sum_le_sum_of_subset
@[simp] theorem W_summable {f : Œ± ‚Üí W} : Summable f := ‚ü®_, W_hasSum‚ü©

variable [OrderClosedTopology W]
variable [AddRightMono W] [AddLeftMono W] [MulLeftMono W]

variable [(B : BExpr Var) ‚Üí (œÉ : Mem W Var) ‚Üí Decidable (B.eval œÉ)]

def wGCL.Œ¶_mono : Monotone (Œ¶ (W:=W) (Var:=Var)) := by
  intro v‚ÇÅ v‚ÇÇ h C f œÉ
  simp only [Œ¶]
  apply Summable.tsum_le_tsum _ (by simp) (by simp)
  intro
  split
  ¬∑ gcongr
    apply_assumption
  ¬∑ rfl

@[simp]
def Succs_Branch {œÉ : Mem W Var} :
    Succs (wgcl { {~C‚ÇÅ} ‚äï {~C‚ÇÇ} }) œÉ = {(1, some C‚ÇÅ, œÉ), (1, some C‚ÇÇ, œÉ)} := by
  ext X
  simp [Succs]
  constructor
  ¬∑ aesop
  ¬∑ aesop
@[simp]
def Succs_Assign {œÉ : Mem W Var} : Succs (wgcl {~x := ~E}) œÉ = {(1, ‚ä•, œÉ[x ‚Ü¶ E.eval œÉ])} := by
  ext X
  simp [Succs]
  constructor
  ¬∑ aesop
  ¬∑ rintro ‚ü®_‚ü©; have n := 0; use n, [], []; apply Op.Assign
@[simp]
def Succs_Weight {œÉ : Mem W Var} : Succs (wgcl {‚äô ~E}) œÉ = {(E, ‚ä•, œÉ)} := by
  ext X
  simp [Succs]
  constructor
  ¬∑ aesop
  ¬∑ rintro ‚ü®_‚ü©; have n := 0; use n, [], []; apply Op.Weight
@[simp]
def Succs_Ite {œÉ : Mem W Var} :
      Succs (wgcl {if (~œÜ) { ~C‚ÇÅ } else { ~C‚ÇÇ }}) œÉ
    = if œÜ.eval œÉ then {(1, some C‚ÇÅ, œÉ)} else {(1, some C‚ÇÇ, œÉ)} := by
  ext X
  simp [Succs]
  constructor
  ¬∑ aesop
  ¬∑ split_ifs
    ¬∑ rintro ‚ü®_‚ü©; have n := 0; use n, [], []; apply Op.If (by assumption)
    ¬∑ rintro ‚ü®_‚ü©; have n := 0; use n, [], []; apply Op.Else (by assumption)
@[simp]
def Succs_Ite_If {œÉ : Mem W Var} (h : œÜ.eval œÉ) :
    Succs (wgcl {if (~œÜ) { ~C‚ÇÅ } else { ~C‚ÇÇ }}) œÉ = {(1, some C‚ÇÅ, œÉ)} := by
  simp_all
@[simp]
def Succs_Ite_Else {œÉ : Mem W Var} (h : ¬¨œÜ.eval œÉ) :
    Succs (wgcl {if (~œÜ) { ~C‚ÇÅ } else { ~C‚ÇÇ }}) œÉ = {(1, some C‚ÇÇ, œÉ)} := by
  simp_all
@[simp]
def Succs_While {œÉ : Mem W Var} :
      Succs (wgcl {while (~œÜ) { ~C }}) œÉ
    = if œÜ.eval œÉ then {(1, some wgcl {~C ; while (~œÜ) { ~C }}, œÉ)} else {(1, none, œÉ)} := by
  ext X
  simp [Succs]
  constructor
  ¬∑ aesop
  ¬∑ split_ifs
    ¬∑ rintro ‚ü®_‚ü©; have n := 0; use n, [], []; apply Op.While (by assumption)
    ¬∑ rintro ‚ü®_‚ü©; have n := 0; use n, [], []; apply Op.Break (by assumption)

theorem tsum_eq_pair {Œ± : Type u_1} {Œ≤ : Type u_2} [DecidableEq Œ≤] [AddCommMonoid Œ±]
    [TopologicalSpace Œ±] {f : Œ≤ ‚Üí Œ±} (b‚ÇÅ b‚ÇÇ : Œ≤) (hf : ‚àÄ (b' : Œ≤), b' ‚â† b‚ÇÅ ‚àß b' ‚â† b‚ÇÇ ‚Üí f b' = 0) :
‚àë' (b : Œ≤), f b = if b‚ÇÅ = b‚ÇÇ then f b‚ÇÅ else f b‚ÇÅ + f b‚ÇÇ := by
  rw [tsum_eq_sum (s:={b‚ÇÅ, b‚ÇÇ})]
  ¬∑ split_ifs <;> simp_all
  ¬∑ simp_all

def Paths.prepend (œÄ : Paths W Var) (c : Conf W Var) : Paths W Var where
  states := c :: œÄ.states
  h_pos := by simp
  pairwise := by
    simp [œÄ.pairwise]
    rintro ùí¶‚ÇÅ ùí¶‚ÇÇ (‚ü®_, h‚ü© | h)
    ¬∑ subst_eqs
      sorry
    ¬∑ simp_all [œÄ.pairwise]
def Paths.tail (œÄ : Paths W Var) : Paths W Var where
  states := if œÄ.states.length = 1 then œÄ.states else œÄ.states.tail
  h_pos := by split_ifs <;> simp_all; have := œÄ.h_pos; omega
  pairwise := by
    split_ifs
    ¬∑ simp_all [œÄ.pairwise]
    ¬∑ intro ùí¶‚ÇÅ ùí¶‚ÇÇ
      exact œÄ.pairwise ùí¶‚ÇÅ ùí¶‚ÇÇ ‚àò List.pairs_of_tail

@[simp]
theorem TPaths.branch {C‚ÇÅ C‚ÇÇ : wGCL W Var} :
      TPaths (conf ‚ü®{~C‚ÇÅ} ‚äï {~C‚ÇÇ}, œÉ, 0, []‚ü©)
    = (¬∑.prepend (conf ‚ü®{~C‚ÇÅ} ‚äï {~C‚ÇÇ}, œÉ, 0, []‚ü©))
      '' (TPaths (conf ‚ü®~C‚ÇÅ, œÉ, 1, .L::[]‚ü©) ‚à™ TPaths (conf ‚ü®~C‚ÇÇ, œÉ, 1, .R::[]‚ü©)) := by
  ext œÄ
  simp [TPaths, Paths.prepend]
  constructor
  ¬∑ intro ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©
    have : ¬¨œÄ.states.length = 1 := by
      intro h
      simp_all [Paths.tail, Paths.IsTerminal, Paths.last, List.getLast_eq_getElem]
    use œÄ.tail
    simp_all [Paths.tail, Paths.IsTerminal, Paths.last]
    obtain ‚ü®a, h‚ü© := œÄ.pairwise œÄ.states[0] (œÄ.states[1]'(by have := œÄ.h_pos; omega)) (by simp)
    simp_all
    obtain ‚ü®_, _, _‚ü© := œÄ
    obtain ‚ü®_, (‚ü®_‚ü© | ‚ü®_‚ü©)‚ü© := h
    ¬∑ subst_eqs; simp_all [List.cons_head?_tail, List.head?_eq_getElem?]
    ¬∑ subst_eqs; simp_all [List.cons_head?_tail, List.head?_eq_getElem?]
  ¬∑ rintro ‚ü®_, (‚ü®_, _‚ü© | ‚ü®_, _‚ü©), _, _‚ü©
    ¬∑ simp_all [Paths.tail, Paths.IsTerminal, Paths.last]
    ¬∑ simp_all [Paths.tail, Paths.IsTerminal, Paths.last]

@[simp]
theorem wGCP.op_branch {C‚ÇÅ C‚ÇÇ : wGCL W Var} : (C‚ÇÅ.Branch C‚ÇÇ).op = C‚ÇÅ.op + C‚ÇÇ.op := by
  ext f œÉ
  simp [wGCL.op]
  rw [TPaths.branch]
  rw [@Set.image_union]
  -- rw [Summable.tsum_union_disjoint]


  sorry

theorem wGCL.Œ¶_op_le_op : Œ¶ (W:=W) (Var:=Var) op ‚â§ op := by
  have : DecidableEq (W √ó WithBot (wGCL W Var) √ó Mem W Var) := Classical.typeDecidableEq _
  intro C
  induction C with
  | Branch C‚ÇÅ C‚ÇÇ ih‚ÇÅ ih‚ÇÇ =>
    intro f œÉ; simp [Œ¶]
    sorry
    -- rw [tsum_eq_pair ‚ü®(1, some C‚ÇÅ, œÉ), by simp‚ü© ‚ü®(1, some C‚ÇÇ, œÉ), by simp‚ü©]
    -- ¬∑ split_ifs <;> simp_all
    -- ¬∑ simp_all only [ne_eq, and_imp, Subtype.forall, Succs_Branch, Set.mem_insert_iff,
    --   Set.mem_singleton_iff, Subtype.mk.injEq, Prod.forall, Prod.mk.injEq, not_and]
    --   rintro w C' œÉ (‚ü®_, _, _‚ü© | ‚ü®_, _, _‚ü©) <;> subst_eqs
    --   ¬∑ simp
    --   ¬∑ simp
  | Weighting => intro f œÉ; simp [Œ¶]
  | Assign x E => intro f œÉ; simp [Œ¶]
  | Ite => sorry
  | Seq => sorry
  | While => sorry

theorem wGCL.Œ¶_seq_le (v) (C‚ÇÅ C‚ÇÇ : wGCL W Var) : Œ¶ v (wgcl {~C‚ÇÅ; ~C‚ÇÇ}) ‚â§ Œ¶ v C‚ÇÅ ‚àò Œ¶ v C‚ÇÇ := by
  intro f œÉ
  simp
  sorry

omit [IsOrderedAddMonoid W] [SupConvergenceClass W] [CanonicallyOrderedAdd W]
  [OrderClosedTopology W] [AddRightMono W] [AddLeftMono W] [MulLeftMono W] in
theorem wGCL.Œ¶_while {C : wGCL W Var} (h : v wgcl {skip} = 0) :
      Œ¶ v (wgcl { while (~œÜ) {~C} })
    = fun X ‚Ü¶ œÜ.iver * v (wgcl {~C; while (~œÜ) {~C}}) X + œÜ.not.iver * v (wgcl {skip}) X := by
  ext f œÉ
  if h : œÜ.eval œÉ then
    simp [Œ¶]
    rw [tsum_eq_single ‚ü®(1, wgcl {~C; while (~œÜ) {~C}}, œÉ), by simp_all; rfl‚ü©]
    ¬∑ simp_all [BExpr.iver, BExpr.not, BExpr.eval]
    ¬∑ simp_all [BExpr.iver, BExpr.not, BExpr.eval]
      contrapose!
      intro; rfl
  else
    simp [Œ¶]
    rw [tsum_eq_single ‚ü®(1, ‚ä•, œÉ), by simp_all; rfl‚ü©]
    ¬∑ simp_all [BExpr.iver, BExpr.not, BExpr.eval]
    ¬∑ simp_all [BExpr.iver, BExpr.not, BExpr.eval]

theorem wGCL.Œ¶_wp_le_wp : Œ¶ (W:=W) (Var:=Var) wp ‚â§ wp := by
  have : DecidableEq (W √ó WithBot (wGCL W Var) √ó Mem W Var) := Classical.typeDecidableEq _
  intro C
  induction C with
  | Branch C‚ÇÅ C‚ÇÇ ih‚ÇÅ ih‚ÇÇ =>
    intro f œÉ
    simp [Œ¶]
    rw [tsum_eq_pair ‚ü®(1, some C‚ÇÅ, œÉ), by simp‚ü© ‚ü®(1, some C‚ÇÇ, œÉ), by simp‚ü©]
    ¬∑ split_ifs <;> simp_all
    ¬∑ simp_all only [ne_eq, and_imp, Subtype.forall, Succs_Branch, Set.mem_insert_iff,
      Set.mem_singleton_iff, Subtype.mk.injEq, Prod.forall, Prod.mk.injEq, not_and]
      rintro w C' œÉ (‚ü®_, _, _‚ü© | ‚ü®_, _, _‚ü©) <;> subst_eqs
      ¬∑ simp
      ¬∑ simp
  | Weighting => intro f œÉ; simp [Œ¶]
  | Assign => intro f œÉ; simp [Œ¶]
  | Ite œÜ C‚ÇÅ C‚ÇÇ ih‚ÇÅ ih‚ÇÇ =>
    intro f œÉ
    if h : œÜ.eval œÉ then
      simp_all [Œ¶]
      rw [tsum_eq_single ‚ü®(1, some C‚ÇÅ, œÉ), by simp_all‚ü©]
      ¬∑ simp_all [BExpr.iver]
      ¬∑ simp_all [BExpr.iver]
    else
      simp_all [Œ¶]
      rw [tsum_eq_single ‚ü®(1, some C‚ÇÇ, œÉ), by simp_all‚ü©]
      ¬∑ simp_all [BExpr.iver, BExpr.not, BExpr.eval]
      ¬∑ simp_all [BExpr.iver]
  | Seq C‚ÇÅ C‚ÇÇ ih‚ÇÅ ih‚ÇÇ =>
    exact fun f ‚Ü¶ (Œ¶_seq_le wp C‚ÇÅ C‚ÇÇ f).trans (ih‚ÇÅ (Œ¶ wp C‚ÇÇ f) |>.trans (wp_monotone C‚ÇÅ (ih‚ÇÇ f)))
  | While œÜ C ih =>
    rw [wGCL.Œ¶_while]
    rw [wp_while]
    ¬∑ intro f
      simp
      nth_rw 2 [‚Üê map_lfp]
      simp only [coe_mk]
      gcongr
      intro œÉ
      simp_all
    ¬∑ ext; simp

theorem wGCL.op_eq_lfp_Œ¶ : wGCL.op (W:=W) (Var:=Var) = lfp ‚ü®Œ¶, Œ¶_mono‚ü© := by
  apply le_antisymm (le_lfp _ _) (lfp_le _ Œ¶_op_le_op)
  intro b h C
  simp_all only [coe_mk]
  sorry

theorem wGCL.op_isLeast (b : wGCL W Var ‚Üí Weigting W Var ‚Üí Weigting W Var) (h : Œ¶ b ‚â§ b) : op ‚â§ b := by
  sorry

-- theorem wGCL.Œ¶_op_le_op : Œ¶ (W:=W) (Var:=Var) op = op := by
--   funext C X œÉ
--   rw [op, ‚Üê MDP.map_lfp_Œ¶]
--   simp only [œÇ, OrderHom.coe_mk]
--   congr! 3 with C'
--   rcases C' with ‚ü®none, œÉ'‚ü© | ‚ü®C', œÉ'‚ü© | _ <;> simp [op]


theorem wGCL.wp_le_op : wp (W:=W) (Var:=Var) ‚â§ op := by
  intro C
  induction C with simp_all only
  | Branch C‚ÇÅ C‚ÇÇ ih‚ÇÅ ih‚ÇÇ =>
    sorry
  | Weighting => sorry
  | Assign => sorry
  | Ite œÜ C‚ÇÅ C‚ÇÇ ih‚ÇÅ ih‚ÇÇ => sorry
  | Seq C‚ÇÅ C‚ÇÇ ih‚ÇÅ ih‚ÇÇ => sorry
  | While œÜ C ih => sorry

theorem wGCL.wp.soundness :
    op (W:=W) (Var:=Var) = wp := by
  apply le_antisymm ?_ wp_le_op
  rw [op_eq_lfp_Œ¶]
  exact lfp_le _ Œ¶_wp_le_wp
