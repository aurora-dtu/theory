import Mathlib.Data.ENNReal.Inv
import Mathlib.Order.FixedPoints
import PGCL.WeakestPre
import MDP.Optimization

namespace pGCL

open OrderHom OmegaCompletePartialOrder
open scoped Optimization.Notation

variable {œñ : Type*} [DecidableEq œñ]

noncomputable def wfp (O : Optimization) : pGCL œñ ‚Üí ProbExp œñ ‚Üío ProbExp œñ
  | pgcl {skip} => ‚ü®fun X ‚Ü¶ X, fun ‚¶É_ _‚¶Ñ a ‚Ü¶ a‚ü©
  | pgcl {~x := ~A} => ‚ü®fun X ‚Ü¶ ‚ü®fun œÉ ‚Ü¶ X (œÉ[x ‚Ü¶ A œÉ]), by intro; simp‚ü©, fun ‚¶É_ _‚¶Ñ a i ‚Ü¶ a _‚ü©
  | pgcl {~C‚ÇÅ; ~C‚ÇÇ} => (C‚ÇÅ.wfp O).comp (C‚ÇÇ.wfp O)
  | pgcl {{~C‚ÇÅ} [~p] {~C‚ÇÇ}} =>
    ‚ü®fun X ‚Ü¶ ‚ü®p.pickProb (C‚ÇÅ.wfp O X) (C‚ÇÇ.wfp O X), by intro; simp‚ü©,
     fun a b hab ‚Ü¶ by apply ProbExp.pick_le <;> apply (wfp O _).mono hab‚ü©
  | pgcl {{~C‚ÇÅ}[]{~C‚ÇÇ}} =>
    ‚ü®O.opt‚ÇÇ (C‚ÇÅ.wfp O) (C‚ÇÇ.wfp O), fun a b hab ‚Ü¶ by simp only [Optimization.opt‚ÇÇ_apply]; gcongr‚ü©
  | pgcl {while ~b {~C'}} => ‚ü®fun X ‚Ü¶ lfp ‚ü®
      (fun Y ‚Ü¶ b.probOf.pickProb (C'.wfp O Y) X),
      fun _ _ _ ‚Ü¶ by simp; gcongr‚ü©, fun _ _ _ ‚Ü¶ by simp; gcongr; intro; simp; gcongr‚ü©
  | pgcl {tick(~e)} => ‚ü®(¬∑), fun _ _ h ‚Ü¶ by simp; gcongr‚ü©
  | pgcl {assert(~b)} => ‚ü®(b.probOf.pickProb ¬∑ 1), fun _ _ h ‚Ü¶ by simp; gcongr‚ü©

syntax "wfp[" term "]‚ü¶" cpgcl_prog "‚üß" : term

macro_rules
| `(wfp[$O]‚ü¶ $p ‚üß) => `(pGCL.wfp $O pgcl {$p})

@[app_unexpander pGCL.wfp]
def wfpUnexpander : Lean.PrettyPrinter.Unexpander
| `($(_) $o $c) => do
    let c ‚Üê match c with | `(pgcl {$c}) => pure c | _ => `(cpgcl_prog| ~ $c)
    `(wfp[$o]‚ü¶$c‚üß)
| _ => throw ()

noncomputable def wfp' (O : Optimization) : pGCL œñ ‚Üí Exp œñ ‚Üío Exp œñ
  | pgcl {skip} => ‚ü®fun X ‚Ü¶ X, fun ‚¶É_ _‚¶Ñ a ‚Ü¶ a‚ü©
  | pgcl {~x := ~A} => ‚ü®fun X œÉ ‚Ü¶ X (œÉ[x ‚Ü¶ A œÉ]), fun ‚¶É_ _‚¶Ñ a i ‚Ü¶ a _‚ü©
  | pgcl {~C‚ÇÅ; ~C‚ÇÇ} => (C‚ÇÅ.wfp' O).comp (C‚ÇÇ.wfp' O)
  | pgcl {{~C‚ÇÅ} [~p] {~C‚ÇÇ}} =>
    ‚ü®fun X ‚Ü¶ p.pick (C‚ÇÅ.wfp' O X) (C‚ÇÇ.wfp' O X),
     fun a b hab ‚Ü¶ by apply ProbExp.pick_le <;> apply (wfp' O _).mono hab‚ü©
  | pgcl {{~C‚ÇÅ}[]{~C‚ÇÇ}} =>
    ‚ü®O.opt‚ÇÇ (C‚ÇÅ.wfp' O) (C‚ÇÇ.wfp' O), fun a b hab ‚Ü¶ by simp only [Optimization.opt‚ÇÇ_apply]; gcongr‚ü©
  | pgcl {while ~b {~C'}} => ‚ü®fun X ‚Ü¶ lfp ‚ü®
      (fun Y ‚Ü¶ b.probOf.pick (C'.wfp' O Y) X),
      fun _ _ _ ‚Ü¶ by simp; gcongr‚ü©, fun _ _ _ ‚Ü¶ by simp; gcongr; intro; simp; gcongr‚ü©
  | pgcl {tick(~e)} => ‚ü®(¬∑), fun _ _ h ‚Ü¶ by simp; gcongr‚ü©
  | pgcl {assert(~b)} => ‚ü®(b.probOf.pick ¬∑ 1), fun _ _ h ‚Ü¶ by simp; gcongr‚ü©

syntax "wfp'[" term "]‚ü¶" cpgcl_prog "‚üß" : term

macro_rules
| `(wfp'[$O]‚ü¶ $p ‚üß) => `(pGCL.wfp' $O pgcl {$p})

@[app_unexpander pGCL.wfp']
def wfp'Unexpander : Lean.PrettyPrinter.Unexpander
| `($(_) $o $c) => do
    let c ‚Üê match c with | `(pgcl {$c}) => pure c | _ => `(cpgcl_prog| ~ $c)
    `(wfp'[$o]‚ü¶$c‚üß)
| _ => throw ()

theorem wfp_eq_wfp' {C : pGCL œñ} : wfp[O]‚ü¶~C‚üß X = wfp'[O]‚ü¶~C‚üß X := by
  induction C generalizing X with try simp [wfp, wfp', ProbExp.pick, ProbExp.pickProb, *]; done
  | nonDet C‚ÇÅ C‚ÇÇ ih‚ÇÅ ih‚ÇÇ =>
    simp [wfp, wfp', ‚Üê ih‚ÇÅ, ‚Üê ih‚ÇÇ]; ext; simp [Optimization.opt‚ÇÇ]
    cases O <;> simp
  | loop b C' ih =>
    simp [wfp, wfp']
    apply le_antisymm
    ¬∑ suffices
            lfp ‚ü®fun Y ‚Ü¶ b.probOf.pickProb (wfp[O]‚ü¶~C'‚üß Y) X, _‚ü©
          ‚â§ ‚ü®lfp ‚ü®fun Y ‚Ü¶ b.probOf.pick (wfp'[O]‚ü¶~C'‚üß Y) ‚áëX, _‚ü©, by
              apply lfp_le
              intro œÉ
              simp only [DFunLike.coe]
              simp [ProbExp.pick, -ProbExp.pick_of, BExpr.probOf]
              split_ifs
              ¬∑ simp
                specialize ih (X:=1)
                replace ih := congrFun ih œÉ
                have : (wfp[O]‚ü¶~C'‚üß 1) œÉ ‚â§ 1 := by simp
                rw [ih] at this
                exact this
              ¬∑ simp; apply ProbExp.le_one
              ‚ü© by
        exact this
      apply lfp_le
      simp
      intro œÉ
      simp
      nth_rw 2 [‚Üê map_lfp]
      simp [-map_lfp]
      simp [ProbExp.pick, ProbExp.pickProb, -ProbExp.pick_of]
      congr!
      apply ih
    ¬∑ apply lfp_le
      simp [‚Üê ih]
      nth_rw 2 [‚Üê map_lfp]
      simp [-map_lfp]
      rfl
  | assert => rfl

noncomputable def fŒ¶ (O : Optimization) (œÜ : BExpr œñ) [DecidablePred œÜ] (C' : pGCL œñ) (f : Exp œñ) :
    Exp œñ ‚Üío Exp œñ :=
  ‚ü®fun X ‚Ü¶ œÜ.probOf.pick (wfp'[O]‚ü¶~C'‚üß X) f, by intro _ _ _; simp; gcongr‚ü©

theorem wfp'_loop (œÜ  : BExpr œñ) (C' : pGCL œñ) [DecidablePred œÜ] :
    wfp'[O]‚ü¶while ~œÜ{~C'}‚üß f = lfp (fŒ¶ O œÜ C' f) := rfl

theorem wfp'_fp (œÜ : BExpr œñ) [DecidablePred œÜ] (C' : pGCL œñ) :
    (fŒ¶ O œÜ C' f) (wfp'[O]‚ü¶while ~œÜ{~C'}‚üß f) = wfp'[O]‚ü¶while ~œÜ{~C'}‚üß f := by simp [wfp'_loop]

theorem wfp_loop (œÜ  : BExpr œñ) (C' : pGCL œñ) [DecidablePred œÜ] :
    wfp[O]‚ü¶while ~œÜ{~C'}‚üß f = lfp (fŒ¶ O œÜ C' f) := by simp [wfp_eq_wfp', wfp'_loop]

noncomputable def wlp (O : Optimization) : pGCL œñ ‚Üí ProbExp œñ ‚Üío ProbExp œñ
  | pgcl {skip} => ‚ü®fun X ‚Ü¶ X, fun ‚¶É_ _‚¶Ñ a ‚Ü¶ a‚ü©
  | pgcl {~x := ~A} => ‚ü®fun X ‚Ü¶ ‚ü®fun œÉ ‚Ü¶ X (œÉ[x ‚Ü¶ A œÉ]), by intro; simp‚ü©, fun ‚¶É_ _‚¶Ñ a i ‚Ü¶ a _‚ü©
  | pgcl {~C‚ÇÅ; ~C‚ÇÇ} => (C‚ÇÅ.wlp O).comp (C‚ÇÇ.wlp O)
  | pgcl {{~C‚ÇÅ} [~p] {~C‚ÇÇ}} =>
    ‚ü®fun X ‚Ü¶ ‚ü®p.pickProb (C‚ÇÅ.wlp O X) (C‚ÇÇ.wlp O X), by intro; simp‚ü©,
     fun a b hab ‚Ü¶ by apply ProbExp.pick_le <;> apply (wlp O _).mono hab‚ü©
  | pgcl {{~C‚ÇÅ}[]{~C‚ÇÇ}} =>
    ‚ü®O.opt‚ÇÇ (C‚ÇÅ.wlp O) (C‚ÇÇ.wlp O), fun a b hab ‚Ü¶ by simp only [Optimization.opt‚ÇÇ_apply]; gcongr‚ü©
  | pgcl {while ~b {~C'}} => ‚ü®fun X ‚Ü¶ gfp ‚ü®
      (fun Y ‚Ü¶ b.probOf.pickProb (C'.wlp O Y) X),
      fun _ _ _ ‚Ü¶ by simp; gcongr‚ü©, fun _ _ _ ‚Ü¶ by simp; gcongr; intro; simp; gcongr‚ü©
  | pgcl {tick(~e)} => ‚ü®(¬∑), fun _ _ h ‚Ü¶ by simp; gcongr‚ü©
  | pgcl {assert(~b)} => ‚ü®(b.probOf * ¬∑), fun _ _ h ‚Ü¶ by simp; gcongr‚ü©

syntax "wlp[" term "]‚ü¶" cpgcl_prog "‚üß" : term

macro_rules
| `(wlp[$O]‚ü¶ $p ‚üß) => `(pGCL.wlp $O pgcl {$p})

@[app_unexpander pGCL.wlp]
def wlpUnexpander : Lean.PrettyPrinter.Unexpander
| `($(_) $o $c) => do
    let c ‚Üê match c with | `(pgcl {$c}) => pure c | _ => `(cpgcl_prog| ~ $c)
    `(wlp[$o]‚ü¶$c‚üß)
| _ => throw ()

noncomputable def wlp' (O : Optimization) : pGCL œñ ‚Üí ProbExp œñ ‚Üío ProbExp œñ
  | pgcl {skip} => ‚ü®fun X ‚Ü¶ X, fun ‚¶É_ _‚¶Ñ a ‚Ü¶ a‚ü©
  | pgcl {~x := ~A} => ‚ü®fun X ‚Ü¶ ‚ü®fun œÉ ‚Ü¶ X (œÉ[x ‚Ü¶ A œÉ]), by intro; simp‚ü©, fun ‚¶É_ _‚¶Ñ a i ‚Ü¶ a _‚ü©
  | pgcl {~C‚ÇÅ; ~C‚ÇÇ} => (C‚ÇÅ.wlp' O).comp (C‚ÇÇ.wlp' O)
  | pgcl {{~C‚ÇÅ} [~p] {~C‚ÇÇ}} =>
    ‚ü®fun X ‚Ü¶ ‚ü®p.pickProb (C‚ÇÅ.wlp' O X) (C‚ÇÇ.wlp' O X), by intro; simp‚ü©,
     fun a b hab ‚Ü¶ by apply ProbExp.pick_le <;> apply (wlp' O _).mono hab‚ü©
  | pgcl {{~C‚ÇÅ}[]{~C‚ÇÇ}} =>
    ‚ü®O.opt‚ÇÇ (C‚ÇÅ.wlp' O) (C‚ÇÇ.wlp' O), fun a b hab ‚Ü¶ by simp only [Optimization.opt‚ÇÇ_apply]; gcongr‚ü©
  | pgcl {while ~b {~C'}} => ‚ü®fun X ‚Ü¶ gfp ‚ü®
      (fun Y ‚Ü¶ b.probOf.pickProb (C'.wlp' O Y) X),
      fun _ _ _ ‚Ü¶ by simp; gcongr‚ü©, fun _ _ _ ‚Ü¶ by simp; gcongr; intro; simp; gcongr‚ü©
  | pgcl {tick(~e)} => ‚ü®(¬∑), fun _ _ h ‚Ü¶ by simp; gcongr‚ü©
  | pgcl {assert(~b)} => ‚ü®(b.probOf.pickProb ¬∑ 1), fun _ _ h ‚Ü¶ by simp; gcongr‚ü©

def wfp.continuous (C : pGCL œñ) : œâScottContinuous (C.wfp O) := by
  refine œâScottContinuous.of_map_œâSup_of_orderHom ?_
  simp [œâSup]
  sorry

attribute [- simp] Function.iterate_succ in
theorem wlp'_sound (C : pGCL œñ) (X : ProbExp œñ) :
    wlp[ùíü]‚ü¶~C.st‚üß X = 1 - wfp[ùíú]‚ü¶~C.st‚üß (1 - X) := by
  induction C generalizing X with
  | skip =>
    ext œÉ
    simp [wlp, wfp, st]
  | assign => ext œÉ; simp [st, wlp, wfp]
  | seq C‚ÇÅ C‚ÇÇ ih‚ÇÅ ih‚ÇÇ =>
    ext œÉ
    simp [wlp, wfp, st]
    rw [ih‚ÇÇ _, ih‚ÇÅ _ ]
    simp
  | prob C‚ÇÅ p C‚ÇÇ ih‚ÇÅ ih‚ÇÇ =>
    ext œÉ
    simp [wlp, wfp, st]
    simp [ih‚ÇÅ, ih‚ÇÇ]
    simp [ProbExp.pickProb, ProbExp.pick, -ProbExp.pick_of]
    simp [-ProbExp.pick_of, ENNReal.mul_sub]
    set f := wfp[ùíú]‚ü¶~C‚ÇÅ.st‚üß (1 - X) œÉ
    set g := wfp[ùíú]‚ü¶~C‚ÇÇ.st‚üß (1 - X) œÉ
    refine (ENNReal.toReal_eq_toReal_iff' ?_ ?_).mp ?_
    ¬∑ simp
    ¬∑ simp
    ¬∑ have hf : f ‚â§ 1 := by simp [f]
      have hg : g ‚â§ 1 := by simp [g]
      have hf' : f ‚â† ‚ä§ := (hf.trans_lt ENNReal.one_lt_top).ne
      have hg' : g ‚â† ‚ä§ := (hg.trans_lt ENNReal.one_lt_top).ne
      rw [ENNReal.toReal_add, ENNReal.toReal_sub_of_le, ENNReal.toReal_sub_of_le,
          ENNReal.toReal_sub_of_le, ENNReal.toReal_sub_of_le, ENNReal.toReal_add]
            <;> try simp [ENNReal.mul_ne_top, *]
      ¬∑ ring
      ¬∑ calc
          p œÉ * f + (1 - p œÉ) * g ‚â§ p œÉ * 1 + (1 - p œÉ) * 1 := by gcongr
          _ ‚â§ 1 := by simp
      ¬∑ calc (1 - p œÉ) * g ‚â§ (1 - p œÉ) * 1 := by gcongr
          _ ‚â§ 1 - p œÉ := by simp
      ¬∑ calc p œÉ * f ‚â§ p œÉ * 1 := by gcongr
          _ ‚â§ p œÉ := by simp
  | nonDet C‚ÇÅ C‚ÇÇ ih‚ÇÅ ih‚ÇÇ =>
    ext œÉ
    simp [wlp, st, Optimization.opt‚ÇÇ]
    simp [ih‚ÇÅ, ih‚ÇÇ]
    set f := wfp[ùíú]‚ü¶~C‚ÇÅ.st‚üß (1 - X) œÉ
    set g := wfp[ùíú]‚ü¶~C‚ÇÇ.st‚üß (1 - X) œÉ
    apply le_antisymm
    ¬∑ simp only [inf_le_iff]
      if hfg : f ‚â§ g then
        right
        gcongr
        refine max_le hfg (by rfl)
      else
        left
        gcongr
        simp at hfg
        refine max_le (by rfl) hfg.le
    ¬∑ simp only [le_inf_iff]
      constructor
      ¬∑ gcongr; exact le_max_left f g
      ¬∑ gcongr; exact le_max_right f g
  | loop b C' ih =>
    simp [wlp, st, wfp]
    simp [ih _]
    rw [fixedPoints.lfp_eq_sSup_iterate _ _, fixedPoints.gfp_eq_sInf_iterate _ _]
    ¬∑ simp
      ext œÉ
      simp [ENNReal.sub_iSup]
      apply le_antisymm
      ¬∑ simp
        intro i
        apply iInf_le_of_le (i + 1)
        induction i generalizing œÉ with
        | zero => simp
        | succ i ih =>
          nth_rw 2 [Function.iterate_succ']
          nth_rw 1 [Function.iterate_succ']
          simp
          set f := (fun Y ‚Ü¶ b.probOf.pickProb (1 - wfp[ùíú]‚ü¶~C'.st‚üß (1 - Y)) X)^[i + 1]
          set g := (fun Y ‚Ü¶ b.probOf.pickProb (wfp[ùíú]‚ü¶~C'.st‚üß Y) (1 - X))^[i]
          if b œÉ then
            simp_all only [ProbExp.pickProb, BExpr.probOf, ProbExp.mk_vcoe, ProbExp.coe_apply,
              Pi.add_apply, Pi.mul_apply, ‚ÜìreduceIte, ProbExp.sub_apply, ProbExp.one_apply, one_mul,
              Pi.sub_apply, Pi.ofNat_apply, tsub_self, zero_mul, add_zero]
            gcongr
            apply (wfp _ _).mono
            intro œÉ
            specialize ih œÉ
            simp
            refine ENNReal.le_sub_of_add_le_left ?_ ?_
            ¬∑ simp
            ¬∑ suffices hg : g ‚ä• œÉ ‚â§ 1 by
                exact (ENNReal.le_sub_iff_add_le_right (hg.trans_lt ENNReal.one_lt_top).ne hg).mp ih
              simp [g]
          else
            simp_all [ProbExp.pickProb, BExpr.probOf]
      ¬∑ simp
        intro i
        apply iInf_le_of_le i
        induction i generalizing œÉ with
        | zero => simp
        | succ i ih =>
          nth_rw 2 [Function.iterate_succ']
          nth_rw 1 [Function.iterate_succ']
          simp only [Function.comp_apply]
          set f := (fun Y ‚Ü¶ b.probOf.pickProb (wfp[ùíú]‚ü¶~C'.st‚üß Y) (1 - X))^[i]
          set g := (fun Y ‚Ü¶ b.probOf.pickProb (1 - wfp[ùíú]‚ü¶~C'.st‚üß (1 - Y)) X)^[i]
          if b œÉ then
            simp_all only [ProbExp.pickProb, BExpr.probOf, ProbExp.mk_vcoe, ProbExp.coe_apply,
              Pi.add_apply, Pi.mul_apply, ‚ÜìreduceIte, one_mul, Pi.sub_apply, Pi.ofNat_apply,
              tsub_self, ProbExp.sub_apply, ProbExp.one_apply, zero_mul, add_zero]
            gcongr
            apply (wfp _ _).mono
            intro œÉ
            simp
            exact tsub_le_iff_left.mp (ih œÉ)
          else
            simp_all only [ProbExp.pickProb, BExpr.probOf, ProbExp.mk_vcoe, tsub_le_iff_right,
              ProbExp.coe_apply, Pi.add_apply, Pi.mul_apply, ‚ÜìreduceIte, zero_mul, Pi.sub_apply,
              Pi.ofNat_apply, tsub_zero, ProbExp.sub_apply, ProbExp.one_apply, one_mul, zero_add,
              ProbExp.one_sub_one_sub_apply, le_refl]
    ¬∑ refine œâScottContinuous.of_monotone_map_œâSup ?_
      apply Exists.intro
      ¬∑ simp [œâSup]
        simp only [DFunLike.coe]
        simp
        intro c
        rw [‚Üê toDual_iInf]
        congr
        ext œÉ
        simp [BExpr.probOf, ProbExp.pickProb]
        split_ifs
        ¬∑ simp_all
          rw [‚Üê ENNReal.sub_iSup (by simp)]
          congr
          have := wfp.continuous C'.st (O:=ùíú)
          rw [œâScottContinuous_iff_map_œâSup_of_orderHom] at this
          simp [œâSup] at this
          let c' : Chain (ProbExp œñ) := c.map ‚ü®fun x ‚Ü¶ ‚ü®fun œÉ ‚Ü¶ 1 - x.val œÉ, by intro œÉ; simp‚ü©, fun a b hab œÉ ‚Ü¶ by
            simp only [ProbExp.coe_apply]; gcongr; apply hab‚ü©
          specialize this c'
          replace := congrArg DFunLike.coe this
          replace := congrFun this œÉ
          simp only at this
          convert this with œÉ'
          ¬∑ simp [c']
            ext œÉ'
            simp
            rw [‚Üê ENNReal.sub_iInf]
            rfl
          ¬∑ simp
            congr
        ¬∑ simp_all
      ¬∑ apply OrderHom.monotone
    ¬∑ refine œâScottContinuous_iff_map_œâSup_of_orderHom.mpr ?_
      intro c
      simp
      ext œÉ
      simp [œâSup]
      if hb : b œÉ then
        simp [hb, BExpr.probOf, ProbExp.pickProb]
        have := wfp.continuous C'.st (O:=ùíú)
        rw [œâScottContinuous_iff_map_œâSup_of_orderHom] at this
        simp [œâSup] at this
        specialize this c
        replace := congrArg DFunLike.coe this
        replace := congrFun this œÉ
        simp at this
        exact this
      else
        simp [hb, BExpr.probOf, ProbExp.pickProb]
  | tick => ext; simp [st, wlp, wfp]
  | assert b =>
    ext œÉ; simp [st, wlp, wfp, BExpr.probOf, ProbExp.pickProb]
    if hb : b œÉ then
      simp [hb]
    else
      simp [hb]

-- attribute [- simp] Function.iterate_succ in
-- theorem wlp'_sound (C : pGCL œñ) (X : ProbExp œñ) :
--     wlp' ùíü C.st X = 1 - wp ùíú C.st (1 - X) := by
--   induction C generalizing X with
--   | skip =>
--     ext œÉ
--     simp [wlp', st]
--   | assign => ext œÉ; simp [st, wlp']
--   | seq C‚ÇÅ C‚ÇÇ ih‚ÇÅ ih‚ÇÇ =>
--     ext œÉ
--     simp [wlp', st]
--     have ih‚ÇÅ' : ‚àÄ X, (wlp' ùíü C‚ÇÅ.st) X = ‚ü®1 - wp[ùíú]‚ü¶~C‚ÇÅ.st‚üß (1 - ‚áëX), by simp [‚Üê ih‚ÇÅ]; intro œÉ; simp‚ü©
--       := by intro X; ext œÉ; simp [ih‚ÇÅ]
--     have ih‚ÇÇ' : ‚àÄ X, (wlp' ùíü C‚ÇÇ.st) X = ‚ü®1 - wp[ùíú]‚ü¶~C‚ÇÇ.st‚üß (1 - ‚áëX), by simp [‚Üê ih‚ÇÇ]; intro œÉ; simp‚ü©
--       := by intro X; ext œÉ; simp [ih‚ÇÇ]
--     rw [ih‚ÇÇ' _, ih‚ÇÅ' _ ]
--     simp
--     congr! 2
--     ext œÉ
--     simp
--     refine ENNReal.sub_sub_cancel ?_ ?_
--     ¬∑ simp
--     ¬∑ apply wp_le_one
--       apply ProbExp.one_sub_le
--   | prob C‚ÇÅ p C‚ÇÇ ih‚ÇÅ ih‚ÇÇ =>
--     ext œÉ
--     simp [wlp', st]
--     have ih‚ÇÅ' : ‚àÄ X, (wlp' ùíü C‚ÇÅ.st) X = ‚ü®1 - wp[ùíú]‚ü¶~C‚ÇÅ.st‚üß (1 - ‚áëX), by simp [‚Üê ih‚ÇÅ]; intro œÉ; simp‚ü©
--       := by intro X; ext œÉ; simp [ih‚ÇÅ]
--     have ih‚ÇÇ' : ‚àÄ X, (wlp' ùíü C‚ÇÇ.st) X = ‚ü®1 - wp[ùíú]‚ü¶~C‚ÇÇ.st‚üß (1 - ‚áëX), by simp [‚Üê ih‚ÇÇ]; intro œÉ; simp‚ü©
--       := by intro X; ext œÉ; simp [ih‚ÇÇ]
--     simp [ih‚ÇÅ', ih‚ÇÇ']
--     simp [ProbExp.pickProb, ProbExp.pick, -ProbExp.pick_of]
--     simp [-ProbExp.pick_of, ENNReal.mul_sub]
--     set f := wp[ùíú]‚ü¶~C‚ÇÅ.st‚üß (1 - ‚áëX) œÉ
--     set g := wp[ùíú]‚ü¶~C‚ÇÇ.st‚üß (1 - ‚áëX) œÉ
--     refine (ENNReal.toReal_eq_toReal_iff' ?_ ?_).mp ?_
--     ¬∑ simp
--     ¬∑ simp
--     ¬∑ have hf : f ‚â§ 1 := wp_le_one _ _ ProbExp.one_sub_le _
--       have hg : g ‚â§ 1 := wp_le_one _ _ ProbExp.one_sub_le _
--       have hf' : f ‚â† ‚ä§ := (hf.trans_lt ENNReal.one_lt_top).ne
--       have hg' : g ‚â† ‚ä§ := (hg.trans_lt ENNReal.one_lt_top).ne
--       rw [ENNReal.toReal_add, ENNReal.toReal_sub_of_le, ENNReal.toReal_sub_of_le,
--           ENNReal.toReal_sub_of_le, ENNReal.toReal_sub_of_le, ENNReal.toReal_add]
--             <;> try simp [ENNReal.mul_ne_top, *]
--       ¬∑ ring
--       ¬∑ calc
--           p œÉ * f + (1 - p œÉ) * g ‚â§ p œÉ * 1 + (1 - p œÉ) * 1 := by gcongr
--           _ ‚â§ 1 := by simp
--       ¬∑ calc (1 - p œÉ) * g ‚â§ (1 - p œÉ) * 1 := by gcongr
--           _ ‚â§ 1 - p œÉ := by simp
--       ¬∑ calc p œÉ * f ‚â§ p œÉ * 1 := by gcongr
--           _ ‚â§ p œÉ := by simp
--   | nonDet C‚ÇÅ C‚ÇÇ ih‚ÇÅ ih‚ÇÇ =>
--     ext œÉ
--     simp [wlp', st, Optimization.opt‚ÇÇ]
--     have ih‚ÇÅ' : ‚àÄ X, (wlp' ùíü C‚ÇÅ.st) X = ‚ü®1 - wp[ùíú]‚ü¶~C‚ÇÅ.st‚üß (1 - ‚áëX), by simp [‚Üê ih‚ÇÅ]; intro œÉ; simp‚ü©
--       := by intro X; ext œÉ; simp [ih‚ÇÅ]
--     have ih‚ÇÇ' : ‚àÄ X, (wlp' ùíü C‚ÇÇ.st) X = ‚ü®1 - wp[ùíú]‚ü¶~C‚ÇÇ.st‚üß (1 - ‚áëX), by simp [‚Üê ih‚ÇÇ]; intro œÉ; simp‚ü©
--       := by intro X; ext œÉ; simp [ih‚ÇÇ]
--     simp [ih‚ÇÅ', ih‚ÇÇ']
--     set f := wp[ùíú]‚ü¶~C‚ÇÅ.st‚üß (1 - ‚áëX) œÉ
--     set g := wp[ùíú]‚ü¶~C‚ÇÇ.st‚üß (1 - ‚áëX) œÉ
--     apply le_antisymm
--     ¬∑ simp only [inf_le_iff]
--       if hfg : f ‚â§ g then
--         right
--         gcongr
--         refine max_le hfg (by rfl)
--       else
--         left
--         gcongr
--         simp at hfg
--         refine max_le (by rfl) hfg.le
--     ¬∑ simp only [le_inf_iff]
--       constructor
--       ¬∑ gcongr; exact le_max_left f g
--       ¬∑ gcongr; exact le_max_right f g
--   | loop b C' ih =>
--     simp [wlp', st, wp]
--     have ih' : ‚àÄ X, (wlp' ùíü C'.st) X = ‚ü®1 - wp[ùíú]‚ü¶~C'.st‚üß (1 - ‚áëX), by simp [‚Üê ih]; intro œÉ; simp‚ü©
--       := by intro X; ext œÉ; simp [ih]
--     simp [ih' _]
--     rw [fixedPoints.lfp_eq_sSup_iterate _ _, fixedPoints.gfp_eq_sInf_iterate _ _]
--     ¬∑ simp
--       ext œÉ
--       clear ih'
--       simp [ENNReal.sub_iSup]
--       apply le_antisymm
--       ¬∑ simp
--         intro i
--         apply iInf_le_of_le (i + 1)
--         induction i generalizing œÉ with
--         | zero => simp
--         | succ i ih =>
--           nth_rw 2 [Function.iterate_succ']
--           nth_rw 1 [Function.iterate_succ']
--           simp
--           set f := (fun Y ‚Ü¶ b.probOf.pickProb ‚ü®1 - wp[ùíú]‚ü¶~C'.st‚üß (1 - ‚áëY), _‚ü© X)^[i + 1]
--           set g := (fun x ‚Ü¶ i[b] * wp[ùíú]‚ü¶~C'.st‚üß x + i[b.not] * (1 - X))^[i]
--           if b œÉ then
--             simp_all only [ProbExp.pickProb, BExpr.probOf, ProbExp.coe_apply, Pi.add_apply,
--               Pi.mul_apply, ‚ÜìreduceIte, Pi.sub_apply, Pi.one_apply, one_mul, tsub_self, zero_mul,
--               add_zero, BExpr.true_iver, BExpr.true_not_iver]
--             gcongr
--             apply (wp _ _).mono
--             intro œÉ
--             specialize ih œÉ
--             simp
--             refine ENNReal.le_sub_of_add_le_left ?_ ?_
--             ¬∑ simp
--             ¬∑ suffices hg : g ‚ä• œÉ ‚â§ 1 by
--                 exact (ENNReal.le_sub_iff_add_le_right (hg.trans_lt ENNReal.one_lt_top).ne hg).mp ih
--               simp [g]
--               clear! f g ih
--               clear ih
--               induction i generalizing œÉ with
--               | zero => simp
--               | succ i ih =>
--                 simp [Function.iterate_succ']
--                 if b œÉ then
--                   simp_all
--                   apply wp_le_one C' _ ih
--                 else
--                   simp_all
--           else
--             simp_all [ProbExp.pickProb, BExpr.probOf]
--       ¬∑ simp
--         intro i
--         apply iInf_le_of_le i
--         induction i generalizing œÉ with
--         | zero => simp
--         | succ i ih =>
--           nth_rw 2 [Function.iterate_succ']
--           nth_rw 1 [Function.iterate_succ']
--           simp only [Function.comp_apply, Pi.add_apply, Pi.mul_apply, Pi.sub_apply, Pi.one_apply]
--           set f := (fun Y ‚Ü¶ b.probOf.pickProb ‚ü®1 - wp[ùíú]‚ü¶~C'.st‚üß (1 - ‚áëY), _‚ü© X)^[i]
--           set g := (fun x ‚Ü¶ i[b] * wp[ùíú]‚ü¶~C'.st‚üß x + i[b.not] * (1 - X))^[i]
--           if b œÉ then
--             simp_all only [BExpr.true_iver, one_mul, BExpr.true_not_iver, zero_mul, add_zero,
--               ProbExp.pickProb, BExpr.probOf, ProbExp.coe_apply, Pi.add_apply, Pi.mul_apply,
--               ‚ÜìreduceIte, Pi.sub_apply, Pi.one_apply, tsub_self]
--             gcongr
--             apply (wp _ _).mono
--             intro œÉ
--             simp
--             exact tsub_le_iff_left.mp (ih œÉ)
--           else
--             simp_all only [tsub_le_iff_right, Bool.false_eq_true, BExpr.false_iver, zero_mul,
--               BExpr.false_not_iver, one_mul, zero_add, ProbExp.pickProb, BExpr.probOf,
--               ProbExp.coe_apply, Pi.add_apply, Pi.mul_apply, ‚ÜìreduceIte, Pi.sub_apply, Pi.one_apply,
--               tsub_zero, ProbExp.le_one, add_tsub_cancel_of_le, le_refl]
--     ¬∑ refine œâScottContinuous.of_monotone_map_œâSup ?_
--       apply Exists.intro
--       ¬∑ simp [œâSup]
--         simp only [DFunLike.coe]
--         simp
--         intro c
--         rw [‚Üê toDual_iInf]
--         congr
--         ext œÉ
--         simp [BExpr.probOf, ProbExp.pickProb]
--         split_ifs
--         ¬∑ simp_all
--           rw [‚Üê ENNReal.sub_iSup (by simp)]
--           congr
--           have := wp.continuous C'.st (O:=ùíú)
--           rw [œâScottContinuous_iff_map_œâSup_of_orderHom] at this
--           simp [œâSup] at this
--           let c' : Chain (Exp œñ) := c.map ‚ü®fun x œÉ ‚Ü¶ 1 - x.val œÉ, fun a b hab œÉ ‚Ü¶ by
--             simp only; gcongr; apply hab‚ü©
--           specialize this c'
--           replace := congrFun this œÉ
--           simp only at this
--           convert this with œÉ'
--           simp [c']
--           have : ‚àÄ (p : ProbExp œñ), p.val œÉ' = p œÉ' := by intro; rfl
--           simp [this]
--           rw [‚Üê ENNReal.sub_iInf]
--           congr
--         ¬∑ simp_all
--       ¬∑ apply OrderHom.monotone
--     ¬∑ refine œâScottContinuous.of_apply‚ÇÇ ?_
--       intro œÉ
--       simp
--       refine œâScottContinuous_iff_monotone_map_œâSup.mpr ?_
--       apply Exists.intro
--       ¬∑ simp [œâSup]
--         simp only [DFunLike.coe]
--         intro c
--         simp only [toFun_eq_coe]
--         simp [‚Üê ENNReal.iSup_add, ‚Üê ENNReal.mul_iSup]
--         congr
--         have := wp.continuous C'.st (O:=ùíú)
--         rw [œâScottContinuous_iff_map_œâSup_of_orderHom] at this
--         simp [œâSup] at this
--         specialize this c
--         exact congrFun this œÉ
--       ¬∑ intro a b hab; simp
--         gcongr
--         apply (wp _ _).mono hab
--   | tick => ext; simp [st, wlp']
--   | assert b =>
--     ext œÉ; simp [st, wlp', wp, BExpr.probOf, ProbExp.pickProb]
--     if b œÉ then
--       simp_all only [‚ÜìreduceIte, tsub_self, add_zero, BExpr.true_iver, one_mul,
--       simp_all only [‚ÜìreduceIte, tsub_zero, zero_add, Bool.false_eq_true, BExpr.false_iver,
--         zero_mul]
--   | diverge =>
--     ext
--     simp only [st, wlp', coe_mk, Pi.one_apply, ProbExp.one_apply, wp.diverge, Pi.sub_apply,
--       tsub_self, one_ne_zero]
--     -- NOTE: BREAKS
--     sorry

-- theorem wlp_add_le (C : pGCL œñ) : wlp ùíú C.st ‚ü®X.val + Y.val, sorry‚ü© ‚â§ (wlp ùíú C.st X).val + wlp ùíú C.st Y := by
--   induction C generalizing X Y with try simp [wlp, st]; (try intro; simp [mul_add]; rfl)
--   | seq C‚ÇÅ C‚ÇÇ ih‚ÇÅ ih‚ÇÇ =>
--     set wlp‚ÇÅ := wlp ùíü C‚ÇÅ.st
--     set wlp‚ÇÇ := wlp ùíü C‚ÇÇ.st
--     grw [‚Üê ih‚ÇÅ]
--     apply (wlp _ _).mono
--     apply ih‚ÇÇ
--   | loop b C' ih =>
--     sorry
--   | nonDet C‚ÇÅ C‚ÇÇ ih‚ÇÅ ih‚ÇÇ =>
--     simp [Optimization.opt‚ÇÇ]
--     intro œÉ
--     simp
--     constructor
--     ¬∑ apply le_trans (ih‚ÇÅ _); simp; gcongr <;> exact le_max_left _ _
--     ¬∑ apply le_trans (ih‚ÇÇ _); simp; gcongr <;> exact le_max_right _ _
--   | prob => sorry
--   | diverge => intro; simp

-- theorem wlp_le_add (C : pGCL œñ) : (wlp ùíü C.st X).val + wlp ùíü C.st Y ‚â§ wlp ùíü C.st ‚ü®X.val + Y.val, sorry‚ü© := by
--   induction C generalizing X Y with try simp [wlp, st]; (try intro; simp [mul_add]; done)
--   | seq C‚ÇÅ C‚ÇÇ ih‚ÇÅ ih‚ÇÇ =>
--     set wlp‚ÇÅ := wlp ùíü C‚ÇÅ.st
--     set wlp‚ÇÇ := wlp ùíü C‚ÇÇ.st
--     grw [ih‚ÇÅ]
--     apply (wlp _ _).mono
--     apply ih‚ÇÇ
--   | loop b C' ih =>
--     sorry
--   | nonDet C‚ÇÅ C‚ÇÇ ih‚ÇÅ ih‚ÇÇ =>
--     simp [Optimization.opt‚ÇÇ]
--     intro œÉ
--     simp
--     constructor
--     ¬∑ apply le_trans _ (ih‚ÇÅ _); simp; gcongr <;> exact min_le_left _ _
--     ¬∑ apply le_trans _ (ih‚ÇÇ _); simp; gcongr <;> exact min_le_right _ _
--   | prob C‚ÇÅ p C‚ÇÇ ih‚ÇÅ ih‚ÇÇ =>
--     grw [‚Üê ih‚ÇÅ, ‚Üê ih‚ÇÇ]
--     simp [ProbExp.pick]
--     ring_nf; rfl
--   | diverge =>
--     intro; simp
--     -- NOTE: BREAKS
--     sorry

-- theorem wp_le_wlp (C : pGCL œñ) : wp ùíü C.st X.val ‚â§ wlp ùíü C.st X := by
--   induction C generalizing X with try simp [wp, wlp, st]; (try intro; simp [mul_add]; rfl)
--   | seq C‚ÇÅ C‚ÇÇ ih‚ÇÅ ih‚ÇÇ =>
--     intro œÉ
--     replace ih‚ÇÅ := fun {X} ‚Ü¶ ih‚ÇÅ (X:=X) œÉ
--     simp at ih‚ÇÅ
--     grw [‚Üê ih‚ÇÅ]
--     apply (wp _ _).mono
--     apply ih‚ÇÇ
--   | nonDet C‚ÇÅ C‚ÇÇ ih‚ÇÅ ih‚ÇÇ =>
--     intro œÉ
--     simp only [Optimization.opt‚ÇÇ, Pi.inf_apply, ProbExp.inf_apply]
--     gcongr
--     ¬∑ apply ih‚ÇÅ
--     ¬∑ apply ih‚ÇÇ
--   | prob C‚ÇÅ p C‚ÇÇ ih‚ÇÅ ih‚ÇÇ =>
--     simp [ProbExp.pick, ProbExp.pickProb]
--     gcongr
--     ¬∑ apply ih‚ÇÅ
--     ¬∑ apply ih‚ÇÇ
--   | loop b C' ih =>
--     intro œÉ
--     simp
--     apply le_trans _ (ProbExp.lfp_le_gfp'_apply _ _ _)
--     rotate_right
--     ¬∑ rfl
--     simp [lfp]
--     have : Nonempty ‚Üë{a | b.probOf.pickProb ((wlp ùíü C'.st) a) X ‚â§ a} := by use ‚ä§; simp
--     rw [ProbExp.sInf_apply (S:={a : ProbExp œñ | b.probOf.pickProb ((wlp ùíü C'.st) a) X ‚â§ a})]
--     simp
--     intro p h
--     apply iInf_le_of_le ‚ü®p, by
--       intro œÉ
--       specialize h œÉ
--       simp [BExpr.probOf, ProbExp.pickProb, BExpr.iver, BExpr.not] at h ‚ä¢
--       apply le_trans _ h
--       split_ifs
--       ¬∑ simp
--         apply ih
--       ¬∑ simp; rfl‚ü©
--     rfl
--   | diverge => rfl


-- attribute [- simp] Function.iterate_succ in
-- theorem wlp_sound (C : pGCL œñ) (X : ProbExp œñ) :
--     wp ùíü C.st X + wlp ùíü C.st 0 = wlp ùíü C.st X := by
--   -- let x : œñ := sorry
--   -- if C = pgcl { {~x := 1} [] { { assert(false) } [~‚ü®1/2, by sorry‚ü©] { skip } } } then
--   --   subst_eqs
--   --   simp [st, wlp, Optimization.opt‚ÇÇ, wp]
--   --   ext œÉ;
--   --   simp [ProbExp.pick, ProbExp.pickProb, BExpr.probOf]
--   --   simp [DFunLike.coe]



--   --   sorry
--   -- else

--   induction C generalizing X with
--   | skip => ext œÉ; simp [wlp, st]
--   | assign => ext œÉ; simp [st, wlp]
--   | seq C‚ÇÅ C‚ÇÇ ih‚ÇÅ ih‚ÇÇ =>
--     -- ext œÉ
--     simp [wlp, st]
--     have ih‚ÇÅ' : ‚àÄ (X : ProbExp œñ), ‚ü®wp[ùíü]‚ü¶~C‚ÇÅ.st‚üß ‚áëX + ‚áë((wlp ùíü C‚ÇÅ.st) 0), sorry‚ü© = (wlp ùíü C‚ÇÅ.st) X := by
--       intro; ext; simp; nth_rw 2 [‚Üê ih‚ÇÅ]; simp
--     have ih‚ÇÇ' : ‚àÄ (X : ProbExp œñ), ‚ü®wp[ùíü]‚ü¶~C‚ÇÇ.st‚üß ‚áëX + ‚áë((wlp ùíü C‚ÇÇ.st) 0), sorry‚ü© = (wlp ùíü C‚ÇÇ.st) X := by
--       intro; ext; simp; nth_rw 2 [‚Üê ih‚ÇÇ]; simp
--     nth_rw 2 [‚Üê ih‚ÇÅ']
--     simp [‚Üê ih‚ÇÇ' X]
--     apply le_antisymm
--     ¬∑ intro œÉ
--       simp
--       have := wp_le_add C‚ÇÅ (X:=wp[ùíü]‚ü¶~C‚ÇÇ.st‚üß ‚áëX) (Y:=‚áë((wlp ùíü C‚ÇÇ.st) 0)) œÉ
--       simp at this
--       grw [‚Üê this]
--       simp [add_assoc]
--       gcongr
--       rw [‚Üê ih‚ÇÅ]
--       rfl
--     ¬∑ nth_rw 2 [‚Üê ih‚ÇÅ]
--       intro œÉ
--       simp
--       have := wp_le_add C‚ÇÅ (X:=wlp ùíü C‚ÇÇ.st 0) (Y:=‚áë((wlp ùíü C‚ÇÅ.st) 0)) œÉ
--       simp at this
--       grw [this]
--       sorry

--     ext œÉ
--     simp
--     rw [‚Üê ih‚ÇÇ]
--     rw [‚Üê ih‚ÇÅ]
--     apply le_antisymm
--     ¬∑ simp [‚Üê add_assoc]
--       gcongr
--       apply wp_le_add
--     ¬∑ simp [‚Üê add_assoc]
--       rw [ih‚ÇÇ]
--       have : wp[ùíü]‚ü¶~C‚ÇÅ.st‚üß (‚áë((wlp ùíü C‚ÇÇ.st) 0)) œÉ + ((wlp ùíü C‚ÇÅ.st) 0) œÉ = (wlp ùíü (C‚ÇÅ.seq C‚ÇÇ).st) 0 œÉ := by
--         simp [wlp, st]
--         nth_rw 2 [‚Üê ih‚ÇÅ]
--         rfl
--       simp [st, wlp] at this
--       simp [add_assoc]
--       rw [this]
--       rw [‚Üê ih‚ÇÇ]
--       set wp‚ÇÅ := wp[ùíü]‚ü¶~C‚ÇÅ.st‚üß
--       set wp‚ÇÇ := wp[ùíü]‚ü¶~C‚ÇÇ.st‚üß
--       set wlp‚ÇÅ := wlp ùíü C‚ÇÅ.st
--       set wlp‚ÇÇ := wlp ùíü C‚ÇÇ.st
--       nth_rw 2 [‚Üê ih‚ÇÇ']
--       calc
--         wp‚ÇÅ (wp‚ÇÇ ‚áëX + ‚áë(wlp‚ÇÇ 0)) œÉ + (wlp‚ÇÅ 0) œÉ ‚â§
--             wp‚ÇÅ (wp‚ÇÇ ‚áëX) œÉ + (wlp‚ÇÅ ‚ü®wp‚ÇÇ 0, by sorry‚ü© œÉ + wlp‚ÇÅ (wlp‚ÇÇ 0) œÉ) :=
--           by
--             simp [‚Üê add_assoc]
--             rw [ih‚ÇÇ]
--             sorry
--         _ ‚â§
--             wp‚ÇÅ (wp‚ÇÇ ‚áëX) œÉ + (wlp‚ÇÅ ‚ü®wp‚ÇÇ 0 + ‚áë(wlp‚ÇÇ 0), _‚ü©) œÉ :=
--           by
--             gcongr
--             apply wlp_le_add



--       gcongr
--       ¬∑ apply (wp _ _).mono
--         rw [‚Üê ih‚ÇÇ]
--         intro œÉ
--         simp
--       ¬∑ apply (wlp _ _).mono
--         intro; simp
--   | prob C‚ÇÅ p C‚ÇÇ ih‚ÇÅ ih‚ÇÇ =>
--     ext œÉ
--     simp [wlp, st]
--     set wp‚ÇÅ := wp[ùíü]‚ü¶~C‚ÇÅ.st‚üß; set wp‚ÇÇ := wp[ùíü]‚ü¶~C‚ÇÇ.st‚üß
--     set wlp‚ÇÅ := wlp ùíü C‚ÇÅ.st; set wlp‚ÇÇ := wlp ùíü C‚ÇÇ.st
--     have ih‚ÇÅ' : ‚àÄ X, ‚ü®wp‚ÇÅ X.val + ‚áë(wlp‚ÇÅ 0), le_trans (ih‚ÇÅ X).le (ProbExp.le_one _)‚ü© = wlp‚ÇÅ X := by
--       intro X; ext œÉ; exact congrFun (ih‚ÇÅ X) œÉ
--     have ih‚ÇÇ' : ‚àÄ X, ‚ü®wp‚ÇÇ X.val + ‚áë(wlp‚ÇÇ 0), le_trans (ih‚ÇÇ X).le (ProbExp.le_one _)‚ü© = wlp‚ÇÇ X := by
--       intro X; ext œÉ; exact congrFun (ih‚ÇÇ X) œÉ
--     nth_rw 2 [‚Üê ih‚ÇÅ', ‚Üê ih‚ÇÇ']
--     simp [ProbExp.pickProb, ProbExp.pick, -ProbExp.pick_of]
--     ring_nf
--     nth_rw 3 [add_comm]
--     nth_rw 1 [add_assoc]
--     nth_rw 3 [add_comm]
--     nth_rw 1 [‚Üê add_assoc]
--     rfl
--   | nonDet C‚ÇÅ C‚ÇÇ ih‚ÇÅ ih‚ÇÇ =>
--     ext œÉ
--     simp [wlp, st, Optimization.opt‚ÇÇ]
--     set wp‚ÇÅ := wp[ùíü]‚ü¶~C‚ÇÅ.st‚üß; set wp‚ÇÇ := wp[ùíü]‚ü¶~C‚ÇÇ.st‚üß
--     set wlp‚ÇÅ := wlp ùíü C‚ÇÅ.st; set wlp‚ÇÇ := wlp ùíü C‚ÇÇ.st
--     have ih‚ÇÅ' : ‚àÄ X, ‚ü®wp‚ÇÅ X.val + ‚áë(wlp‚ÇÅ 0), le_trans (ih‚ÇÅ X).le (ProbExp.le_one _)‚ü© = wlp‚ÇÅ X := by
--       intro X; ext œÉ; exact congrFun (ih‚ÇÅ X) œÉ
--     have ih‚ÇÇ' : ‚àÄ X, ‚ü®wp‚ÇÇ X.val + ‚áë(wlp‚ÇÇ 0), le_trans (ih‚ÇÇ X).le (ProbExp.le_one _)‚ü© = wlp‚ÇÇ X := by
--       intro X; ext œÉ; exact congrFun (ih‚ÇÇ X) œÉ
--     nth_rw 2 [‚Üê ih‚ÇÅ', ‚Üê ih‚ÇÇ']
--     simp
--     -- set f := wp[ùíú]‚ü¶~C‚ÇÅ.st‚üß (1 - ‚áëX) œÉ
--     -- set g := wp[ùíú]‚ü¶~C‚ÇÇ.st‚üß (1 - ‚áëX) œÉ
--     apply le_antisymm
--     ¬∑ simp only [le_inf_iff]
--       constructor
--       ¬∑ gcongr <;> exact min_le_left _ _
--       ¬∑ gcongr <;> exact min_le_right _ _
--     ¬∑ -- simp only [-inf_le_iff]
--       rw [min_add]
--       gcongr
--       ¬∑ rfl
--       ¬∑ sorry
--       ¬∑ rfl
--       ¬∑ sorry
--       if h : wp‚ÇÅ X œÉ ‚â§ wp‚ÇÇ X œÉ then
--         have h' :  wlp‚ÇÅ 0 œÉ ‚â§ wlp‚ÇÇ 0 œÉ := by
--           rw [‚Üê ih‚ÇÅ, ‚Üê ih‚ÇÇ]
--           simp
--           gcongr

--           have h‚ÇÅ := wp_le_wlp C‚ÇÅ (X:=X) œÉ
--           have h‚ÇÇ := wp_le_wlp C‚ÇÇ (X:=X) œÉ
--           simp [wlp‚ÇÅ, wlp‚ÇÇ, wp‚ÇÅ, wp‚ÇÇ] at h‚ÇÅ h‚ÇÇ h ‚ä¢
--           have := h.trans h‚ÇÇ

--           apply le_trans _ h‚ÇÇ
--           apply le_trans _ h
--           sorry
--         sorry
--       else
--         sorry

--       -- if hfg : f ‚â§ g then
--       --   right
--       --   gcongr
--       --   refine max_le hfg (by rfl)
--       -- else
--       --   left
--       --   gcongr
--       --   simp at hfg
--       --   refine max_le (by rfl) hfg.le
--   | loop b C' ih =>
--     -- simp [wlp, st, wp]
--     -- sorry
--     have ih' : ‚àÄ X, (wlp ùíü C'.st) X = ‚ü®1 - wp[ùíú]‚ü¶~C'.st‚üß (1 - ‚áëX), by simp [‚Üê ih]; intro œÉ; simp‚ü©
--       := by intro X; ext œÉ; simp [ih]
--     simp [ih' _]
--     rw [fixedPoints.lfp_eq_sSup_iterate _ _, fixedPoints.gfp_eq_sInf_iterate _ _]
--     ¬∑ simp
--       ext œÉ
--       clear ih'
--       simp [ENNReal.sub_iSup]
--       apply le_antisymm
--       ¬∑ simp
--         intro i
--         apply iInf_le_of_le (i + 1)
--         induction i generalizing œÉ with
--         | zero => simp
--         | succ i ih =>
--           nth_rw 2 [Function.iterate_succ']
--           nth_rw 1 [Function.iterate_succ']
--           simp
--           set f := (fun Y ‚Ü¶ b.probOf.pickProb ‚ü®1 - wp[ùíú]‚ü¶~C'.st‚üß (1 - ‚áëY), _‚ü© X)^[i + 1]
--           set g := (fun x ‚Ü¶ i[b] * wp[ùíú]‚ü¶~C'.st‚üß x + i[b.not] * (1 - X))^[i]
--           if b œÉ then
--             simp_all only [ProbExp.pickProb, BExpr.probOf, ProbExp.coe_apply, Pi.add_apply,
--               Pi.mul_apply, ‚ÜìreduceIte, Pi.sub_apply, Pi.one_apply, one_mul, tsub_self, zero_mul,
--               add_zero, BExpr.true_iver, BExpr.true_not_iver]
--             gcongr
--             apply (wp _ _).mono
--             intro œÉ
--             specialize ih œÉ
--             simp
--             refine ENNReal.le_sub_of_add_le_left ?_ ?_
--             ¬∑ simp
--             ¬∑ suffices hg : g ‚ä• œÉ ‚â§ 1 by
--                 exact (ENNReal.le_sub_iff_add_le_right (hg.trans_lt ENNReal.one_lt_top).ne hg).mp ih
--               simp [g]
--               clear! f g ih
--               clear ih
--               induction i generalizing œÉ with
--               | zero => simp
--               | succ i ih =>
--                 simp [Function.iterate_succ']
--                 if b œÉ then
--                   simp_all
--                   apply wp_le_one C' _ ih
--                 else
--                   simp_all
--           else
--             simp_all [ProbExp.pickProb, BExpr.probOf]
--       ¬∑ simp
--         intro i
--         apply iInf_le_of_le i
--         induction i generalizing œÉ with
--         | zero => simp; rfl
--         | succ i ih =>
--           nth_rw 2 [Function.iterate_succ']
--           nth_rw 1 [Function.iterate_succ']
--           simp only [Function.comp_apply, Pi.add_apply, Pi.mul_apply, Pi.sub_apply, Pi.one_apply]
--           set f := (fun Y ‚Ü¶ b.probOf.pickProb ‚ü®1 - wp[ùíú]‚ü¶~C'.st‚üß (1 - ‚áëY), _‚ü© X)^[i]
--           set g := (fun x ‚Ü¶ i[b] * wp[ùíú]‚ü¶~C'.st‚üß x + i[b.not] * (1 - X))^[i]
--           if b œÉ then
--             simp_all only [BExpr.true_iver, one_mul, BExpr.true_not_iver, zero_mul, add_zero,
--               ProbExp.pickProb, BExpr.probOf, ProbExp.coe_apply, Pi.add_apply, Pi.mul_apply,
--               ‚ÜìreduceIte, Pi.sub_apply, Pi.one_apply, tsub_self]
--             gcongr
--             apply (wp _ _).mono
--             intro œÉ
--             simp
--             exact tsub_le_iff_left.mp (ih œÉ)
--           else
--             simp_all only [tsub_le_iff_right, Bool.false_eq_true, BExpr.false_iver, zero_mul,
--               BExpr.false_not_iver, one_mul, zero_add, ProbExp.pickProb, BExpr.probOf,
--               ProbExp.coe_apply, Pi.add_apply, Pi.mul_apply, ‚ÜìreduceIte, Pi.sub_apply, Pi.one_apply,
--               tsub_zero, ProbExp.le_one, add_tsub_cancel_of_le, le_refl]
--     ¬∑ refine œâScottContinuous.of_monotone_map_œâSup ?_
--       apply Exists.intro
--       ¬∑ simp [œâSup]
--         simp only [DFunLike.coe]
--         simp
--         intro c
--         rw [‚Üê toDual_iInf]
--         congr
--         ext œÉ
--         simp [BExpr.probOf, ProbExp.pickProb]
--         split_ifs
--         ¬∑ simp_all
--           rw [‚Üê ENNReal.sub_iSup (by simp)]
--           congr
--           have := wp.continuous C'.st (O:=ùíú)
--           rw [œâScottContinuous_iff_map_œâSup_of_orderHom] at this
--           simp [œâSup] at this
--           let c' : Chain (Exp œñ) := c.map ‚ü®fun x œÉ ‚Ü¶ 1 - x.val œÉ, fun a b hab œÉ ‚Ü¶ by
--             simp only; gcongr; apply hab‚ü©
--           specialize this c'
--           replace := congrFun this œÉ
--           simp only at this
--           convert this with œÉ'
--           simp [c']
--           have : ‚àÄ (p : ProbExp œñ), p.val œÉ' = p œÉ' := by intro; rfl
--           simp [this]
--           rw [‚Üê ENNReal.sub_iInf]
--           congr
--         ¬∑ simp_all
--       ¬∑ apply OrderHom.monotone
--     ¬∑ refine œâScottContinuous.of_apply‚ÇÇ ?_
--       intro œÉ
--       simp
--       refine œâScottContinuous_iff_monotone_map_œâSup.mpr ?_
--       apply Exists.intro
--       ¬∑ simp [œâSup]
--         simp only [DFunLike.coe]
--         intro c
--         simp only [toFun_eq_coe]
--         simp [‚Üê ENNReal.iSup_add, ‚Üê ENNReal.mul_iSup]
--         congr
--         have := wp.continuous C'.st (O:=ùíú)
--         rw [œâScottContinuous_iff_map_œâSup_of_orderHom] at this
--         simp [œâSup] at this
--         specialize this c
--         exact congrFun this œÉ
--       ¬∑ intro a b hab; simp
--         gcongr
--         apply (wp _ _).mono hab
--   | tick => ext; simp [st, wlp]
--   | assert b =>
--     ext œÉ; simp [st, wlp, wp, BExpr.probOf, BExpr.iver]

end pGCL
